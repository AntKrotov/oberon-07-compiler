MODULE WRITER;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mFile := FILES,
	mErr := ERRORS,
	mMash := MACHINE;

TYPE
	tpFile* = mFile.tpFile;

VAR
	counter*: INTEGER;

PROCEDURE Aligh_Get (pNum, pAlign: INTEGER): INTEGER;
	BEGIN
		IF pNum MOD pAlign # 0 THEN
			pNum := pNum + pAlign - (pNum MOD pAlign)
		END

		RETURN pNum
	END Aligh_Get;

PROCEDURE Byte_Write* (pFile: tpFile; pByte: BYTE);
	BEGIN
		IF mFile.WriteByte(pFile, pByte) THEN
			INC(counter)
		ELSE
			mErr.Error1("writing file error")
		END
	END Byte_Write;

PROCEDURE Write* (pFile: tpFile; pChunk: ARRAY OF BYTE; pLenBytes: INTEGER);
	VAR
		_len: INTEGER;
	BEGIN
		_len := mFile.Write(pFile, pChunk, pLenBytes);
		IF _len # pLenBytes THEN
			mErr.Error1("writing file error")
		END;
		INC(counter, _len)
	END Write;

PROCEDURE Write64LE* (pFile: tpFile; pLen: INTEGER);
	VAR
		_i: INTEGER;
	BEGIN
		FOR _i := 0 TO 7 DO
			Byte_Write(pFile, mMash.Byte(pLen, _i))
		END
	END Write64LE;

PROCEDURE Write32LE* (pFile: tpFile; pLen: INTEGER);
	VAR
		_i: INTEGER;
	BEGIN
		FOR _i := 0 TO 3 DO
			Byte_Write(pFile, mMash.Byte(pLen, _i))
		END
	END Write32LE;

PROCEDURE Write16LE* (pFile: tpFile; pLen: INTEGER);
	BEGIN
		Byte_Write(pFile, mMash.Byte(pLen, 0));
		Byte_Write(pFile, mMash.Byte(pLen, 1))
	END Write16LE;

PROCEDURE Padding* (pFile: tpFile; FileAlignment: INTEGER);
	VAR
		_i: INTEGER;
	BEGIN
		_i := Aligh_Get(counter, FileAlignment) - counter;
		WHILE _i > 0 DO
			Byte_Write(pFile, 0);
			DEC(_i)
		END
	END Padding;

PROCEDURE Create* (pFileName: ARRAY OF CHAR): tpFile;
	BEGIN
		counter := 0
		RETURN mFile.Create(pFileName)
	END Create;

PROCEDURE Close* (VAR pFile: tpFile);
	BEGIN
		mFile.Close(pFile)
	END Close;

END WRITER.
