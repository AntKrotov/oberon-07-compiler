MODULE WRITER;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mFile := FILES,
	mErr := ERRORS,
	mMash := MACHINE;

TYPE
	tpFile* = mFile.tpFile;

VAR
	counter*: INTEGER;

PROCEDURE Aligh_Get (pNum, pAlign: INTEGER): INTEGER;
	BEGIN
		IF pNum MOD pAlign # 0 THEN
			pNum := pNum + pAlign - (pNum MOD pAlign)
		END

		RETURN pNum
	END Aligh_Get;

PROCEDURE Byte_Write* (file: tpFile; n: BYTE);
	BEGIN
		IF mFile.WriteByte(file, n) THEN
			INC(counter)
		ELSE
			mErr.Error1("writing file error")
		END
	END Byte_Write;

PROCEDURE Write* (file: tpFile; chunk: ARRAY OF BYTE; bytes: INTEGER);
	VAR
		n: INTEGER;

	BEGIN
		n := mFile.Write(file, chunk, bytes);
		IF n # bytes THEN
			mErr.Error1("writing file error")
		END;
		INC(counter, n)
	END Write;

PROCEDURE Write64LE* (file: tpFile; n: INTEGER);
	VAR
		i: INTEGER;

	BEGIN
		FOR i := 0 TO 7 DO
			Byte_Write(file, mMash.Byte(n, i))
		END
	END Write64LE;

PROCEDURE Write32LE* (file: tpFile; n: INTEGER);
	VAR
		i: INTEGER;

	BEGIN
		FOR i := 0 TO 3 DO
			Byte_Write(file, mMash.Byte(n, i))
		END
	END Write32LE;

PROCEDURE Write16LE* (file: tpFile; n: INTEGER);
	BEGIN
		Byte_Write(file, mMash.Byte(n, 0));
		Byte_Write(file, mMash.Byte(n, 1))
	END Write16LE;

PROCEDURE Padding* (file: tpFile; FileAlignment: INTEGER);
	VAR
		i: INTEGER;

	BEGIN
		i := Aligh_Get(counter, FileAlignment) - counter;
		WHILE i > 0 DO
			Byte_Write(file, 0);
			DEC(i)
		END
	END Padding;

PROCEDURE Create* (FileName: ARRAY OF CHAR): tpFile;
	BEGIN
		counter := 0
		RETURN mFile.Create(FileName)
	END Create;

PROCEDURE Close* (VAR file: tpFile);
	BEGIN
		mFile.Close(file)
	END Close;

END WRITER.
