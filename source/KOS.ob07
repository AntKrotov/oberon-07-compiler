MODULE KOS;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mBin := BIN,
	mWrit := WRITER,
	mList := LISTS,
	mChl := CHUNKLISTS,
	mConst := modConstante;

TYPE
	tpFile = mWrit.tpFile;

	tHeader = RECORD
			menuet01: ARRAY 9 OF CHAR;
			ver, start, size, mem, sp, param, path: INTEGER
		END;

PROCEDURE Aligh_Get (pNum, pAlign: INTEGER): INTEGER;
	BEGIN
		IF pNum MOD pAlign # 0 THEN
			pNum := pNum + pAlign - (pNum MOD pAlign)
		END

		RETURN pNum
	END Aligh_Get;

PROCEDURE Import* (pProgram: mBin.PROGRAM; pData: INTEGER; VAR pImportTable: mChl.INTLIST; VAR pLen, pLibCount, pSize: INTEGER);
	VAR
		_i:      INTEGER;
		_import: mBin.IMPRT;
	BEGIN
		pLibCount  := 0;
		_import := pProgram.imp_list.first(mBin.IMPRT);
		WHILE _import # NIL DO
			IF _import.label = 0 THEN
				INC(pLibCount)
			END;
			_import := _import.next(mBin.IMPRT)
		END;

		pLen  := pLibCount * 2 + 2;
		pSize := (mList.count(pProgram.imp_list) + pLen + 1) * mConst.Kolibry_SizeDWORD;

		pImportTable := mChl.CreateIntList();
		FOR _i := 0 TO pSize DIV mConst.Kolibry_SizeHeader - 1 DO
			mChl.PushInt(pImportTable, 0)
		END;

		_i := 0;
		_import := pProgram.imp_list.first(mBin.IMPRT);
		WHILE _import # NIL DO

			IF _import.label = 0 THEN
				mChl.SetInt(pImportTable, pLen, 0);
				INC(pLen);
				mChl.SetInt(pImportTable, _i, pData + pLen * mConst.Kolibry_SizeDWORD);
				INC(_i);
				mChl.SetInt(pImportTable, _i, _import.nameoffs + pSize + pData);
				INC(_i)
			ELSE
				mChl.SetInt(pImportTable, pLen, _import.nameoffs + pSize + pData);
				_import.label := pLen * mConst.Kolibry_SizeDWORD;
				INC(pLen)
			END;

			_import := _import.next(mBin.IMPRT)
		END;
		mChl.SetInt(pImportTable, pLen, 0);
		mChl.SetInt(pImportTable, _i, 0);
		mChl.SetInt(pImportTable, _i + 1, 0);
		INC(pLen);
		pSize := pSize + mChl.Length(pProgram.import)
	END Import;

PROCEDURE Write* (pProgram: mBin.PROGRAM; pFileName: ARRAY OF CHAR);
	VAR
		_header: tHeader;
		_base, _text, _data, _idata, _bss: INTEGER;
		_reloc:   mBin.RELOC;
		_iproc:   mBin.IMPRT;
		_L:       INTEGER;
		_delta:   INTEGER;
		_i: INTEGER;
		_file: tpFile;
		_importTable: mChl.INTLIST;
		_ILen, _libCount, _isize: INTEGER;
		_icount, _dcount, _ccount: INTEGER;
	BEGIN
		_base := 0;

		_icount := mChl.Length(pProgram.import);
		_dcount := mChl.Length(pProgram.data);
		_ccount := mChl.Length(pProgram.code);

		_text  := _base + mConst.Kolibry_SizeHeader;
		_data  := Aligh_Get(_text + _ccount, mConst.Kolibry_FileAlignment);
		_idata := Aligh_Get(_data + _dcount, mConst.Kolibry_FileAlignment);

		Import(pProgram, _idata, _importTable, _ILen, _libCount, _isize);

		_bss := Aligh_Get(_idata + _isize, mConst.Kolibry_FileAlignment);

		_header.menuet01 := mConst.Kolibry_sName;
		_header.ver      :=  1;
		_header.start    :=  _text;
		_header.size     :=  _idata + _isize - _base;
		_header.mem      :=  Aligh_Get(_header.size + pProgram.stack + pProgram.bss + 
									mConst.Kolibry_SizeParam * 2 + 4096,
									mConst.Kolibry_FileAlignment);
		_header.sp       :=  _base + _header.mem - mConst.Kolibry_SizeParam * 2;
		_header.param    :=  _header.sp;
		_header.path     :=  _header.param + mConst.Kolibry_SizeParam;


		_reloc := pProgram.rel_list.first(mBin.RELOC);
		WHILE _reloc # NIL DO

			_L := mBin.get32le(pProgram.code, _reloc.offset);
			_delta := 3 - _reloc.offset - _text;

			CASE _reloc.opcode OF

			|mBin.RIMP:
				  _iproc := mBin.GetIProc(pProgram, _L);
				  mBin.put32le(pProgram.code, _reloc.offset, _idata + _iproc.label)

			|mBin.RBSS:
				  mBin.put32le(pProgram.code, _reloc.offset, _L + _bss)

			|mBin.RDATA:
				  mBin.put32le(pProgram.code, _reloc.offset, _L + _data)

			|mBin.RCODE:
				  mBin.put32le(pProgram.code, _reloc.offset, mBin.GetLabel(pProgram, _L) + _text)

			|mBin.PICDATA:
				  mBin.put32le(pProgram.code, _reloc.offset, _L + _data + _delta)

			|mBin.PICCODE:
				  mBin.put32le(pProgram.code, _reloc.offset, mBin.GetLabel(pProgram, _L) + _text + _delta)

			|mBin.PICBSS:
				  mBin.put32le(pProgram.code, _reloc.offset, _L + _bss + _delta)

			|mBin.PICIMP:
				  _iproc := mBin.GetIProc(pProgram, _L);
				  mBin.put32le(pProgram.code, _reloc.offset, _idata + _iproc.label + _delta)

			|mBin.IMPTAB:
				  mBin.put32le(pProgram.code, _reloc.offset, _idata + _delta)

			END;

			_reloc := _reloc.next(mBin.RELOC)
		END;

		_file := mWrit.Create(pFileName);

		FOR _i := 0 TO 7 DO
			mWrit.Byte_Write(_file, ORD(_header.menuet01[_i]))
		END;

		mWrit.Write32LE(_file, _header.ver);
		mWrit.Write32LE(_file, _header.start);
		mWrit.Write32LE(_file, _header.size);
		mWrit.Write32LE(_file, _header.mem);
		mWrit.Write32LE(_file, _header.sp);
		mWrit.Write32LE(_file, _header.param);
		mWrit.Write32LE(_file, _header.path);
		
		mChl.WriteToFile(_file, pProgram.code);
		mWrit.Padding(_file, mConst.Kolibry_FileAlignment);

		mChl.WriteToFile(_file, pProgram.data);
		mWrit.Padding(_file, mConst.Kolibry_FileAlignment);

		FOR _i := 0 TO _ILen - 1 DO
			mWrit.Write32LE(_file, mChl.GetInt(_importTable, _i))
		END;      
		
		mChl.WriteToFile(_file, pProgram.import);

		mWrit.Close(_file)
	END Write;

END KOS.
