MODULE AVLTREES;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mCol := COLLECTIONS;

TYPE
	tpData* = POINTER TO RECORD (mCol.tpItem) END;

	tpNode* = POINTER TO RECORD (mCol.tpItem)
			data*: tpData;
			height: INTEGER;
			left*, right*: tpNode
		END;

	tCMP = PROCEDURE (a, b: tpData): INTEGER;

	tDesctuctor = PROCEDURE (VAR data: tpData);

VAR
	nodes: mCol.tpCollection;

PROCEDURE New (pData: tpData): tpNode;
	VAR
		_node:  tpNode;
		_colItem: mCol.tpItem;
	BEGIN  
		_colItem := mCol.Pop(nodes);
		IF _colItem = NIL THEN
			NEW(_node)
		ELSE
			_node := _colItem(tpNode)
		END;

		_node.data := pData;
		_node.left := NIL;
		_node.right := NIL;
		_node.height := 1

		RETURN _node
	END New;

PROCEDURE Height_Get (pNode: tpNode): INTEGER;
	VAR
		_res: INTEGER;
	BEGIN
		IF pNode = NIL THEN
			_res := 0
		ELSE
			_res := pNode.height
		END

		RETURN _res
	END Height_Get;

PROCEDURE BFactor_Get (pNode: tpNode): INTEGER;
		RETURN Height_Get(pNode.right) - Height_Get(pNode.left)
	END BFactor_Get;

PROCEDURE Height_Fix (pNode: tpNode);
	BEGIN
		pNode.height := MAX(Height_Get(pNode.left), Height_Get(pNode.right)) + 1
	END Height_Fix;

PROCEDURE RotateR (pNode: tpNode): tpNode;
	VAR
		_node: tpNode;
	BEGIN
		_node := pNode.left;
		pNode.left := _node.right;
		_node.right := pNode;
		Height_Fix(pNode);
		Height_Fix(_node)

		RETURN _node
	END RotateR;

PROCEDURE RotateL (pNode: tpNode): tpNode;
	VAR
		_node: tpNode;
	BEGIN
		_node := pNode.right;
		pNode.right := _node.left;
		_node.left := pNode;
		Height_Fix(pNode);
		Height_Fix(_node)

		RETURN _node
	END RotateL;

PROCEDURE Node_Balance (pNode: tpNode): tpNode;
	VAR
		_node: tpNode;
	BEGIN
		Height_Fix(pNode);

		IF BFactor_Get(pNode) = 2 THEN
			IF BFactor_Get(pNode.right) < 0 THEN
				pNode.right := RotateR(pNode.right)
			END;
			_node := RotateL(pNode)

		ELSIF BFactor_Get(pNode) = -2 THEN
			IF BFactor_Get(pNode.left) > 0 THEN
				pNode.left := RotateL(pNode.left)
			END;
			_node := RotateR(pNode)

		ELSE
			_node := pNode
		END

		RETURN _node
	END Node_Balance;

PROCEDURE Insert* (pNode: tpNode; pData: tpData; cmp: tCMP; VAR pNewNode: BOOLEAN; VAR pNode2: tpNode): tpNode;
	VAR
		_node: tpNode;
		_resCmp: INTEGER;
	BEGIN
		IF pNode = NIL THEN
			_node := New(pData);
			pNode2 := _node;
			pNewNode := TRUE
		ELSE

			_resCmp := cmp(pData, pNode.data);
			IF _resCmp < 0 THEN
				pNode.left := Insert(pNode.left, pData, cmp, pNewNode, pNode2);
				_node := Node_Balance(pNode)
			ELSIF _resCmp > 0 THEN
				pNode.right := Insert(pNode.right, pData, cmp, pNewNode, pNode2);
				_node := Node_Balance(pNode)
			ELSE
				_node := pNode;
				pNode2 := _node;
				pNewNode := FALSE
			END

		END

		RETURN _node
	END Insert;

PROCEDURE Destroy* (VAR pNode: tpNode; pDestructor: tDesctuctor);
	VAR
		left, right: tpNode;

	BEGIN
		IF pNode # NIL THEN
			left  := pNode.left;
			right := pNode.right;

			IF pDestructor # NIL THEN
				pDestructor(pNode.data)
			END; 
			
			mCol.Push(nodes, pNode);
			pNode := NIL;

			Destroy(left, pDestructor);
			Destroy(right, pDestructor)
		END
	END Destroy;

BEGIN
	nodes := mCol.New()
END AVLTREES.
