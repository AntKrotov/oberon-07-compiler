(*
    BSD 2-Clause License

    Copyright (c) 2019, Anton Krotov
    All rights reserved.
*)

MODULE MSP430;

IMPORT CODE, LISTS, REG, CHL := CHUNKLISTS, ERRORS, FILES, WRITER, X86, MACHINE, C := CONSOLE, PROG;


CONST

    minRAM* = 128;  maxRAM* = 2048;
    minROM* = 4096; maxROM* = 49152;

    PC = 0; SP = 1; SR = 2; CG = 3;

    R4 = 4; R5 = 5; R6 = 6; R7 = 7;

    BP = 15; HP = 14; IR = 13;

    ACC = R4;

    opRRC  = 1000H;  opSWPB = 1080H;  opRRA  = 1100H;  opSXT = 1180H;
    opPUSH = 1200H;  opCALL = 1280H;  opRETI = 1300H;

    opMOV = 04000H;  opADD = 05000H;  opADDC = 06000H;  opSUBC = 07000H;
    opSUB = 08000H;  opCMP = 09000H;  opDADD = 0A000H;  opBIT  = 0B000H;
    opBIC = 0C000H;  opBIS = 0D000H;  opXOR  = 0E000H;  opAND  = 0F000H;

    opJNE = 2000H;  opJEQ = 2400H;  opJNC = 2800H;  opJC  = 2C00H;
    opJN  = 3000H;  opJGE = 3400H;  opJL  = 3800H;  opJMP = 3C00H;

    sREG = 0; sIDX = 16; sINDIR = 32; sINCR = 48; BW = 64; dIDX = 128;

    NOWORD = 10000H;

    RCODE = 0; RDATA = 1; RBSS = 2;

    je  = 0;  jne = je  + 1;
    jge = 2;  jl  = jge + 1;
    jle = 4;  jg  = jle + 1;
    jb  = 6;


    ram_adr = 200H;
    iv_adr  = 0FFC0H;

    sp_adr         = iv_adr - 2;
    empty_proc_adr = sp_adr - 2;
    types_adr      = empty_proc_adr - 2;

    trap_adr = ram_adr;
    int_adr  = trap_adr + 2;


TYPE

    ANYCODE = POINTER TO RECORD (LISTS.ITEM)

        offset: INTEGER

    END;

    WORD = POINTER TO RECORD (ANYCODE)

        val: INTEGER

    END;

    LABEL = POINTER TO RECORD (ANYCODE)

        num: INTEGER

    END;

    JMP = POINTER TO RECORD (ANYCODE)

        cc, label: INTEGER;
        short: BOOLEAN

    END;

    CALL = POINTER TO RECORD (ANYCODE)

        label: INTEGER

    END;

    COMMAND = CODE.COMMAND;

    RELOC = POINTER TO RECORD (LISTS.ITEM)

        section: INTEGER;
        WordPtr: WORD

    END;


VAR

    R: REG.REGS;

    CodeList: LISTS.LIST;
    RelList:  LISTS.LIST;

    mem: ARRAY 65536 OF BYTE;

    Labels: ARRAY 30000 OF LABEL;

    _new: INTEGER;

    IV: ARRAY 32 OF INTEGER;

    IdxWords: RECORD src, dst: INTEGER END;


PROCEDURE EmitLabel (L: INTEGER);
VAR
    label: LABEL;

BEGIN
    NEW(label);
    ERRORS.OutOfMemory(label = NIL);
    label.num := L;
    LISTS.push(CodeList, label)
END EmitLabel;


PROCEDURE EmitWord (val: INTEGER);
VAR
    word: WORD;

BEGIN
    IF val < 0 THEN
        ASSERT(val >= -32768);
        val := ORD(BITS(val) * {0..15})
    ELSE
        ASSERT(val <= 65535)
    END;
    NEW(word);
    ERRORS.OutOfMemory(word = NIL);
    word.val := val;
    LISTS.push(CodeList, word)
END EmitWord;


PROCEDURE EmitJmp (cc, label: INTEGER);
VAR
    jmp: JMP;

BEGIN
    NEW(jmp);
    ERRORS.OutOfMemory(jmp = NIL);
    jmp.cc := cc;
    jmp.label := label;
    jmp.short := FALSE;
    LISTS.push(CodeList, jmp)
END EmitJmp;


PROCEDURE EmitCall (label: INTEGER);
VAR
    call: CALL;

BEGIN
    NEW(call);
    ERRORS.OutOfMemory(call = NIL);
    call.label := label;
    LISTS.push(CodeList, call)
END EmitCall;


PROCEDURE bw (b: BOOLEAN): INTEGER;
    RETURN BW * ORD(b)
END bw;


PROCEDURE src_x (x, Rn: INTEGER): INTEGER;
BEGIN
    IdxWords.src := x
    RETURN Rn * 256 + sIDX
END src_x;


PROCEDURE dst_x (x, Rn: INTEGER): INTEGER;
BEGIN
    IdxWords.dst := x
    RETURN Rn + dIDX
END dst_x;


PROCEDURE indir (Rn: INTEGER): INTEGER;
    RETURN Rn * 256 + sINDIR
END indir;


PROCEDURE incr (Rn: INTEGER): INTEGER;
    RETURN Rn * 256 + sINCR
END incr;


PROCEDURE imm (x: INTEGER): INTEGER;
VAR
    res: INTEGER;

BEGIN
    CASE x OF
    | 0: res := CG * 256
    | 1: res := src_x(0, CG); IdxWords.src := NOWORD
    | 2: res := indir(CG)
    | 4: res := indir(SR)
    | 8: res := incr(SR)
    |-1: res := incr(CG)
    ELSE
        res := incr(PC);
        IdxWords.src := x
    END

    RETURN res
END imm;


PROCEDURE Op2 (op, src, dst: INTEGER);
BEGIN
    ASSERT(BITS(op) + {6, 12..15} = {6, 12..15});
    ASSERT(BITS(src) + {4, 5, 8..11} = {4, 5, 8..11});
    ASSERT(BITS(dst) + {0..3, 7} = {0..3, 7});

    EmitWord(op + src + dst);

    IF IdxWords.src # NOWORD THEN
        EmitWord(IdxWords.src);
        IdxWords.src := NOWORD
    END;

    IF IdxWords.dst # NOWORD THEN
        EmitWord(IdxWords.dst);
        IdxWords.dst := NOWORD
    END
END Op2;


PROCEDURE Op1 (op, reg, As: INTEGER);
BEGIN
    EmitWord(op + reg + As)
END Op1;


PROCEDURE MovRR (src, dst: INTEGER);
BEGIN
    Op2(opMOV, src * 256, dst)
END MovRR;


PROCEDURE PushImm (imm: INTEGER);
BEGIN
    CASE imm OF
    | 0: Op1(opPUSH, CG, sREG)
    | 1: Op1(opPUSH, CG, sIDX)
    | 2: Op1(opPUSH, CG, sINDIR)
    |-1: Op1(opPUSH, CG, sINCR)
    ELSE
        Op1(opPUSH, PC, sINCR);
        EmitWord(imm)
    END
END PushImm;


PROCEDURE PutWord (word: INTEGER; VAR adr: INTEGER);
BEGIN
    ASSERT(~ODD(adr));
    ASSERT((0 <= word) & (word <= 65535));
    mem[adr] := word MOD 256;
    mem[adr + 1] := word DIV 256;
    INC(adr, 2)
END PutWord;


PROCEDURE Fixup (CodeAdr, IntVectorSize: INTEGER): INTEGER;
VAR
    cmd:      ANYCODE;
    adr:      INTEGER;
    offset:   INTEGER;
    diff:     INTEGER;
    cc:       INTEGER;
    shorted:  BOOLEAN;

BEGIN
    REPEAT
        shorted := FALSE;
        offset := CodeAdr DIV 2;

        cmd := CodeList.first(ANYCODE);
        WHILE cmd # NIL DO
            cmd.offset := offset;
            CASE cmd OF
            |LABEL: Labels[cmd.num] := cmd
            |JMP:   INC(offset);
                    IF ~cmd.short THEN
                        INC(offset);
                        IF cmd.cc # opJMP THEN
                            INC(offset)
                        END
                    END

            |CALL:  INC(offset, 2)
            |WORD:  INC(offset)
            END;
            cmd := cmd.next(ANYCODE)
        END;

        cmd := CodeList.first(ANYCODE);
        WHILE cmd # NIL DO
            IF (cmd IS JMP) & ~cmd(JMP).short THEN
                diff := Labels[cmd(JMP).label].offset - cmd.offset - 1;
                IF ABS(diff) <= 512 THEN
                    cmd(JMP).short := TRUE;
                    shorted := TRUE
                END
            END;
            cmd := cmd.next(ANYCODE)
        END

    UNTIL ~shorted;

    IF offset * 2 > 10000H - IntVectorSize THEN
        ERRORS.error1("size of program is too large")
    END;

    adr := CodeAdr;
    cmd := CodeList.first(ANYCODE);
    WHILE cmd # NIL DO
        CASE cmd OF
        |LABEL:

        |JMP:   IF ~cmd.short THEN
                    CASE cmd.cc OF
                    |opJNE: cc := opJEQ
                    |opJEQ: cc := opJNE
                    |opJNC: cc := opJC
                    |opJC:  cc := opJNC
                    |opJGE: cc := opJL
                    |opJL:  cc := opJGE
                    |opJMP: cc := opJMP
                    END;

                    IF cc # opJMP THEN
                        PutWord(cc + 2, adr)  (* jcc L *)
                    END;

                    PutWord(4030H, adr); (* MOV @PC+, PC *)
                    PutWord(Labels[cmd.label].offset * 2, adr)
                    (* L: *)
                ELSE
                    diff := Labels[cmd.label].offset - cmd.offset - 1;
                    ASSERT((-512 <= diff) & (diff <= 511));
                    PutWord(cmd.cc + ORD(BITS(diff) * {0..9}), adr)
                END

        |CALL:  PutWord(12B0H, adr); (* CALL @PC+ *)
                PutWord(Labels[cmd.label].offset * 2, adr)

        |WORD:  PutWord(cmd.val, adr)

        END;
        cmd := cmd.next(ANYCODE)
    END

    RETURN adr - CodeAdr
END Fixup;


PROCEDURE NewLabel (): INTEGER;
VAR
    L: INTEGER;

BEGIN
    L := CODE.NewLabel();
    IF L >= LEN(Labels) THEN
        ERRORS.error1("size of program is too large")
    END

    RETURN L
END NewLabel;


PROCEDURE Push (reg: INTEGER);
BEGIN
    Op1(opPUSH, reg, sREG)
END Push;


PROCEDURE Pop (reg: INTEGER);
BEGIN
    Op2(opMOV, incr(SP), reg)
END Pop;


PROCEDURE Test (reg: INTEGER);
BEGIN
    Op2(opCMP, imm(0), reg)
END Test;


PROCEDURE Clear (reg: INTEGER);
BEGIN
    Op2(opMOV, imm(0), reg)
END Clear;


PROCEDURE mov (dst, src: INTEGER);
BEGIN
    MovRR(src, dst)
END mov;


PROCEDURE xchg (reg1, reg2: INTEGER);
BEGIN
    Push(reg1);
    Push(reg2);
    Pop(reg1);
    Pop(reg2)
END xchg;


PROCEDURE Reloc (section: INTEGER);
VAR
    reloc: RELOC;

BEGIN
    NEW(reloc);
    ERRORS.OutOfMemory(reloc = NIL);
    reloc.section := section;
    reloc.WordPtr := CodeList.last(WORD);
    LISTS.push(RelList, reloc)
END Reloc;


PROCEDURE CallRTL (proc, params: INTEGER);
BEGIN
    EmitCall(CODE.codes.rtl[proc]);
    IF params > 0 THEN
        Op2(opADD, imm(params * 2), SP)
    END
END CallRTL;


PROCEDURE UnOp (VAR reg: INTEGER);
BEGIN
    REG.UnOp(R, reg)
END UnOp;


PROCEDURE BinOp (VAR reg1, reg2: INTEGER);
BEGIN
    REG.BinOp(R, reg1, reg2)
END BinOp;


PROCEDURE GetRegA;
BEGIN
    ASSERT(REG.GetReg(R, ACC))
END GetRegA;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    DEC(R.pushed, NumberOfParameters)
END PushAll;


PROCEDURE cond (op: INTEGER): INTEGER;
VAR
    res: INTEGER;

BEGIN
    CASE op OF
    |CODE.opGT, CODE.opGTR, CODE.opLTL: res := jg
    |CODE.opGE, CODE.opGER, CODE.opLEL: res := jge
    |CODE.opLT, CODE.opLTR, CODE.opGTL: res := jl
    |CODE.opLE, CODE.opLER, CODE.opGEL: res := jle
    |CODE.opEQ, CODE.opEQR, CODE.opEQL: res := je
    |CODE.opNE, CODE.opNER, CODE.opNEL: res := jne
    END

    RETURN res
END cond;


PROCEDURE inv0 (op: INTEGER): INTEGER;
    RETURN ORD(BITS(op) / {0})
END inv0;


PROCEDURE jcc (cc, label: INTEGER);
VAR
    L: INTEGER;

BEGIN
    CASE cc OF
    |jne:
        EmitJmp(opJNE, label)
    |je:
        EmitJmp(opJEQ, label)
    |jge:
        EmitJmp(opJGE, label)
    |jl:
        EmitJmp(opJL, label)
    |jle:
        EmitJmp(opJL, label);
        EmitJmp(opJEQ, label)
    |jg:
        L := NewLabel();
        EmitJmp(opJEQ, L);
        EmitJmp(opJGE, label);
        EmitLabel(L)
    |jb:
        EmitJmp(opJNC, label)
    END
END jcc;


PROCEDURE setcc (cc, reg: INTEGER);
VAR
    L: INTEGER;

BEGIN
    L := NewLabel();
    Op2(opMOV, imm(1), reg);
    jcc(cc, L);
    Clear(reg);
    EmitLabel(L)
END setcc;


PROCEDURE Shift2 (op, reg, n: INTEGER);
VAR
    reg2: INTEGER;

BEGIN
    IF n >= 8 THEN
        CASE op OF
        |CODE.opASR2: Op1(opSWPB, reg, sREG); Op1(opSXT, reg, sREG)
        |CODE.opROR2: Op1(opSWPB, reg, sREG)
        |CODE.opLSL2: Op1(opSWPB, reg, sREG); Op2(opBIC, imm(255), reg)
        |CODE.opLSR2: Op2(opBIC, imm(255), reg); Op1(opSWPB, reg, sREG)
        END;
        DEC(n, 8)
    END;

    IF (op = CODE.opROR2) & (n > 0) THEN
        reg2 := REG.GetAnyReg(R);
        MovRR(reg, reg2)
    ELSE
        reg2 := -1
    END;

    WHILE n > 0 DO
        CASE op OF
        |CODE.opASR2: Op1(opRRA, reg, sREG)
        |CODE.opROR2: Op1(opRRC, reg2, sREG); Op1(opRRC, reg, sREG)
        |CODE.opLSL2: Op2(opADD, reg * 256, reg)
        |CODE.opLSR2: Op2(opBIC, imm(1), SR); Op1(opRRC, reg, sREG)
        END;
        DEC(n)
    END;

    IF reg2 # -1 THEN
        drop
    END

END Shift2;


PROCEDURE Neg (reg: INTEGER);
BEGIN
    Op2(opXOR, imm(-1), reg);
    Op2(opADD, imm(1), reg)
END Neg;


PROCEDURE translate (code: CODE.CODES);
VAR
    cmd: COMMAND;

    opcode, param1, param2, label, L, a, n: INTEGER;

    reg1, reg2: INTEGER;

    cc: INTEGER;

BEGIN
    cmd := code.commands.first(COMMAND);

    WHILE cmd # NIL DO

        param1 := cmd.param1;
        param2 := cmd.param2;

        opcode := cmd.opcode;

        CASE opcode OF
        |CODE.opJMP:
            EmitJmp(opJMP, param1)

        |CODE.opCALL:
            EmitCall(param1)

        |CODE.opCALLP:
            UnOp(reg1);
            Op1(opCALL, reg1, sREG);
            drop;
            ASSERT(R.top = -1)

        |CODE.opPRECALL:
            PushAll(0)

        |CODE.opLABEL:
            EmitLabel(param2)

        |CODE.opSADR_PARAM:
            Op1(opPUSH, PC, sINCR);
            EmitWord(param2);
            Reloc(RDATA)

        |CODE.opERR:
            CallRTL(CODE._error, 2)

        |CODE.opERRC:
            PushImm(param2)

        |CODE.opENTER:
            ASSERT(R.top = -1);

            EmitLabel(param1);

            Push(BP);
            MovRR(SP, BP);

            IF param2 > 8 THEN
                Op2(opMOV, imm(param2), R4);
                L := NewLabel();
                EmitLabel(L);
                Push(CG);
                Op2(opSUB, imm(1), R4);
                jcc(jne, L)
            ELSIF param2 > 0 THEN
                WHILE param2 > 0 DO
                    Push(CG);
                    DEC(param2)
                END
            END

        |CODE.opLEAVE, CODE.opLEAVER:
            ASSERT(param2 = 0);
            IF opcode = CODE.opLEAVER THEN
                UnOp(reg1);
                IF reg1 # ACC THEN
                    GetRegA;
                    ASSERT(REG.Exchange(R, reg1, ACC));
                    drop
                END;
                drop
            END;

            ASSERT(R.top = -1);

            MovRR(BP, SP);
            Pop(BP);
            Pop(PC)

        |CODE.opRES:
            ASSERT(R.top = -1);
            GetRegA

        |CODE.opCLEANUP:
            IF param2 # 0 THEN
                Op2(opADD, imm(param2 * 2), SP)
            END

        |CODE.opCONST:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, imm(param2), reg1)

        |CODE.opSADR:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, incr(PC), reg1);
            EmitWord(param2);
            Reloc(RDATA)

        |CODE.opGADR:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, incr(PC), reg1);
            EmitWord(param2);
            Reloc(RBSS)

        |CODE.opLADR:
            reg1 := REG.GetAnyReg(R);
            MovRR(BP, reg1);
            Op2(opADD, imm(param2 * 2), reg1)

        |CODE.opLLOAD8:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV + BW, src_x(param2 * 2, BP), reg1)

        |CODE.opLLOAD16, CODE.opVADR:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, src_x(param2 * 2, BP), reg1)

        |CODE.opGLOAD8:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV + BW, src_x(param2, SR), reg1);
            Reloc(RBSS)

        |CODE.opGLOAD16:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, src_x(param2, SR), reg1);
            Reloc(RBSS)

        |CODE.opLOAD8:
            UnOp(reg1);
            Op2(opMOV + BW, indir(reg1), reg1)

        |CODE.opLOAD16:
            UnOp(reg1);
            Op2(opMOV, indir(reg1), reg1)

        |CODE.opVLOAD8:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, src_x(param2 * 2, BP), reg1);
            Op2(opMOV + BW, indir(reg1), reg1)

        |CODE.opVLOAD16:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, src_x(param2 * 2, BP), reg1);
            Op2(opMOV, indir(reg1), reg1)

        |CODE.opSAVE, CODE.opSAVE16:
            BinOp(reg2, reg1);
            Op2(opMOV, reg2 * 256, dst_x(0, reg1));
            drop;
            drop

        |CODE.opSAVE8:
            BinOp(reg2, reg1);
            Op2(opMOV + BW, reg2 * 256, dst_x(0, reg1));
            drop;
            drop

        |CODE.opSAVE8C:
            UnOp(reg1);
            Op2(opMOV + BW, imm(param2), dst_x(0, reg1));
            drop

        |CODE.opSAVE16C, CODE.opSAVEC:
            UnOp(reg1);
            Op2(opMOV, imm(param2), dst_x(0, reg1));
            drop

        |CODE.opUMINUS:
            UnOp(reg1);
            Neg(reg1)

        |CODE.opADD:
            BinOp(reg1, reg2);
            Op2(opADD, reg2 * 256, reg1);
            drop

        |CODE.opADDL, CODE.opADDR:
            IF param2 # 0 THEN
                UnOp(reg1);
                Op2(opADD, imm(param2), reg1)
            END

        |CODE.opSUB:
            BinOp(reg1, reg2);
            Op2(opSUB, reg2 * 256, reg1);
            drop

        |CODE.opSUBR, CODE.opSUBL:
            UnOp(reg1);
            IF param2 # 0 THEN
                Op2(opSUB, imm(param2), reg1)
            END;
            IF opcode = CODE.opSUBL THEN
                reg2 := REG.GetAnyReg(R);
                Clear(reg2);
                Op2(opSUB, reg1 * 256, reg2);
                drop;
                drop;
                ASSERT(REG.GetReg(R, reg2))
            END

        |CODE.opLADR_SAVEC:
            Op2(opMOV, imm(param2), dst_x(param1 * 2, BP))

        |CODE.opLADR_SAVE:
            UnOp(reg1);
            Op2(opMOV, reg1 * 256, dst_x(param2 * 2, BP));
            drop

        |CODE.opGADR_SAVEC:
            Op2(opMOV, imm(param2), dst_x(param1, SR));
            Reloc(RBSS)

        |CODE.opCONST_PARAM:
            PushImm(param2)

        |CODE.opPARAM:
            IF param2 = 1 THEN
                UnOp(reg1);
                Push(reg1);
                drop
            ELSE
                ASSERT(R.top + 1 <= param2);
                PushAll(param2)
            END

        |CODE.opEQL..CODE.opGEL,
         CODE.opEQR..CODE.opGER,
         CODE.opEQ..CODE.opGE:

            IF (CODE.opEQ <= opcode) & (opcode <= CODE.opGE) THEN
                BinOp(reg1, reg2);
                Op2(opCMP, reg2 * 256, reg1);
                drop
            ELSE
                UnOp(reg1);
                Op2(opCMP, imm(param2), reg1)
            END;

            drop;
            cc := cond(opcode);

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).param1;
                jcc(cc, label);
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).param1;
                jcc(inv0(cc), label);
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);
                setcc(cc, reg1)
            END

        |CODE.opNOP:

        |CODE.opCODE:
            EmitWord(param2)

        |CODE.opACC:
            IF (R.top # 0) OR (R.stk[0] # ACC) THEN
                PushAll(0);
                GetRegA;
                Pop(ACC);
                DEC(R.pushed)
            END

        |CODE.opDROP:
            UnOp(reg1);
            drop

        |CODE.opJNZ:
            UnOp(reg1);
            Test(reg1);
            jcc(jne, param1)

        |CODE.opJZ:
            UnOp(reg1);
            Test(reg1);
            jcc(je, param1)

        |CODE.opJG:
            UnOp(reg1);
            Test(reg1);
            jcc(jg, param1)

        |CODE.opJE:
            UnOp(reg1);
            Test(reg1);
            jcc(jne, param1);
            drop

        |CODE.opJNE:
            UnOp(reg1);
            Test(reg1);
            jcc(je, param1);
            drop

        |CODE.opNOT:
            UnOp(reg1);
            Test(reg1);
            setcc(je, reg1)

        |CODE.opORD:
            UnOp(reg1);
            Test(reg1);
            setcc(jne, reg1)

        |CODE.opLOOP:
        |CODE.opENDLOOP:

        |CODE.opGET:
            BinOp(reg1, reg2);
            drop;
            drop;
            Op2(opMOV + bw(param2 = 1), indir(reg1), dst_x(0, reg2))

        |CODE.opCHKIDX:
            UnOp(reg1);
            Op2(opCMP, imm(param2), reg1);
            jcc(jb, param1)

        |CODE.opCHKIDX2:
            BinOp(reg1, reg2);
            IF param2 # -1 THEN
                Op2(opCMP, reg1 * 256, reg2);
                MovRR(reg2, reg1);
                drop;
                jcc(jb, param1)
            ELSE
                INCL(R.regs, reg1);
                DEC(R.top);
                R.stk[R.top] := reg2
            END

        |CODE.opINC1, CODE.opINC1B:
            UnOp(reg1);
            Op2(opADD + bw(opcode = CODE.opINC1B), imm(1), dst_x(0, reg1));
            drop

        |CODE.opDEC1, CODE.opDEC1B:
            UnOp(reg1);
            Op2(opSUB + bw(opcode = CODE.opDEC1B), imm(1), dst_x(0, reg1));
            drop

        |CODE.opINCC, CODE.opINCCB:
            UnOp(reg1);
            Op2(opADD + bw(opcode = CODE.opINCCB), imm(param2), dst_x(0, reg1));
            drop

        |CODE.opDECC, CODE.opDECCB:
            UnOp(reg1);
            Op2(opSUB + bw(opcode = CODE.opDECCB), imm(param2), dst_x(0, reg1));
            drop

        |CODE.opINC, CODE.opINCB:
            BinOp(reg1, reg2);
            Op2(opADD + bw(opcode = CODE.opINCB), reg1 * 256, dst_x(0, reg2));
            drop;
            drop

        |CODE.opDEC, CODE.opDECB:
            BinOp(reg1, reg2);
            Op2(opSUB + bw(opcode = CODE.opDECB), reg1 * 256, dst_x(0, reg2));
            drop;
            drop

        |CODE.opLADR_INC1, CODE.opLADR_INC1B:
            Op2(opADD + bw(opcode = CODE.opLADR_INC1B), imm(1), dst_x(param2 * 2, BP))

        |CODE.opLADR_DEC1, CODE.opLADR_DEC1B:
            Op2(opSUB + bw(opcode = CODE.opLADR_DEC1B), imm(1), dst_x(param2 * 2, BP))

        |CODE.opLADR_INCC, CODE.opLADR_INCCB:
            Op2(opADD + bw(opcode = CODE.opLADR_INCCB), imm(param2), dst_x(param1 * 2, BP))

        |CODE.opLADR_DECC, CODE.opLADR_DECCB:
            Op2(opSUB + bw(opcode = CODE.opLADR_DECCB), imm(param2), dst_x(param1 * 2, BP))

        |CODE.opLADR_INC, CODE.opLADR_INCB:
            UnOp(reg1);
            Op2(opADD + bw(opcode = CODE.opLADR_INCB), reg1 * 256, dst_x(param2 * 2, BP));
            drop

        |CODE.opLADR_DEC, CODE.opLADR_DECB:
            UnOp(reg1);
            Op2(opSUB + bw(opcode = CODE.opLADR_DECB), reg1 * 256, dst_x(param2 * 2, BP));
            drop

        |CODE.opPUSHT:
            UnOp(reg1);
            reg2 := REG.GetAnyReg(R);
            Op2(opMOV, src_x(-2, reg1), reg2)

        |CODE.opISREC:
            PushAll(2);
            PushImm(param2);
            CallRTL(CODE._guardrec, 3);
            GetRegA

        |CODE.opIS:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._is, 2);
            GetRegA

        |CODE.opTYPEGR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            GetRegA

        |CODE.opTYPEGP:
            UnOp(reg1);
            PushAll(0);
            Push(reg1);
            PushImm(param2);
            CallRTL(CODE._guard, 2);
            GetRegA

        |CODE.opTYPEGD:
            UnOp(reg1);
            PushAll(0);
            Op1(opPUSH, reg1, sIDX);
            EmitWord(-2);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            GetRegA

        |CODE.opMULS:
            BinOp(reg1, reg2);
            Op2(opAND, reg2 * 256, reg1);
            drop

        |CODE.opMULSC:
            UnOp(reg1);
            Op2(opAND, imm(param2), reg1)

        |CODE.opDIVS:
            BinOp(reg1, reg2);
            Op2(opXOR, reg2 * 256, reg1);
            drop

        |CODE.opDIVSC:
            UnOp(reg1);
            Op2(opXOR, imm(param2), reg1)

        |CODE.opADDS:
            BinOp(reg1, reg2);
            Op2(opBIS, reg2 * 256, reg1);
            drop

        |CODE.opSUBS:
            BinOp(reg1, reg2);
            Op2(opBIC, reg2 * 256, reg1);
            drop

        |CODE.opADDSL, CODE.opADDSR:
            UnOp(reg1);
            Op2(opBIS, imm(param2), reg1)

        |CODE.opSUBSL:
            UnOp(reg1);
            Op2(opXOR, imm(-1), reg1);
            Op2(opAND, imm(param2), reg1)

        |CODE.opSUBSR:
            UnOp(reg1);
            Op2(opBIC, imm(param2), reg1)

        |CODE.opUMINS:
            UnOp(reg1);
            Op2(opXOR, imm(-1), reg1)

        |CODE.opLENGTH:
            PushAll(2);
            CallRTL(CODE._length, 2);
            GetRegA

        |CODE.opMIN:
            BinOp(reg1, reg2);
            Op2(opCMP, reg2 * 256, reg1);
            EmitWord(opJL + 1); (* jl L *)
            MovRR(reg2, reg1);
                                (* L: *)
            drop


        |CODE.opMAX:
            BinOp(reg1, reg2);
            Op2(opCMP, reg2 * 256, reg1);
            EmitWord(opJGE + 1); (* jge L *)
            MovRR(reg2, reg1);
                                 (* L: *)
            drop

        |CODE.opMINC:
            UnOp(reg1);
            Op2(opCMP, imm(param2), reg1);
            L := NewLabel();
            jcc(jl, L);
            Op2(opMOV, imm(param2), reg1);
            EmitLabel(L)

        |CODE.opMAXC:
            UnOp(reg1);
            Op2(opCMP, imm(param2), reg1);
            L := NewLabel();
            jcc(jge, L);
            Op2(opMOV, imm(param2), reg1);
            EmitLabel(L)

        |CODE.opSWITCH:
            UnOp(reg1);
            IF param2 = 0 THEN
                reg2 := ACC
            ELSE
                reg2 := R5
            END;
            IF reg1 # reg2 THEN
                ASSERT(REG.GetReg(R, reg2));
                ASSERT(REG.Exchange(R, reg1, reg2));
                drop
            END;
            drop

        |CODE.opENDSW:

        |CODE.opCASEL:
            Op2(opCMP, imm(param1), ACC);
            jcc(jl, param2)

        |CODE.opCASER:
            Op2(opCMP, imm(param1), ACC);
            jcc(jg, param2)

        |CODE.opCASELR:
            Op2(opCMP, imm(param1), ACC);
            jcc(jl, param2);
            jcc(jg, cmd.param3)

        |CODE.opSBOOL:
            BinOp(reg2, reg1);
            Test(reg2);
            setcc(jne, reg2);
            Op2(opMOV + BW, reg2 * 256, dst_x(0, reg1));
            drop;
            drop

        |CODE.opSBOOLC:
            UnOp(reg1);
            Op2(opMOV + BW, imm(param2), dst_x(0, reg1));
            drop

        |CODE.opODD:
            UnOp(reg1);
            Op2(opAND, imm(1), reg1)

        |CODE.opEQS .. CODE.opGES:
            PushAll(4);
            PushImm(opcode - CODE.opEQS);
            CallRTL(CODE._strcmp, 5);
            GetRegA

        |CODE.opEQS2 .. CODE.opGES2:
            PushAll(4);
            PushImm(opcode - CODE.opEQS2);
            CallRTL(CODE._strcmp2, 5);
            GetRegA

        |CODE.opLEN:
            UnOp(reg1);
            drop;
            EXCL(R.regs, reg1);

            WHILE param2 > 0 DO
                UnOp(reg2);
                drop;
                DEC(param2)
            END;

            INCL(R.regs, reg1);
            ASSERT(REG.GetReg(R, reg1))

        |CODE.opCHKBYTE:
            BinOp(reg1, reg2);
            Op2(opCMP, imm(256), reg1);
            jcc(jb, param1)

        |CODE.opLSL, CODE.opASR, CODE.opROR, CODE.opLSR:
            PushAll(2);
            CASE opcode OF
            |CODE.opLSL: PushImm(0)
            |CODE.opASR: PushImm(1)
            |CODE.opROR: PushImm(2)
            |CODE.opLSR: PushImm(3)
            END;
            CallRTL(CODE._shift2, 3);
            GetRegA

        |CODE.opLSL1, CODE.opASR1, CODE.opROR1, CODE.opLSR1:
            PushAll(1);
            PushImm(param2);
            CASE opcode OF
            |CODE.opLSL1: PushImm(0)
            |CODE.opASR1: PushImm(1)
            |CODE.opROR1: PushImm(2)
            |CODE.opLSR1: PushImm(3)
            END;
            CallRTL(CODE._shift, 3);
            GetRegA

        |CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
            param2 := ORD(BITS(param2) * {0..3});
            IF param2 # 0 THEN
                UnOp(reg1);
                Shift2(opcode, reg1, param2)
            END

        |CODE.opMUL:
            PushAll(2);
            CallRTL(CODE._mul, 2);
            GetRegA

        |CODE.opMULC:
            UnOp(reg1);

            a := param2;
            IF a > 1 THEN
                n := X86.log2(a)
            ELSIF a < -1 THEN
                n := X86.log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                Neg(reg1)
            ELSIF a = 0 THEN
                Clear(reg1)
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        Neg(reg1)
                    END;
                    Shift2(CODE.opLSL2, reg1, n)
                ELSE
                    PushAll(1);
                    PushImm(a);
                    CallRTL(CODE._mul, 2);
                    GetRegA
                END
            END

        |CODE.opDIV:
            PushAll(2);
            CallRTL(CODE._div, 2);
            GetRegA

        |CODE.opDIVR:
            ASSERT(param2 > 0);

            IF param2 > 1 THEN
                n := X86.log2(param2);
                IF n > 0 THEN
                    UnOp(reg1);
                    Shift2(CODE.opASR2, reg1, n)
                ELSE
                    PushAll(1);
                    PushImm(param2);
                    CallRTL(CODE._div, 2);
                    GetRegA
                END
            END

        |CODE.opDIVL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._div2, 2);
            GetRegA

        |CODE.opMOD:
            PushAll(2);
            CallRTL(CODE._mod, 2);
            GetRegA

        |CODE.opMODR:
            ASSERT(param2 > 0);

            IF param2 = 1 THEN
                UnOp(reg1);
                Clear(reg1)
            ELSE
                IF X86.log2(param2) > 0 THEN
                    UnOp(reg1);
                    Op2(opAND, imm(param2 - 1), reg1)
                ELSE
                    PushAll(1);
                    PushImm(param2);
                    CallRTL(CODE._mod, 2);
                    GetRegA
                END
            END

        |CODE.opMODL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._mod2, 2);
            GetRegA

        |CODE.opCOPYS:
            PushAll(4);
            CallRTL(CODE._strcpy, 4)

        |CODE.opCOPYS2:
            PushAll(4);
            CallRTL(CODE._strcpy2, 4)

        |CODE.opCOPY:
            PushAll(2);
            PushImm(param2);
            CallRTL(CODE._move2, 3)

        |CODE.opMOVE:
            PushAll(3);
            CallRTL(CODE._move2, 3)

        |CODE.opCOPYA:
            PushAll(4);
            PushImm(param2);
            CallRTL(CODE._arrcpy, 5);
            GetRegA

        |CODE.opROT:
            PushAll(0);
            MovRR(SP, ACC);
            Push(ACC);
            PushImm(param2);
            CallRTL(CODE._rot, 2)

        |CODE.opSAVES:
            PushAll(1);
            Op1(opPUSH, PC, sINCR);
            EmitWord(param2);
            Reloc(RDATA);
            PushImm(param1);
            CallRTL(CODE._move, 3)

        |CODE.opCASET:
            Push(R5);
            Push(R5);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            Pop(R5);
            Test(ACC);
            jcc(jne, param1)

        |CODE.opCHR:
            UnOp(reg1);
            Op2(opAND, imm(255), reg1)

        |CODE.opABS:
            UnOp(reg1);
            Test(reg1);
            L := NewLabel();
            jcc(jge, L);
            Neg(reg1);
            EmitLabel(L)

        |CODE.opEQB, CODE.opNEB:
            BinOp(reg1, reg2);
            drop;

            Test(reg1);
            L := NewLabel();
            jcc(je, L);
            Op2(opMOV, imm(1), reg1);
            EmitLabel(L);

            Test(reg2);
            L := NewLabel();
            jcc(je, L);
            Op2(opMOV, imm(1), reg2);
            EmitLabel(L);

            Op2(opCMP, reg2 * 256, reg1);
            IF opcode = CODE.opEQB THEN
                setcc(je, reg1)
            ELSE
                setcc(jne, reg1)
            END

        |CODE.opSAVEP:
            UnOp(reg1);
            Op2(opMOV, incr(PC), reg1 + dIDX);
            EmitWord(param2);
            Reloc(RCODE);
            EmitWord(0);
            drop

        |CODE.opPUSHP:
            reg1 := REG.GetAnyReg(R);
            Op2(opMOV, incr(PC), reg1);
            EmitWord(param2);
            Reloc(RCODE)

        |CODE.opEQP, CODE.opNEP:
            UnOp(reg1);
            Op2(opCMP, incr(PC), reg1);
            EmitWord(param1);
            Reloc(RCODE);
            drop;
            reg1 := REG.GetAnyReg(R);

            IF opcode = CODE.opEQP THEN
                setcc(je, reg1)
            ELSIF opcode = CODE.opNEP THEN
                setcc(jne, reg1)
            END

        |CODE.opVADR_PARAM:
            Op1(opPUSH, BP, sIDX);
            EmitWord(param2 * 2)

        |CODE.opNEW:
            PushAll(1);
            n := param2 + 2;
            ASSERT(MACHINE.Align(n, 2));
            PushImm(n);
            PushImm(param1);
            CallRTL(CODE._new, 3)

        |CODE.opRSET:
            PushAll(2);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opRSETR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opRSETL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._set2, 2);
            GetRegA

        |CODE.opRSET1:
            UnOp(reg1);
            PushAll(1);
            Push(reg1);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opINCLC:
            UnOp(reg1);
            Op2(opBIS, imm(ORD({param2})), dst_x(0, reg1));
            drop

        |CODE.opEXCLC:
            UnOp(reg1);
            Op2(opBIC, imm(ORD({param2})), dst_x(0, reg1));
            drop

        |CODE.opIN:
            PushAll(2);
            CallRTL(CODE._in, 2);
            GetRegA

        |CODE.opINR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._in, 2);
            GetRegA

        |CODE.opINL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._in2, 2);
            GetRegA

        |CODE.opINCL:
            PushAll(2);
            CallRTL(CODE._incl, 2)

        |CODE.opEXCL:
            PushAll(2);
            CallRTL(CODE._excl, 2)

        |CODE.opLADR_INCL, CODE.opLADR_EXCL:
            PushAll(1);
            MovRR(BP, ACC);
            Op2(opADD, imm(param2 * 2), ACC);
            Push(ACC);
            IF opcode = CODE.opLADR_INCL THEN
                CallRTL(CODE._incl, 2)
            ELSIF opcode = CODE.opLADR_EXCL THEN
                CallRTL(CODE._excl, 2)
            END

        |CODE.opLADR_INCLC:
            Op2(opBIS, imm(ORD({param2})), dst_x(param1 * 2, BP))

        |CODE.opLADR_EXCLC:
            Op2(opBIC, imm(ORD({param2})), dst_x(param1 * 2, BP))

        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)
END translate;


PROCEDURE prolog;
BEGIN
    _new := NewLabel();
    CODE.codes.rtl[CODE._new] := _new;
    IV[LEN(IV) - 1] := NewLabel();
    EmitLabel(IV[LEN(IV) - 1]);
    Op2(opMOV, incr(PC), SP);
    EmitWord(0);
    Op2(opMOV, incr(PC), HP);
    EmitWord(0);
    Op2(opMOV, imm(5A80H), dst_x(0120H, SR)); (* stop WDT *)
    Op2(opMOV, imm(empty_proc_adr), dst_x(int_adr, SR))
END prolog;


PROCEDURE epilog;
VAR
    L1, L2, L3, L4: INTEGER;
    i: INTEGER;

BEGIN
    Op2(opBIS, imm(10H), SR); (* CPUOFF *)

    L1 := NewLabel();
    L2 := NewLabel();
    L3 := NewLabel();

    EmitLabel(_new);
    Push(SR);
    Clear(SR);
    MovRR(CG, CG);
    MovRR(SP, R4);
    Op2(opSUB, imm(16), R4);
    MovRR(HP, R5);
    Op2(opADD, src_x(6, SP), R5);
    Op2(opCMP, R5 * 256, R4);
    Op2(opMOV, src_x(8, SP), R4);
    jcc(jl, L1);
    Op2(opMOV, src_x(4, SP), dst_x(0, HP));
    Op2(opADD, imm(2), HP);
    Op2(opMOV, HP * 256, dst_x(0, R4));
    EmitLabel(L3);
    Op2(opMOV, imm(0), dst_x(0, HP));
    Op2(opADD, imm(2), HP);
    Op2(opCMP, R5 * 256, HP);
    jcc(jl, L3);
    EmitJmp(opJMP, L2);
    EmitLabel(L1);
    Op2(opMOV, imm(0), dst_x(0, R4));
    EmitLabel(L2);
    Op1(opRETI, 0, 0);

    L4 := NewLabel();
    FOR i := 0 TO LEN(IV) - 2 DO
        IV[i] := NewLabel();
        EmitLabel(IV[i]);
        PushImm(i);
        IF i # LEN(IV) - 2 THEN
            EmitJmp(opJMP, L4)
        END
    END;

    EmitLabel(L4);

    MovRR(SP, IR);

    FOR i := 0 TO 15 DO
        IF i IN R.regs + R.vregs THEN
            Push(i)
        END
    END;

    Push(IR);
    Op1(opPUSH, IR, sINDIR);
    Op1(opCALL, SR, sIDX);
    EmitWord(int_adr);
    Op2(opADD, imm(4), SP);

    FOR i := 15 TO 0 BY -1 DO
        IF i IN R.regs + R.vregs THEN
            Pop(i)
        END
    END;

    Op2(opADD, imm(2), SP);
    Op1(opRETI, 0, 0)
END epilog;


PROCEDURE hexdgt (n: BYTE): BYTE;
BEGIN
    IF n < 10 THEN
        n := n + ORD("0")
    ELSE
        n := n - 10 + ORD("A")
    END

    RETURN n
END hexdgt;


PROCEDURE WriteHexByte (file: FILES.FILE; byte: BYTE);
BEGIN
    WRITER.WriteByte(file, hexdgt(byte DIV 16));
    WRITER.WriteByte(file, hexdgt(byte MOD 16));
END WriteHexByte;


PROCEDURE WriteHex (file: FILES.FILE; mem: ARRAY OF BYTE; idx, cnt: INTEGER);
VAR
    i: INTEGER;

BEGIN
    WHILE cnt > 0 DO
        WRITER.WriteByte(file, ORD(":"));
        WriteHexByte(file, MIN(16, cnt));
        WriteHexByte(file, idx DIV 256);
        WriteHexByte(file, idx MOD 256);
        WriteHexByte(file, 0);
        i := MIN(16, cnt);
        WHILE i > 0 DO
            WriteHexByte(file, mem[idx]);
            INC(idx);
            DEC(i)
        END;
        DEC(cnt, MIN(16, cnt));
        WRITER.WriteByte(file, 0DH);
        WRITER.WriteByte(file, 0AH)
    END
END WriteHex;


PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target: INTEGER; options: PROG.OPTIONS);
CONST
    RTLVarSize  = 4;
    RTLDataSize = 4;
    IntVectorSize = LEN(IV) * 2 + RTLDataSize;
    minStackSize = 64;

VAR
    i, tcount, adr, heap, stack, DataSize,
    TextSize: INTEGER;

    Code, Data, Bss: RECORD address, size: INTEGER END;

    ram, rom: INTEGER;

    reloc: RELOC;

    file: FILES.FILE;

BEGIN
    IdxWords.src := NOWORD;
    IdxWords.dst := NOWORD;

    ram := options.ram;
    rom := options.rom;

    IF ODD(ram) THEN DEC(ram) END;
    IF ODD(rom) THEN DEC(rom) END;

    ram := MIN(MAX(ram, minRAM), maxRAM);
    rom := MIN(MAX(rom, minROM), maxROM);

    IF code.bss > ram - minStackSize - RTLVarSize THEN
        ERRORS.error1("size of global variables is too large")
    END;

    IF code.lcount >= LEN(Labels) THEN
        ERRORS.error1("size of program is too large")
    END;

    FOR i := 0 TO LEN(mem) - 1 DO
        mem[i] := 0
    END;

    tcount := CHL.Length(code.types);
    CodeList := LISTS.create(NIL);
    RelList  := LISTS.create(NIL);
    R := REG.Create(Push, Pop, mov, xchg, NIL, NIL, {R4, R5, R6, R7}, {});

    prolog;
    translate(code);
    epilog;

    Code.address := 10000H - rom;
    Code.size := Fixup(Code.address, IntVectorSize + tcount * 2);
    Data.address := Code.address + Code.size;
    Data.size := CHL.Length(code.data);
    Data.size := Data.size + ORD(ODD(Data.size));
    TextSize  := Code.size + Data.size;

    IF Code.address + TextSize > 10000H - IntVectorSize - tcount * 2 THEN
        ERRORS.error1("size of program is too large")
    END;

    Bss.address := ram_adr + RTLVarSize;
    Bss.size := code.bss + ORD(ODD(code.bss));
    heap := Bss.address + Bss.size;
    stack := ram_adr + ram;
    ASSERT(stack - heap >= minStackSize);
    adr := Code.address + 2;
    PutWord(stack, adr);
    adr := Code.address + 6;
    PutWord(heap, adr);

    reloc := RelList.first(RELOC);
    WHILE reloc # NIL DO
        adr := reloc.WordPtr.offset * 2;
        CASE reloc.section OF
        |RCODE: PutWord(Labels[reloc.WordPtr.val].offset * 2, adr)
        |RDATA: PutWord(reloc.WordPtr.val + Data.address, adr)
        |RBSS:  PutWord(reloc.WordPtr.val + Bss.address, adr)
        END;
        reloc := reloc.next(RELOC)
    END;

    adr := Data.address;

    DataSize := CHL.Length(code.data);
    FOR i := 0 TO DataSize - 1 DO
        mem[adr] := CHL.GetByte(code.data, i);
        INC(adr)
    END;

    adr := 10000H - IntVectorSize - tcount * 2;

    FOR i := tcount - 1 TO 0 BY -1 DO
        PutWord(CHL.GetInt(code.types, i), adr)
    END;

    PutWord(4130H, adr); (* RET *)
    PutWord(stack, adr);

    FOR i := 0 TO LEN(IV) - 1 DO
        PutWord(Labels[IV[i]].offset * 2, adr)
    END;

    file := FILES.create(outname);
    WriteHex(file, mem, Code.address, TextSize);
    WriteHex(file, mem, 10000H - IntVectorSize - tcount * 2, IntVectorSize + tcount * 2);

    WRITER.WriteByte(file, ORD(":"));
    WriteHexByte(file, 0);
    WriteHexByte(file, 0);
    WriteHexByte(file, 0);
    WriteHexByte(file, 1);
    WriteHexByte(file, 255);
    WRITER.WriteByte(file, 0DH);
    WRITER.WriteByte(file, 0AH);

    FILES.close(file);

    INC(TextSize, IntVectorSize + tcount * 2);
    INC(Bss.size, minStackSize + RTLVarSize);

    C.StringLn("-------------------------------");
    C.String(  "  rom:  "); C.Int(TextSize); C.String(" of "); C.Int(rom); C.String("  ("); C.Int(TextSize * 100 DIV rom); C.StringLn("%)");
    C.String(  "  ram:  "); C.Int(Bss.size); C.String(" of "); C.Int(ram); C.String("  ("); C.Int(Bss.size * 100 DIV ram); C.StringLn("%)");
    C.StringLn("-------------------------------")

END CodeGen;


END MSP430.