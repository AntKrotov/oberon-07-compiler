(*
    BSD 2-Clause License

    Copyright (c) 2019, Anton Krotov
    All rights reserved.
*)

MODULE MSP430;

IMPORT CODE, LISTS, REG, CHL := CHUNKLISTS, ERRORS, FILES, WRITER, X86, MACHINE, C := CONSOLE, PROG;


CONST

    minRAM* = 128;  maxRAM* = 2048;
    minROM* = 4096; maxROM* = 49152;

    PC = 0; SP = 1; SR = 2; CG = 3;

    R4 = 4; R5 = 5; R6 = 6; R7 = 7; R8 = 8;

    BP = 15; HP = 14; IR = 13;

    ACC = R4;

    opRRC  = 0;  opSWPB = 1;  opRRA  = 2;  opSXT = 3;
    opPUSH = 4;  opCALL = 5;  opRETI = 6;

    opMOV =  4;  opADD =  5;  opADDC =  6;  opSUBC = 7;
    opSUB =  8;  opCMP =  9;  opDADD = 10;  opBIT = 11;
    opBIC = 12;  opBIS = 13;  opXOR  = 14;  opAND = 15;

    opJNE = 0;  opJEQ = 1;  opJNC = 2;  opJC  = 3;
    opJN  = 4;  opJGE = 5;  opJL  = 6;  opJMP = 7;

    mREG = 0; mIDX = 1; mINDIR = 2; mINCR = 3;

    RCODE = 0; RDATA = 1; RBSS = 2;

    je  = 0;  jne = je  + 1;
    jge = 2;  jl  = jge + 1;
    jle = 4;  jg  = jle + 1;
    jb  = 6;


    ram_adr = 200H;
    iv_adr  = 0FFC0H;

    sp_adr         = iv_adr - 2;
    empty_proc_adr = sp_adr - 2;
    types_adr      = empty_proc_adr - 2;

    trap_adr = ram_adr;
    int_adr  = trap_adr + 2;


TYPE

    ANYCODE = POINTER TO RECORD (LISTS.ITEM)

        offset: INTEGER

    END;

    WORD = POINTER TO RECORD (ANYCODE)

        val: INTEGER

    END;

    LABEL = POINTER TO RECORD (ANYCODE)

        num: INTEGER

    END;

    JMP = POINTER TO RECORD (ANYCODE)

        cc, label: INTEGER;
        short: BOOLEAN

    END;

    CALL = POINTER TO RECORD (ANYCODE)

        label: INTEGER

    END;

    COMMAND = CODE.COMMAND;

    RELOC = POINTER TO RECORD (LISTS.ITEM)

        section: INTEGER;
        WordPtr: WORD

    END;


VAR

    R: REG.REGS;

    CodeList: LISTS.LIST;
    RelList:  LISTS.LIST;

    mem: ARRAY 65536 OF BYTE;

    Labels: ARRAY 30000 OF LABEL;

    _new: INTEGER;

    IV: ARRAY 32 OF INTEGER;


PROCEDURE EmitLabel (L: INTEGER);
VAR
    label: LABEL;

BEGIN
    NEW(label);
    ERRORS.OutOfMemory(label = NIL);
    label.num := L;
    LISTS.push(CodeList, label)
END EmitLabel;


PROCEDURE EmitWord (val: INTEGER);
VAR
    word: WORD;

BEGIN
    IF val < 0 THEN
        ASSERT(val >= -32768);
        val := ORD(BITS(val) * {0..15})
    ELSE
        ASSERT(val <= 65535)
    END;
    NEW(word);
    ERRORS.OutOfMemory(word = NIL);
    word.val := val;
    LISTS.push(CodeList, word)
END EmitWord;


PROCEDURE EmitJmp (cc, label: INTEGER);
VAR
    jmp: JMP;

BEGIN
    NEW(jmp);
    ERRORS.OutOfMemory(jmp = NIL);
    jmp.cc := cc;
    jmp.label := label;
    jmp.short := FALSE;
    LISTS.push(CodeList, jmp)
END EmitJmp;


PROCEDURE EmitCall (label: INTEGER);
VAR
    call: CALL;

BEGIN
    NEW(call);
    ERRORS.OutOfMemory(call = NIL);
    call.label := label;
    LISTS.push(CodeList, call)
END EmitCall;


PROCEDURE GenBinOp (opcode, src, As, dst, Ad: INTEGER; byte: BOOLEAN);
VAR
    word: INTEGER;

BEGIN
    ASSERT(Ad IN {mREG, mIDX});
    word := LSL(opcode, 4) + src;
    word := LSL(word, 1) + Ad;
    word := LSL(word, 1) + ORD(byte);
    word := LSL(word, 2) + As;
    word := LSL(word, 4) + dst;
    EmitWord(word)
END GenBinOp;


PROCEDURE GenUnOp (opcode, reg, As: INTEGER; byte: BOOLEAN);
VAR
    word: INTEGER;

BEGIN
    word := LSL(opcode + 32, 1) + ORD(byte);
    word := LSL(word, 2) + As;
    word := LSL(word, 4) + reg;
    EmitWord(word)
END GenUnOp;


PROCEDURE GenBinOpW (opcode, src, As, dst, Ad: INTEGER);
BEGIN
    GenBinOp(opcode, src, As, dst, Ad, FALSE)
END GenBinOpW;


PROCEDURE GenUnOpW (opcode, reg, As: INTEGER);
BEGIN
    GenUnOp(opcode, reg, As, FALSE)
END GenUnOpW;


PROCEDURE OpRegReg (op, src, dst: INTEGER);
BEGIN
    GenBinOpW(op, src, mREG, dst, mREG)
END OpRegReg;


PROCEDURE OpImmRegMode (op, imm, reg, mode: INTEGER; byte: BOOLEAN);
BEGIN
    CASE imm OF
    | 0: GenBinOp(op, CG, mREG,   reg, mode, byte)
    | 1: GenBinOp(op, CG, mIDX,   reg, mode, byte)
    | 2: GenBinOp(op, CG, mINDIR, reg, mode, byte)
    | 4: GenBinOp(op, SR, mINDIR, reg, mode, byte)
    | 8: GenBinOp(op, SR, mINCR,  reg, mode, byte)
    |-1: GenBinOp(op, CG, mINCR,  reg, mode, byte)
    ELSE
        GenBinOp(op, PC, mINCR, reg, mode, byte);
        EmitWord(imm)
    END
END OpImmRegMode;


PROCEDURE OpImmReg (op, imm, reg: INTEGER);
BEGIN
    OpImmRegMode(op, imm, reg, mREG, FALSE)
END OpImmReg;


PROCEDURE OpImmRegIdx (op, imm, reg: INTEGER);
BEGIN
    OpImmRegMode(op, imm, reg, mIDX, FALSE)
END OpImmRegIdx;


PROCEDURE OpImmRegIdxBW (op, imm, reg: INTEGER; byte: BOOLEAN);
BEGIN
    OpImmRegMode(op, imm, reg, mIDX, byte)
END OpImmRegIdxBW;


PROCEDURE MovRegReg (src, dst: INTEGER);
BEGIN
    OpRegReg(opMOV, src, dst)
END MovRegReg;


PROCEDURE MovImmReg (imm, reg: INTEGER);
BEGIN
    OpImmReg(opMOV, imm, reg)
END MovImmReg;


PROCEDURE CmpImmReg (imm, reg: INTEGER);
BEGIN
    OpImmReg(opCMP, imm, reg)
END CmpImmReg;


PROCEDURE AddImmReg (imm, reg: INTEGER);
BEGIN
    OpImmReg(opADD, imm, reg)
END AddImmReg;


PROCEDURE SubImmReg (imm, reg: INTEGER);
BEGIN
    OpImmReg(opSUB, imm, reg)
END SubImmReg;


PROCEDURE DecReg (reg: INTEGER);
BEGIN
    SubImmReg(1, reg)
END DecReg;


PROCEDURE IncReg (reg: INTEGER);
BEGIN
    AddImmReg(1, reg)
END IncReg;


PROCEDURE PushImm (imm: INTEGER);
BEGIN
    CASE imm OF
    | 0: GenUnOpW(opPUSH, CG, mREG)
    | 1: GenUnOpW(opPUSH, CG, mIDX)
    | 2: GenUnOpW(opPUSH, CG, mINDIR)
    |-1: GenUnOpW(opPUSH, CG, mINCR)
    ELSE
        GenUnOpW(opPUSH, PC, mINCR);
        EmitWord(imm)
    END
END PushImm;


PROCEDURE PutWord (word: INTEGER; VAR adr: INTEGER);
BEGIN
    ASSERT(~ODD(adr));
    ASSERT((0 <= word) & (word <= 65535));
    mem[adr] := word MOD 256;
    mem[adr + 1] := word DIV 256;
    INC(adr, 2)
END PutWord;


PROCEDURE Fixup (CodeAdr, IntVectorSize: INTEGER): INTEGER;
VAR
    cmd:      ANYCODE;
    adr:      INTEGER;
    offset:   INTEGER;
    diff:     INTEGER;
    cc:       INTEGER;
    shorted:  BOOLEAN;

BEGIN
    REPEAT
        shorted := FALSE;
        offset := CodeAdr DIV 2;

        cmd := CodeList.first(ANYCODE);
        WHILE cmd # NIL DO
            cmd.offset := offset;
            CASE cmd OF
            |LABEL: Labels[cmd.num] := cmd
            |JMP:   INC(offset);
                    IF ~cmd.short THEN
                        INC(offset);
                        IF cmd.cc # opJMP THEN
                            INC(offset)
                        END
                    END

            |CALL:  INC(offset, 2)
            |WORD:  INC(offset)
            END;
            cmd := cmd.next(ANYCODE)
        END;

        cmd := CodeList.first(ANYCODE);
        WHILE cmd # NIL DO
            IF (cmd IS JMP) & ~cmd(JMP).short THEN
                diff := Labels[cmd(JMP).label].offset - cmd.offset - 1;
                IF ABS(diff) <= 512 THEN
                    cmd(JMP).short := TRUE;
                    shorted := TRUE
                END
            END;
            cmd := cmd.next(ANYCODE)
        END

    UNTIL ~shorted;

    IF offset * 2 > 10000H - IntVectorSize THEN
        ERRORS.error1("size of program is too large")
    END;

    adr := CodeAdr;
    cmd := CodeList.first(ANYCODE);
    WHILE cmd # NIL DO
        CASE cmd OF
        |LABEL:

        |JMP:   IF ~cmd.short THEN
                    CASE cmd.cc OF
                    |opJNE: cc := opJEQ
                    |opJEQ: cc := opJNE
                    |opJNC: cc := opJC
                    |opJC:  cc := opJNC
                    |opJGE: cc := opJL
                    |opJL:  cc := opJGE
                    |opJMP: cc := opJMP
                    END;

                    IF cc # opJMP THEN
                        PutWord(LSL(cc + 8, 10) + 2, adr)  (* jcc L *)
                    END;

                    PutWord(4030H, adr); (* MOV @PC+, PC *)
                    PutWord(Labels[cmd.label].offset * 2, adr)
                    (* L: *)
                ELSE
                    diff := Labels[cmd.label].offset - cmd.offset - 1;
                    ASSERT((-512 <= diff) & (diff <= 511));
                    PutWord(LSL(cmd.cc + 8, 10) + ORD(BITS(diff) * {0..9}), adr)
                END

        |CALL:  PutWord(12B0H, adr); (* CALL @PC+ *)
                PutWord(Labels[cmd.label].offset * 2, adr)

        |WORD:  PutWord(cmd.val, adr)

        END;
        cmd := cmd.next(ANYCODE)
    END

    RETURN adr - CodeAdr
END Fixup;


PROCEDURE NewLabel (): INTEGER;
VAR
    L: INTEGER;

BEGIN
    L := CODE.NewLabel();
    IF L >= LEN(Labels) THEN
        ERRORS.error1("size of program is too large")
    END

    RETURN L
END NewLabel;


PROCEDURE PushReg (reg: INTEGER);
BEGIN
    GenUnOpW(opPUSH, reg, mREG)
END PushReg;


PROCEDURE Pop (reg: INTEGER);
BEGIN
    GenBinOpW(opMOV, SP, mINCR, reg, mREG)
END Pop;


PROCEDURE Test (reg: INTEGER);
BEGIN
    CmpImmReg(0, reg)
END Test;


PROCEDURE Clear (reg: INTEGER);
BEGIN
    OpRegReg(opSUB, reg, reg)
END Clear;


PROCEDURE mov (dst, src: INTEGER);
BEGIN
    MovRegReg(src, dst)
END mov;


PROCEDURE xchg (reg1, reg2: INTEGER);
BEGIN
    PushReg(reg1);
    PushReg(reg2);
    Pop(reg1);
    Pop(reg2)
END xchg;


PROCEDURE Reloc (section, value: INTEGER);
VAR
    reloc: RELOC;

BEGIN
    NEW(reloc);
    ERRORS.OutOfMemory(reloc = NIL);
    EmitWord(value);
    reloc.section := section;
    reloc.WordPtr := CodeList.last(WORD);
    LISTS.push(RelList, reloc)
END Reloc;


PROCEDURE CallRTL (proc, params: INTEGER);
BEGIN
    EmitCall(CODE.codes.rtl[proc]);
    IF params > 0 THEN
        AddImmReg(params * 2, SP)
    END
END CallRTL;


PROCEDURE UnOp (VAR reg: INTEGER);
BEGIN
    REG.UnOp(R, reg)
END UnOp;


PROCEDURE BinOp (VAR reg1, reg2: INTEGER);
BEGIN
    REG.BinOp(R, reg1, reg2)
END BinOp;


PROCEDURE GetRegA;
BEGIN
    ASSERT(REG.GetReg(R, ACC))
END GetRegA;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    DEC(R.pushed, NumberOfParameters)
END PushAll;


PROCEDURE cond (op: INTEGER): INTEGER;
VAR
    res: INTEGER;

BEGIN
    CASE op OF
    |CODE.opGT, CODE.opGTR, CODE.opLTL: res := jg
    |CODE.opGE, CODE.opGER, CODE.opLEL: res := jge
    |CODE.opLT, CODE.opLTR, CODE.opGTL: res := jl
    |CODE.opLE, CODE.opLER, CODE.opGEL: res := jle
    |CODE.opEQ, CODE.opEQR, CODE.opEQL: res := je
    |CODE.opNE, CODE.opNER, CODE.opNEL: res := jne
    END

    RETURN res
END cond;


PROCEDURE inv0 (op: INTEGER): INTEGER;
    RETURN ORD(BITS(op) / {0})
END inv0;


PROCEDURE jcc (cc, label: INTEGER);
VAR
    L: INTEGER;

BEGIN
    CASE cc OF
    |jne:
        EmitJmp(opJNE, label)
    |je:
        EmitJmp(opJEQ, label)
    |jge:
        EmitJmp(opJGE, label)
    |jl:
        EmitJmp(opJL, label)
    |jle:
        EmitJmp(opJL, label);
        EmitJmp(opJEQ, label)
    |jg:
        L := NewLabel();
        EmitJmp(opJEQ, L);
        EmitJmp(opJGE, label);
        EmitLabel(L)
    |jb:
        EmitJmp(opJNC, label)
    END
END jcc;


PROCEDURE setcc (cc, reg: INTEGER);
VAR
    L: INTEGER;

BEGIN
    L := NewLabel();
    MovImmReg(1, reg);
    jcc(cc, L);
    Clear(reg);
    EmitLabel(L)
END setcc;


PROCEDURE Shift2 (op, reg, n: INTEGER);
VAR
    reg2: INTEGER;

BEGIN
    IF n >= 8 THEN
        CASE op OF
        |CODE.opASR2: GenUnOpW(opSWPB, reg, mREG); GenUnOpW(opSXT, reg, mREG)
        |CODE.opROR2: GenUnOpW(opSWPB, reg, mREG)
        |CODE.opLSL2: GenUnOpW(opSWPB, reg, mREG); OpImmReg(opBIC, 255, reg)
        |CODE.opLSR2: OpImmReg(opBIC, 255, reg); GenUnOpW(opSWPB, reg, mREG)
        END;
        DEC(n, 8)
    END;

    IF (op = CODE.opROR2) & (n > 0) THEN
        reg2 := REG.GetAnyReg(R);
        MovRegReg(reg, reg2)
    ELSE
        reg2 := -1
    END;

    WHILE n > 0 DO
        CASE op OF
        |CODE.opASR2: GenUnOpW(opRRA, reg, mREG)
        |CODE.opROR2: GenUnOpW(opRRC, reg2, mREG); GenUnOpW(opRRC, reg, mREG)
        |CODE.opLSL2: OpRegReg(opADD, reg, reg)
        |CODE.opLSR2: OpImmReg(opBIC, 1, SR); GenUnOpW(opRRC, reg, mREG)
        END;
        DEC(n)
    END;

    IF reg2 # -1 THEN
        drop
    END

END Shift2;


PROCEDURE Neg (reg: INTEGER);
VAR
    reg2: INTEGER;

BEGIN
    reg2 := REG.GetAnyReg(R);
    Clear(reg2);
    OpRegReg(opSUB, reg, reg2);
    MovRegReg(reg2, reg);
    drop
END Neg;


PROCEDURE translate (code: CODE.CODES);
VAR
    cmd: COMMAND;

    opcode, param1, param2, label, L, a, n: INTEGER;

    reg1, reg2: INTEGER;

    cc: INTEGER;

BEGIN
    cmd := code.commands.first(COMMAND);

    WHILE cmd # NIL DO

        param1 := cmd.param1;
        param2 := cmd.param2;

        opcode := cmd.opcode;

        CASE opcode OF
        |CODE.opJMP:
            EmitJmp(opJMP, param1)

        |CODE.opCALL:
            EmitCall(param1)

        |CODE.opCALLP:
            UnOp(reg1);
            GenUnOpW(opCALL, reg1, mREG);
            drop;
            ASSERT(R.top = -1)

        |CODE.opPRECALL:
            PushAll(0)

        |CODE.opLABEL:
            EmitLabel(param2)

        |CODE.opSADR_PARAM:
            GenUnOpW(opPUSH, PC, mINCR);
            Reloc(RDATA, param2)

        |CODE.opERR:
            CallRTL(CODE._error, 2)

        |CODE.opERRC:
            PushImm(param2)

        |CODE.opENTER:
            ASSERT(R.top = -1);

            EmitLabel(param1);

            PushReg(BP);
            MovRegReg(SP, BP);

            IF param2 > 8 THEN
                MovImmReg(param2, R4);
                L := NewLabel();
                EmitLabel(L);
                PushReg(CG);
                DecReg(R4);
                jcc(jne, L)
            ELSIF param2 > 0 THEN
                WHILE param2 > 0 DO
                    PushReg(CG);
                    DEC(param2)
                END
            END

        |CODE.opLEAVE, CODE.opLEAVER:
            ASSERT(param2 = 0);
            IF opcode = CODE.opLEAVER THEN
                UnOp(reg1);
                IF reg1 # ACC THEN
                    GetRegA;
                    ASSERT(REG.Exchange(R, reg1, ACC));
                    drop
                END;
                drop
            END;

            ASSERT(R.top = -1);

            MovRegReg(BP, SP);
            Pop(BP);
            Pop(PC)

        |CODE.opRES:
            ASSERT(R.top = -1);
            GetRegA

        |CODE.opCLEANUP:
            IF param2 # 0 THEN
                AddImmReg(param2 * 2, SP)
            END

        |CODE.opCONST:
            reg1 := REG.GetAnyReg(R);
            MovImmReg(param2, reg1)

        |CODE.opSADR:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, PC, mINCR, reg1, mREG);
            Reloc(RDATA, param2)

        |CODE.opGADR:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, PC, mINCR, reg1, mREG);
            Reloc(RBSS, param2)

        |CODE.opLADR:
            reg1 := REG.GetAnyReg(R);
            MovRegReg(BP, reg1);
            OpImmReg(opADD, param2 * 2, reg1)

        |CODE.opLLOAD8:
            reg1 := REG.GetAnyReg(R);
            GenBinOp(opMOV, BP, mIDX, reg1, mREG, TRUE);
            EmitWord(param2 * 2)

        |CODE.opLLOAD16, CODE.opVADR:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, BP, mIDX, reg1, mREG);
            EmitWord(param2 * 2)

        |CODE.opGLOAD8:
            reg1 := REG.GetAnyReg(R);
            GenBinOp(opMOV, SR, mIDX, reg1, mREG, TRUE);
            Reloc(RBSS, param2)

        |CODE.opGLOAD16:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, SR, mIDX, reg1, mREG);
            Reloc(RBSS, param2)

        |CODE.opLOAD8:
            UnOp(reg1);
            GenBinOp(opMOV, reg1, mINDIR, reg1, mREG, TRUE)

        |CODE.opLOAD16:
            UnOp(reg1);
            GenBinOpW(opMOV, reg1, mINDIR, reg1, mREG)

        |CODE.opVLOAD8:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, BP, mIDX, reg1, mREG);
            EmitWord(param2 * 2);
            GenBinOp(opMOV, reg1, mINDIR, reg1, mREG, TRUE)

        |CODE.opVLOAD16:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, BP, mIDX, reg1, mREG);
            EmitWord(param2 * 2);
            GenBinOpW(opMOV, reg1, mINDIR, reg1, mREG)

        |CODE.opSAVE, CODE.opSAVE16:
            BinOp(reg2, reg1);
            GenBinOpW(opMOV, reg2, mREG, reg1, mIDX);
            EmitWord(0);
            drop;
            drop

        |CODE.opSAVE8:
            BinOp(reg2, reg1);
            GenBinOp(opMOV, reg2, mREG, reg1, mIDX, TRUE);
            EmitWord(0);
            drop;
            drop

        |CODE.opSAVE8C:
            UnOp(reg1);
            OpImmRegIdxBW(opMOV, param2, reg1, TRUE);
            EmitWord(0);
            drop

        |CODE.opSAVE16C, CODE.opSAVEC:
            UnOp(reg1);
            OpImmRegIdx(opMOV, param2, reg1);
            EmitWord(0);
            drop

        |CODE.opUMINUS:
            UnOp(reg1);
            Neg(reg1)

        |CODE.opADD:
            BinOp(reg1, reg2);
            OpRegReg(opADD, reg2, reg1);
            drop

        |CODE.opADDL, CODE.opADDR:
            IF param2 # 0 THEN
                UnOp(reg1);
                AddImmReg(param2, reg1)
            END

        |CODE.opSUB:
            BinOp(reg1, reg2);
            OpRegReg(opSUB, reg2, reg1);
            drop

        |CODE.opSUBR, CODE.opSUBL:
            UnOp(reg1);
            IF param2 # 0 THEN
                SubImmReg(param2, reg1)
            END;
            IF opcode = CODE.opSUBL THEN
                reg2 := REG.GetAnyReg(R);
                Clear(reg2);
                OpRegReg(opSUB, reg1, reg2);
                drop;
                drop;
                ASSERT(REG.GetReg(R, reg2))
            END

        |CODE.opLADR_SAVEC:
            OpImmRegIdx(opMOV, param2, BP);
            EmitWord(param1 * 2)

        |CODE.opLADR_SAVE:
            UnOp(reg1);
            GenBinOpW(opMOV, reg1, mREG, BP, mIDX);
            EmitWord(param2 * 2);
            drop

        |CODE.opGADR_SAVEC:
            OpImmRegIdx(opMOV, param2, SR);
            Reloc(RBSS, param1)

        |CODE.opCONST_PARAM:
            PushImm(param2)

        |CODE.opPARAM:
            IF param2 = 1 THEN
                UnOp(reg1);
                PushReg(reg1);
                drop
            ELSE
                ASSERT(R.top + 1 <= param2);
                PushAll(param2)
            END

        |CODE.opEQL..CODE.opGEL,
         CODE.opEQR..CODE.opGER,
         CODE.opEQ..CODE.opGE:

            IF (CODE.opEQ <= opcode) & (opcode <= CODE.opGE) THEN
                BinOp(reg1, reg2);
                OpRegReg(opCMP, reg2, reg1);
                drop
            ELSE
                UnOp(reg1);
                CmpImmReg(param2, reg1)
            END;

            drop;
            cc := cond(opcode);

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).param1;
                jcc(cc, label);
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).param1;
                jcc(inv0(cc), label);
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);
                setcc(cc, reg1)
            END

        |CODE.opNOP:

        |CODE.opCODE:
            EmitWord(param2)

        |CODE.opACC:
            IF (R.top # 0) OR (R.stk[0] # ACC) THEN
                PushAll(0);
                GetRegA;
                Pop(ACC);
                DEC(R.pushed)
            END

        |CODE.opDROP:
            UnOp(reg1);
            drop

        |CODE.opJNZ:
            UnOp(reg1);
            Test(reg1);
            jcc(jne, param1)

        |CODE.opJZ:
            UnOp(reg1);
            Test(reg1);
            jcc(je, param1)

        |CODE.opJG:
            UnOp(reg1);
            Test(reg1);
            jcc(jg, param1)

        |CODE.opJE:
            UnOp(reg1);
            Test(reg1);
            jcc(jne, param1);
            drop

        |CODE.opJNE:
            UnOp(reg1);
            Test(reg1);
            jcc(je, param1);
            drop

        |CODE.opNOT:
            UnOp(reg1);
            Test(reg1);
            setcc(je, reg1)

        |CODE.opORD:
            UnOp(reg1);
            Test(reg1);
            setcc(jne, reg1)

        |CODE.opLOOP:
        |CODE.opENDLOOP:

        |CODE.opGET:
            BinOp(reg1, reg2);
            drop;
            drop;
            GenBinOp(opMOV, reg1, mINDIR, reg2, mIDX, param2 = 1);
            EmitWord(0)

        |CODE.opCHKIDX:
            UnOp(reg1);
            CmpImmReg(param2, reg1);
            jcc(jb, param1)

        |CODE.opCHKIDX2:
            BinOp(reg1, reg2);
            IF param2 # -1 THEN
                OpRegReg(opCMP, reg1, reg2);
                MovRegReg(reg2, reg1);
                drop;
                jcc(jb, param1)
            ELSE
                INCL(R.regs, reg1);
                DEC(R.top);
                R.stk[R.top] := reg2
            END

        |CODE.opINC1, CODE.opINC1B:
            UnOp(reg1);
            GenBinOp(opADD, CG, mIDX, reg1, mIDX, opcode = CODE.opINC1B);
            EmitWord(0);
            drop

        |CODE.opDEC1, CODE.opDEC1B:
            UnOp(reg1);
            GenBinOp(opSUB, CG, mIDX, reg1, mIDX, opcode = CODE.opDEC1B);
            EmitWord(0);
            drop

        |CODE.opINCC, CODE.opINCCB:
            UnOp(reg1);
            OpImmRegIdxBW(opADD, param2, reg1, opcode = CODE.opINCCB);
            EmitWord(0);
            drop

        |CODE.opDECC, CODE.opDECCB:
            UnOp(reg1);
            OpImmRegIdxBW(opSUB, param2, reg1, opcode = CODE.opDECCB);
            EmitWord(0);
            drop

        |CODE.opINC, CODE.opINCB:
            BinOp(reg1, reg2);
            GenBinOp(opADD, reg1, mREG, reg2, mIDX, opcode = CODE.opINCB);
            EmitWord(0);
            drop;
            drop

        |CODE.opDEC, CODE.opDECB:
            BinOp(reg1, reg2);
            GenBinOp(opSUB, reg1, mREG, reg2, mIDX, opcode = CODE.opDECB);
            EmitWord(0);
            drop;
            drop

        |CODE.opLADR_INC1, CODE.opLADR_INC1B:
            GenBinOp(opADD, CG, mIDX, BP, mIDX, opcode = CODE.opLADR_INC1B);
            EmitWord(param2 * 2)

        |CODE.opLADR_DEC1, CODE.opLADR_DEC1B:
            GenBinOp(opSUB, CG, mIDX, BP, mIDX, opcode = CODE.opLADR_DEC1B);
            EmitWord(param2 * 2)

        |CODE.opLADR_INCC, CODE.opLADR_INCCB:
            OpImmRegIdxBW(opADD, param2, BP, opcode = CODE.opLADR_INCCB);
            EmitWord(param1 * 2)

        |CODE.opLADR_DECC, CODE.opLADR_DECCB:
            OpImmRegIdxBW(opSUB, param2, BP, opcode = CODE.opLADR_DECCB);
            EmitWord(param1 * 2)

        |CODE.opLADR_INC, CODE.opLADR_INCB:
            UnOp(reg1);
            GenBinOp(opADD, reg1, mREG, BP, mIDX, opcode = CODE.opLADR_INCB);
            EmitWord(param2 * 2);
            drop

        |CODE.opLADR_DEC, CODE.opLADR_DECB:
            UnOp(reg1);
            GenBinOp(opSUB, reg1, mREG, BP, mIDX, opcode = CODE.opLADR_DECB);
            EmitWord(param2 * 2);
            drop

        |CODE.opPUSHT:
            UnOp(reg1);
            reg2 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, reg1, mIDX, reg2, mREG);
            EmitWord(-2)

        |CODE.opISREC:
            PushAll(2);
            PushImm(param2);
            CallRTL(CODE._guardrec, 3);
            GetRegA

        |CODE.opIS:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._is, 2);
            GetRegA

        |CODE.opTYPEGR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            GetRegA

        |CODE.opTYPEGP:
            UnOp(reg1);
            PushAll(0);
            PushReg(reg1);
            PushImm(param2);
            CallRTL(CODE._guard, 2);
            GetRegA

        |CODE.opTYPEGD:
            UnOp(reg1);
            PushAll(0);
            GenUnOpW(opPUSH, reg1, mIDX);
            EmitWord(-2);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            GetRegA

        |CODE.opMULS:
            BinOp(reg1, reg2);
            OpRegReg(opAND, reg2, reg1);
            drop

        |CODE.opMULSC:
            UnOp(reg1);
            OpImmReg(opAND, param2, reg1)

        |CODE.opDIVS:
            BinOp(reg1, reg2);
            OpRegReg(opXOR, reg2, reg1);
            drop

        |CODE.opDIVSC:
            UnOp(reg1);
            OpImmReg(opXOR, param2, reg1)

        |CODE.opADDS:
            BinOp(reg1, reg2);
            OpRegReg(opBIS, reg2, reg1);
            drop

        |CODE.opSUBS:
            BinOp(reg1, reg2);
            OpRegReg(opBIC, reg2, reg1);
            drop

        |CODE.opADDSL, CODE.opADDSR:
            UnOp(reg1);
            OpImmReg(opBIS, param2, reg1)

        |CODE.opSUBSL:
            UnOp(reg1);
            OpImmReg(opXOR, -1, reg1);
            OpImmReg(opAND, param2, reg1)

        |CODE.opSUBSR:
            UnOp(reg1);
            OpImmReg(opBIC, param2, reg1)

        |CODE.opUMINS:
            UnOp(reg1);
            OpImmReg(opXOR, -1, reg1)

        |CODE.opLENGTH:
            PushAll(2);
            CallRTL(CODE._length, 2);
            GetRegA

        |CODE.opMIN:
            BinOp(reg1, reg2);
            OpRegReg(opCMP, reg2, reg1);
            EmitWord(LSL(opJL + 8, 10) + 1); (* jl L *)
            MovRegReg(reg2, reg1);
                                             (* L: *)
            drop


        |CODE.opMAX:
            BinOp(reg1, reg2);
            OpRegReg(opCMP, reg2, reg1);
            EmitWord(LSL(opJGE + 8, 10) + 1); (* jge L *)
            MovRegReg(reg2, reg1);
                                              (* L: *)
            drop

        |CODE.opMINC:
            UnOp(reg1);
            CmpImmReg(param2, reg1);
            L := NewLabel();
            jcc(jl, L);
            MovImmReg(param2, reg1);
            EmitLabel(L)

        |CODE.opMAXC:
            UnOp(reg1);
            CmpImmReg(param2, reg1);
            L := NewLabel();
            jcc(jge, L);
            MovImmReg(param2, reg1);
            EmitLabel(L)

        |CODE.opSWITCH:
            UnOp(reg1);
            IF param2 = 0 THEN
                reg2 := ACC
            ELSE
                reg2 := R5
            END;
            IF reg1 # reg2 THEN
                ASSERT(REG.GetReg(R, reg2));
                ASSERT(REG.Exchange(R, reg1, reg2));
                drop
            END;
            drop

        |CODE.opENDSW:

        |CODE.opCASEL:
            CmpImmReg(param1, ACC);
            jcc(jl, param2)

        |CODE.opCASER:
            CmpImmReg(param1, ACC);
            jcc(jg, param2)

        |CODE.opCASELR:
            CmpImmReg(param1, ACC);
            jcc(jl, param2);
            jcc(jg, cmd.param3)

        |CODE.opSBOOL:
            BinOp(reg2, reg1);
            Test(reg2);
            setcc(jne, reg2);
            GenBinOp(opMOV, reg2, mREG, reg1, mIDX, TRUE);
            EmitWord(0);
            drop;
            drop

        |CODE.opSBOOLC:
            UnOp(reg1);
            IF param2 # 0 THEN
                GenBinOp(opMOV, CG, mIDX, reg1, mIDX, TRUE)
            ELSE
                GenBinOp(opMOV, CG, mREG, reg1, mIDX, TRUE)
            END;
            EmitWord(0);
            drop

        |CODE.opODD:
            UnOp(reg1);
            OpImmReg(opAND, 1, reg1)

        |CODE.opEQS .. CODE.opGES:
            PushAll(4);
            PushImm(opcode - CODE.opEQS);
            CallRTL(CODE._strcmp, 5);
            GetRegA

        |CODE.opEQS2 .. CODE.opGES2:
            PushAll(4);
            PushImm(opcode - CODE.opEQS2);
            CallRTL(CODE._strcmp2, 5);
            GetRegA

        |CODE.opLEN:
            UnOp(reg1);
            drop;
            EXCL(R.regs, reg1);

            WHILE param2 > 0 DO
                UnOp(reg2);
                drop;
                DEC(param2)
            END;

            INCL(R.regs, reg1);
            ASSERT(REG.GetReg(R, reg1))

        |CODE.opCHKBYTE:
            BinOp(reg1, reg2);
            CmpImmReg(256, reg1);
            jcc(jb, param1)

        |CODE.opLSL, CODE.opASR, CODE.opROR, CODE.opLSR:
            PushAll(2);
            CASE opcode OF
            |CODE.opLSL: PushImm(0)
            |CODE.opASR: PushImm(1)
            |CODE.opROR: PushImm(2)
            |CODE.opLSR: PushImm(3)
            END;
            CallRTL(CODE._shift2, 3);
            GetRegA

        |CODE.opLSL1, CODE.opASR1, CODE.opROR1, CODE.opLSR1:
            PushAll(1);
            PushImm(param2);
            CASE opcode OF
            |CODE.opLSL1: PushImm(0)
            |CODE.opASR1: PushImm(1)
            |CODE.opROR1: PushImm(2)
            |CODE.opLSR1: PushImm(3)
            END;
            CallRTL(CODE._shift, 3);
            GetRegA

        |CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
            param2 := ORD(BITS(param2) * {0..3});
            IF param2 # 0 THEN
                UnOp(reg1);
                Shift2(opcode, reg1, param2)
            END

        |CODE.opMUL:
            PushAll(2);
            CallRTL(CODE._mul, 2);
            GetRegA

        |CODE.opMULC:
            UnOp(reg1);

            a := param2;
            IF a > 1 THEN
                n := X86.log2(a)
            ELSIF a < -1 THEN
                n := X86.log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                Neg(reg1)
            ELSIF a = 0 THEN
                Clear(reg1)
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        Neg(reg1)
                    END;
                    Shift2(CODE.opLSL2, reg1, n)
                ELSE
                    PushAll(1);
                    PushImm(a);
                    CallRTL(CODE._mul, 2);
                    GetRegA
                END
            END

        |CODE.opDIV:
            PushAll(2);
            CallRTL(CODE._div, 2);
            GetRegA

        |CODE.opDIVR:
            ASSERT(param2 > 0);

            IF param2 > 1 THEN
                n := X86.log2(param2);
                IF n > 0 THEN
                    UnOp(reg1);
                    Shift2(CODE.opASR2, reg1, n)
                ELSE
                    PushAll(1);
                    PushImm(param2);
                    CallRTL(CODE._div, 2);
                    GetRegA
                END
            END

        |CODE.opDIVL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._div2, 2);
            GetRegA

        |CODE.opMOD:
            PushAll(2);
            CallRTL(CODE._mod, 2);
            GetRegA

        |CODE.opMODR:
            ASSERT(param2 > 0);

            IF param2 = 1 THEN
                UnOp(reg1);
                Clear(reg1)
            ELSE
                IF X86.log2(param2) > 0 THEN
                    UnOp(reg1);
                    OpImmReg(opAND, param2 - 1, reg1)
                ELSE
                    PushAll(1);
                    PushImm(param2);
                    CallRTL(CODE._mod, 2);
                    GetRegA
                END
            END

        |CODE.opMODL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._mod2, 2);
            GetRegA

        |CODE.opCOPYS:
            PushAll(4);
            CallRTL(CODE._strcpy, 4)

        |CODE.opCOPYS2:
            PushAll(4);
            CallRTL(CODE._strcpy2, 4)

        |CODE.opCOPY:
            PushAll(2);
            PushImm(param2);
            CallRTL(CODE._move2, 3)

        |CODE.opMOVE:
            PushAll(3);
            CallRTL(CODE._move2, 3)

        |CODE.opCOPYA:
            PushAll(4);
            PushImm(param2);
            CallRTL(CODE._arrcpy, 5);
            GetRegA

        |CODE.opROT:
            PushAll(0);
            MovRegReg(SP, ACC);
            PushReg(ACC);
            PushImm(param2);
            CallRTL(CODE._rot, 2)

        |CODE.opSAVES:
            PushAll(1);
            GenUnOpW(opPUSH, PC, mINCR);
            Reloc(RDATA, param2);
            PushImm(param1);
            CallRTL(CODE._move, 3)

        |CODE.opCASET:
            PushReg(R5);
            PushReg(R5);
            PushImm(param2);
            CallRTL(CODE._guardrec, 2);
            Pop(R5);
            Test(ACC);
            jcc(jne, param1)

        |CODE.opCHR:
            UnOp(reg1);
            OpImmReg(opAND, 255, reg1)

        |CODE.opABS:
            UnOp(reg1);
            Test(reg1);
            L := NewLabel();
            jcc(jge, L);
            Neg(reg1);
            EmitLabel(L)

        |CODE.opEQB, CODE.opNEB:
            BinOp(reg1, reg2);
            drop;

            Test(reg1);
            L := NewLabel();
            jcc(je, L);
            MovImmReg(1, reg1);
            EmitLabel(L);

            Test(reg2);
            L := NewLabel();
            jcc(je, L);
            MovImmReg(1, reg2);
            EmitLabel(L);

            OpRegReg(opCMP, reg2, reg1);
            IF opcode = CODE.opEQB THEN
                setcc(je, reg1)
            ELSE
                setcc(jne, reg1)
            END

        |CODE.opSAVEP:
            UnOp(reg1);
            GenBinOpW(opMOV, PC, mINCR, reg1, mIDX);
            Reloc(RCODE, param2);
            EmitWord(0);
            drop

        |CODE.opPUSHP:
            reg1 := REG.GetAnyReg(R);
            GenBinOpW(opMOV, PC, mINCR, reg1, mREG);
            Reloc(RCODE, param2)

        |CODE.opEQP, CODE.opNEP:
            UnOp(reg1);
            GenBinOpW(opCMP, PC, mINCR, reg1, mREG);
            Reloc(RCODE, param1);
            drop;
            reg1 := REG.GetAnyReg(R);

            IF opcode = CODE.opEQP THEN
                setcc(je, reg1)
            ELSIF opcode = CODE.opNEP THEN
                setcc(jne, reg1)
            END

        |CODE.opVADR_PARAM:
            GenUnOpW(opPUSH, BP, mIDX);
            EmitWord(param2 * 2)

        |CODE.opNEW:
            PushAll(1);
            n := param2 + 2;
            ASSERT(MACHINE.Align(n, 2));
            PushImm(n);
            PushImm(param1);
            CallRTL(CODE._new, 3)

        |CODE.opRSET:
            PushAll(2);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opRSETR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opRSETL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._set2, 2);
            GetRegA

        |CODE.opRSET1:
            UnOp(reg1);
            PushAll(1);
            PushReg(reg1);
            CallRTL(CODE._set, 2);
            GetRegA

        |CODE.opINCLC:
            UnOp(reg1);
            OpImmRegIdx(opBIS, LSL(1, param2), reg1);
            EmitWord(0);
            drop

        |CODE.opEXCLC:
            UnOp(reg1);
            OpImmRegIdx(opBIC, LSL(1, param2), reg1);
            EmitWord(0);
            drop

        |CODE.opIN:
            PushAll(2);
            CallRTL(CODE._in, 2);
            GetRegA

        |CODE.opINR:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._in, 2);
            GetRegA

        |CODE.opINL:
            PushAll(1);
            PushImm(param2);
            CallRTL(CODE._in2, 2);
            GetRegA

        |CODE.opINCL:
            PushAll(2);
            CallRTL(CODE._incl, 2)

        |CODE.opEXCL:
            PushAll(2);
            CallRTL(CODE._excl, 2)

        |CODE.opLADR_INCL, CODE.opLADR_EXCL:
            PushAll(1);
            MovRegReg(BP, ACC);
            AddImmReg(param2 * 2, ACC);
            PushReg(ACC);
            IF opcode = CODE.opLADR_INCL THEN
                CallRTL(CODE._incl, 2)
            ELSIF opcode = CODE.opLADR_EXCL THEN
                CallRTL(CODE._excl, 2)
            END

        |CODE.opLADR_INCLC:
            OpImmRegIdx(opBIS, LSL(1, param2), BP);
            EmitWord(param1 * 2)

        |CODE.opLADR_EXCLC:
            OpImmRegIdx(opBIC, LSL(1, param2), BP);
            EmitWord(param1 * 2)

        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)
END translate;


PROCEDURE prolog;
BEGIN
    _new := NewLabel();
    CODE.codes.rtl[CODE._new] := _new;
    IV[LEN(IV) - 1] := NewLabel();
    EmitLabel(IV[LEN(IV) - 1]);
    GenBinOpW(opMOV, PC, mINCR, SP, mREG);
    EmitWord(0);
    GenBinOpW(opMOV, PC, mINCR, HP, mREG);
    EmitWord(0);
    GenBinOpW(opMOV, PC, mINCR, SR, mIDX); (* stop WDT *)
    EmitWord(5A80H);
    EmitWord(0120H);
    GenBinOpW(opMOV, PC, mINCR, SR, mIDX);
    EmitWord(empty_proc_adr);
    EmitWord(int_adr)
END prolog;


PROCEDURE epilog;
VAR
    L1, L2, L3, L4: INTEGER;
    i: INTEGER;

BEGIN
    EmitWord(0D032H); EmitWord(0010H); (* BIS #10H, SR; CPUOFF *)

    L1 := NewLabel();
    L2 := NewLabel();
    L3 := NewLabel();

    EmitLabel(_new);
    PushReg(SR);
    Clear(SR);
    MovRegReg(R4, R4);
    MovRegReg(SP, R4);
    SubImmReg(16, R4);
    MovRegReg(HP, R5);
    GenBinOpW(opADD, SP, mIDX, R5, mREG); EmitWord(6);
    OpRegReg(opCMP, R5, R4);
    GenBinOpW(opMOV, SP, mIDX, R4, mREG); EmitWord(8);
    jcc(jl, L1);
    GenBinOpW(opMOV, SP, mIDX, HP, mIDX); EmitWord(4); EmitWord(0);
    AddImmReg(2, HP);
    GenBinOpW(opMOV, HP, mREG, R4, mIDX); EmitWord(0);
    EmitLabel(L3);
    GenBinOpW(opMOV, CG, mREG, HP, mIDX); EmitWord(0);
    AddImmReg(2, HP);
    OpRegReg(opCMP, R5, HP);
    jcc(jl, L3);
    EmitJmp(opJMP, L2);
    EmitLabel(L1);
    GenBinOpW(opMOV, CG, mREG, R4, mIDX); EmitWord(0);
    EmitLabel(L2);
    EmitWord(1300H); (* RETI *)

    L4 := NewLabel();
    FOR i := 0 TO LEN(IV) - 2 DO
        IV[i] := NewLabel();
        EmitLabel(IV[i]);
        PushImm(i);
        IF i # LEN(IV) - 2 THEN
            EmitJmp(opJMP, L4)
        END
    END;

    EmitLabel(L4);

    MovRegReg(SP, IR);

    FOR i := 0 TO 15 DO
        IF i IN R.regs + R.vregs THEN
            PushReg(i)
        END
    END;

    PushReg(IR);
    EmitWord(1220H + IR); (* PUSH @IR *)
    EmitWord(1292H);      (* CALL int_adr(SR) *)
    EmitWord(int_adr);
    AddImmReg(4, SP);

    FOR i := 15 TO 0 BY -1 DO
        IF i IN R.regs + R.vregs THEN
            Pop(i)
        END
    END;

    AddImmReg(2, SP);
    EmitWord(1300H) (* RETI *)
END epilog;


PROCEDURE hexdgt (n: BYTE): BYTE;
BEGIN
    IF n < 10 THEN
        n := n + ORD("0")
    ELSE
        n := n - 10 + ORD("A")
    END

    RETURN n
END hexdgt;


PROCEDURE WriteHexByte (file: FILES.FILE; byte: BYTE);
BEGIN
    WRITER.WriteByte(file, hexdgt(byte DIV 16));
    WRITER.WriteByte(file, hexdgt(byte MOD 16));
END WriteHexByte;


PROCEDURE WriteHex (file: FILES.FILE; mem: ARRAY OF BYTE; idx, cnt: INTEGER);
VAR
    i: INTEGER;

BEGIN
    WHILE cnt > 0 DO
        WRITER.WriteByte(file, ORD(":"));
        WriteHexByte(file, MIN(16, cnt));
        WriteHexByte(file, idx DIV 256);
        WriteHexByte(file, idx MOD 256);
        WriteHexByte(file, 0);
        i := MIN(16, cnt);
        WHILE i > 0 DO
            WriteHexByte(file, mem[idx]);
            INC(idx);
            DEC(i)
        END;
        DEC(cnt, MIN(16, cnt));
        WRITER.WriteByte(file, 0DH);
        WRITER.WriteByte(file, 0AH)
    END
END WriteHex;


PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target: INTEGER; options: PROG.OPTIONS);
CONST
    RTLVarSize  = 4;
    RTLDataSize = 4;
    IntVectorSize = LEN(IV) * 2 + RTLDataSize;
    minStackSize = 64;

VAR
    i, tcount, adr, heap, stack, DataSize,
    TextSize: INTEGER;

    Code, Data, Bss: RECORD address, size: INTEGER END;

    ram, rom: INTEGER;

    reloc: RELOC;

    file: FILES.FILE;

BEGIN
    ram := options.ram;
    rom := options.rom;

    IF ODD(ram) THEN DEC(ram) END;
    IF ODD(rom) THEN DEC(rom) END;

    ram := MIN(MAX(ram, minRAM), maxRAM);
    rom := MIN(MAX(rom, minROM), maxROM);

    IF code.bss > ram - minStackSize - RTLVarSize THEN
        ERRORS.error1("size of global variables is too large")
    END;

    IF code.lcount >= LEN(Labels) THEN
        ERRORS.error1("size of program is too large")
    END;

    FOR i := 0 TO LEN(mem) - 1 DO
        mem[i] := 0
    END;

    tcount := CHL.Length(code.types);
    CodeList := LISTS.create(NIL);
    RelList  := LISTS.create(NIL);
    R := REG.Create(PushReg, Pop, mov, xchg, NIL, NIL, {R4, R5, R6, R7}, {});

    prolog;
    translate(code);
    epilog;

    Code.address := 10000H - rom;
    Code.size := Fixup(Code.address, IntVectorSize + tcount * 2);
    Data.address := Code.address + Code.size;
    Data.size := CHL.Length(code.data);
    Data.size := Data.size + ORD(ODD(Data.size));
    TextSize  := Code.size + Data.size;

    IF Code.address + TextSize > 10000H - IntVectorSize - tcount * 2 THEN
        ERRORS.error1("size of program is too large")
    END;

    Bss.address := ram_adr + RTLVarSize;
    Bss.size := code.bss + ORD(ODD(code.bss));
    heap := Bss.address + Bss.size;
    stack := ram_adr + ram;
    ASSERT(stack - heap >= minStackSize);
    adr := Code.address + 2;
    PutWord(stack, adr);
    adr := Code.address + 6;
    PutWord(heap, adr);

    reloc := RelList.first(RELOC);
    WHILE reloc # NIL DO
        adr := reloc.WordPtr.offset * 2;
        CASE reloc.section OF
        |RCODE: PutWord(Labels[reloc.WordPtr.val].offset * 2, adr)
        |RDATA: PutWord(reloc.WordPtr.val + Data.address, adr)
        |RBSS:  PutWord(reloc.WordPtr.val + Bss.address, adr)
        END;
        reloc := reloc.next(RELOC)
    END;

    adr := Data.address;

    DataSize := CHL.Length(code.data);
    FOR i := 0 TO DataSize - 1 DO
        mem[adr] := CHL.GetByte(code.data, i);
        INC(adr)
    END;

    adr := 10000H - IntVectorSize - tcount * 2;

    FOR i := tcount - 1 TO 0 BY -1 DO
        PutWord(CHL.GetInt(code.types, i), adr)
    END;

    PutWord(4130H, adr); (* RET *)
    PutWord(stack, adr);

    FOR i := 0 TO LEN(IV) - 1 DO
        PutWord(Labels[IV[i]].offset * 2, adr)
    END;

    file := FILES.create(outname);
    WriteHex(file, mem, Code.address, TextSize);
    WriteHex(file, mem, 10000H - IntVectorSize - tcount * 2, IntVectorSize + tcount * 2);

    WRITER.WriteByte(file, ORD(":"));
    WriteHexByte(file, 0);
    WriteHexByte(file, 0);
    WriteHexByte(file, 0);
    WriteHexByte(file, 1);
    WriteHexByte(file, 255);
    WRITER.WriteByte(file, 0DH);
    WRITER.WriteByte(file, 0AH);

    FILES.close(file);

    INC(TextSize, IntVectorSize + tcount * 2);
    INC(Bss.size, minStackSize + RTLVarSize);

    C.StringLn("-------------------------------");
    C.String(  "  rom:  "); C.Int(TextSize); C.String(" of "); C.Int(rom); C.String("  ("); C.Int(TextSize * 100 DIV rom); C.StringLn("%)");
    C.String(  "  ram:  "); C.Int(Bss.size); C.String(" of "); C.Int(ram); C.String("  ("); C.Int(Bss.size * 100 DIV ram); C.StringLn("%)");
    C.StringLn("-------------------------------")

END CodeGen;


END MSP430.