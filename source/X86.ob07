(*
    BSD 2-Clause License

    Copyright (c) 2018, Anton Krotov
    All rights reserved.
*)

MODULE X86;

IMPORT CODE, REG, UTILS, STRINGS, LISTS, BIN, PE := PE32, KOS;


CONST

    N = 3;

    eax = REG.R0; ecx = REG.R1; edx = REG.R2;

    al = eax; cl = ecx; dl = edx;

    ax = eax; cx = ecx; dx = edx;

    sete = 94H; setne = 95H; setl = 9CH; setge = 9DH; setle = 9EH; setg = 9FH;

    je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H;


TYPE

    COMMAND = CODE.COMMAND;
    FILE = UTILS.FILE;


VAR

    error:   BOOLEAN;

    R:       REG.REGS;

    stroffs: INTEGER;

    program: BIN.PROGRAM;
    dllret:  INTEGER;
    dllinit: INTEGER;
    label_import:  INTEGER;


PROCEDURE fcreate (name: ARRAY OF CHAR): FILE;
    RETURN UTILS.fcreate(name)
END fcreate;


PROCEDURE fclose (file: FILE);
BEGIN
    UTILS.fclose(file)
END fclose;


PROCEDURE Byte (n: INTEGER): INTEGER;
    RETURN ORD(BITS(n) * {0..7})
END Byte;


PROCEDURE Word (n: INTEGER): INTEGER;
    RETURN ORD(BITS(n) * {0..15})
END Word;


PROCEDURE OutByte (n: INTEGER);
BEGIN
    ASSERT((0 <= n) & (n <= 255));
    BIN.PutCode(program, n)
END OutByte;


PROCEDURE OutCode (code: ARRAY OF CHAR);
VAR
    i, k, hi, lo: INTEGER;

BEGIN
    i := 0;
    k := LENGTH(code) - 1;
    ASSERT(ODD(k));

    WHILE i <= k DO
        hi := UTILS.digit[ORD(code[i])]; INC(i);
        ASSERT(hi # -1);
        lo := UTILS.digit[ORD(code[i])]; INC(i);
        ASSERT(lo # -1);
        OutByte(hi * 16 + lo)
    END
END OutCode;


PROCEDURE OutInt (n: INTEGER);
BEGIN
    BIN.PutCode32LE(program, n)
END OutInt;


PROCEDURE OutWord (n: INTEGER);
BEGIN
    ASSERT((0 <= n) & (n <= 65535));
    OutByte(n MOD 256);
    OutByte(n DIV 256)
END OutWord;


PROCEDURE isByte (n: INTEGER): BOOLEAN;
    RETURN (-128 <= n) & (n <= 127)
END isByte;


PROCEDURE OutIntByte (n: INTEGER);
BEGIN
    IF isByte(n) THEN
        OutByte(Byte(n))
    ELSE
        OutInt(n)
    END
END OutIntByte;


PROCEDURE _mov (reg1, reg2: INTEGER); // mov reg1, reg2
BEGIN
    OutByte(89H);
    OutByte(0C0H + reg2 * 8 + reg1)
END _mov;


PROCEDURE _xch (reg1, reg2: INTEGER); // xchg reg1, reg2
VAR
    regs: SET;

BEGIN
    regs := {reg1, reg2};
    IF regs = {eax, ecx} THEN
        OutByte(91H)
    ELSIF regs = {eax, edx} THEN
        OutByte(92H)
    ELSIF regs = {ecx, edx} THEN
        OutByte(87H); OutByte(0D1H)
    END
END _xch;


PROCEDURE _pop (reg: INTEGER); //pop reg
BEGIN
    OutByte(58H + reg)
END _pop;


PROCEDURE _push (reg: INTEGER); //push reg
BEGIN
    OutByte(50H + reg)
END _push;


PROCEDURE movrc (reg, n: INTEGER); //mov reg, n
BEGIN
    OutByte(0B8H + reg);
    OutInt(n)
END movrc;


PROCEDURE pushc (n: INTEGER);
BEGIN
    OutByte(68H + 2 * ORD(isByte(n)));
    OutIntByte(n)
END pushc;


PROCEDURE test (reg: INTEGER); //test reg, reg
BEGIN
    OutByte(85H);
    OutByte(0C0H + reg * 9)
END test;


PROCEDURE neg (reg: INTEGER); //neg reg
BEGIN
    OutByte(0F7H);
    OutByte(0D8H + reg)
END neg;


PROCEDURE not (reg: INTEGER); //not reg
BEGIN
    OutByte(0F7H);
    OutByte(0D0H + reg)
END not;


PROCEDURE add (reg1, reg2: INTEGER);  // add reg1, reg2
BEGIN
    OutByte(01H);
    OutByte(0C0H + reg2 * 8 + reg1)
END add;


PROCEDURE andrc (reg, n: INTEGER); //and reg, n
BEGIN
    OutByte(81H + 2 * ORD(isByte(n)));
    OutByte(0E0H + reg);
    OutIntByte(n)
END andrc;


PROCEDURE addrc (reg, n: INTEGER);  //add reg, n
BEGIN
    OutByte(81H + 2 * ORD(isByte(n)));
    OutByte(0C0H + reg);
    OutIntByte(n)
END addrc;


PROCEDURE cmprr (reg1, reg2: INTEGER); // cmp reg1, reg2
BEGIN
    OutByte(39H);
    OutByte(0C0H + reg2 * 8 + reg1)
END cmprr;


PROCEDURE cmprc (reg, n: INTEGER); // cmp reg, n
BEGIN
    OutByte(81H + 2 * ORD(isByte(n)));
    OutByte(0F8H + reg);
    OutIntByte(n)
END cmprc;


PROCEDURE setcc (cond, reg: INTEGER);  // setcc reg
BEGIN
    OutByte(0FH);
    OutByte(cond);
    OutByte(0C0H + reg)
END setcc;


PROCEDURE log2 (x: INTEGER): INTEGER;
VAR
    n: INTEGER;

BEGIN
    ASSERT(x > 0);

    n := 0;
    WHILE ~ODD(x) DO
        x := x DIV 2;
        INC(n)
    END;

    IF x # 1 THEN
        n := -1
    END

    RETURN n
END log2;


PROCEDURE jcc (opcode, label: INTEGER);
BEGIN
    BIN.PutCode(program, 0FH);
    BIN.PutCode(program, opcode); (* je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H; *)
    BIN.PutReloc(program, 1);
    BIN.PutCode32LE(program, label)
END jcc;


PROCEDURE CallRTL (proc: INTEGER);
BEGIN
    BIN.PutCode(program, 0E8H);    //call L
    BIN.PutReloc(program, 1);
    BIN.PutCode32LE(program, CODE.codes.rtl[proc])
END CallRTL;


PROCEDURE translate (code: CODE.CODES);
VAR
    cmd, next, next2: COMMAND;

    reg1, reg2: INTEGER;

    n, a, b, label: INTEGER;

BEGIN
    cmd := code.commands.first(COMMAND);

    WHILE cmd # NIL DO

        CASE cmd.opcode OF

        |CODE.opJMP:
            BIN.PutCode(program, 0E9H);     //jmp L
            BIN.PutReloc(program, 1);
            BIN.PutCode32LE(program, cmd.label)

        |CODE.opCALL:
            BIN.PutCode(program, 0E8H);             //call L
            BIN.PutReloc(program, 1);
            BIN.PutCode32LE(program, cmd.label)

        |CODE.opCALLI:
            BIN.PutCode(program, 0FFH);   //call dword[L]
            BIN.PutCode(program, 015H);
            BIN.PutReloc(program, 2);
            BIN.PutCode32LE(program, cmd.label)

        |CODE.opCALLP:
            REG.UnOp(R, reg1);

            OutByte(0FFH);          //call reg1
            OutByte(0D0H + reg1);

            reg1 := REG.Drop(R);
            ASSERT(R.top = -1)

        |CODE.opPRECALL:
            n := cmd.param;
            IF (cmd.param2 # 0) & (n # 0) THEN
                OutCode("83EC08") //sub esp,8
            END;
            WHILE n > 0 DO
                OutCode("83EC08"); // sub esp,8
                OutCode("DD1C24"); // fstp qword[esp]
                DEC(n)
            END;
            REG.PushAll(R)

        |CODE.opRES:
            ASSERT(R.top = -1);
            ASSERT(REG.GetReg(R, eax));
            n := cmd.param;
            WHILE n > 0 DO
                OutCode("DD0424"); // fld qword[esp]
                OutCode("83C408"); // add esp,8
                DEC(n)
            END

        |CODE.opRESF:
            n := cmd.param;
            IF n > 0 THEN
                OutByte(0DDH); OutByte(5CH + 40H * ORD(~isByte(n * 8)));
                OutByte(24H); OutIntByte(n * 8); // fstp qword[esp + n*8]
                INC(n)
            END;

            WHILE n > 0 DO
                OutCode("DD0424"); // fld qword[esp]
                OutCode("83C408"); // add esp,8
                DEC(n)
            END

        |CODE.opENTER:
            ASSERT(R.top = -1);
            OutCode("5589E5"); // push ebp
                               // mov ebp,esp

            n := cmd.param;
            IF n > 4 THEN
                movrc(ecx, n);   // mov ecx,n
                pushc(0);        // @@: push 0
                OutCode("E2FC")  // loop @b
            ELSE
                WHILE n > 0 DO
                    pushc(0);
                    DEC(n)
                END
            END

        |CODE.opLEAVE, CODE.opLEAVER, CODE.opLEAVEF:
            IF cmd.opcode = CODE.opLEAVER THEN
                REG.UnOp(R, reg1);
                IF reg1 # eax THEN
                    ASSERT(REG.GetReg(R, eax));
                    ASSERT(REG.Exchange(R, reg1, eax));
                    reg1 := REG.Drop(R)
                END;
                reg1 := REG.Drop(R)
            END;

            ASSERT(R.top = -1);

            OutCode("89EC5D"); // mov esp,ebp
                               // pop ebp

            n := cmd.param;
            IF n > 0 THEN
                n := n * 4;
                OutByte(0C2H); OutWord(Word(n)) // ret n
            ELSE
                OutByte(0C3H) // ret
            END

        |CODE.opERRC:
            pushc(cmd.param)

        |CODE.opPARAM:
            n := cmd.param;
            IF n = 1 THEN
                REG.UnOp(R, reg1);
                _push(reg1);
                reg1 := REG.Drop(R)
            ELSE
                ASSERT(R.top + 1 <= n);
                REG.PushAll(R);
                R.pushed := R.pushed - n
            END

        |CODE.opCLEANUP:
            n := cmd.param * 4;
            IF n # 0 THEN
                OutByte(81H + 2 * ORD(isByte(n))); OutByte(0C4H);  // add esp, n
                OutIntByte(n)
            END

        |CODE.opCONST:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                pushc(cmd.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                movrc(reg1, cmd.param)
            END

        |CODE.opLABEL,
         CODE.opPROC:
            BIN.SetLabel(program, cmd.param) //L:

        |CODE.opNOP:

        |CODE.opGADR:
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opSAVEC THEN
                //mov dword[_bss+cmd.param],next.param
                BIN.PutCode(program, 0C7H);
                BIN.PutCode(program,  05H);
                BIN.PutReloc(program, 3);
                BIN.PutCode32LE(program, cmd.param);
                BIN.PutCode32LE(program, next.param);

                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                //mov reg1,_bss+cmd.param
                BIN.PutCode(program, 0B8H + reg1);
                BIN.PutReloc(program, 3);
                BIN.PutCode32LE(program, cmd.param);

            END

        |CODE.opLADR:
            n := cmd.param * 4;
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opSAVEC THEN
                OutByte(0C7H); OutByte(45H + 40H * ORD(~isByte(n)));
                OutIntByte(n);   // mov dword[ebp + n], next.param
                OutInt(next.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);         // lea reg1, dword[ebp + n]
                OutByte(8DH); OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
                OutIntByte(n)
            END

        |CODE.opVADR:
            n := cmd.param * 4;
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte(0FFH); OutByte(75H + 40H * ORD(~isByte(n)));
                OutIntByte(n);   //push dword[ebp + n]
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte(8BH); // mov reg1, dword[ebp + n]
                OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
                OutIntByte(n)
            END

        |CODE.opSADR:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                //push _data + stroffs + cmd.param
                BIN.PutCode(program, 068H);
                BIN.PutReloc(program, 4);
                BIN.PutCode32LE(program, stroffs + cmd.param);

                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                //mov reg1,_data + stroffs + cmd.param
                BIN.PutCode(program, 0B8H + reg1);
                BIN.PutReloc(program, 4);
                BIN.PutCode32LE(program, stroffs + cmd.param)

            END

        |CODE.opSAVEC:
            REG.UnOp(R, reg1);
            OutByte(0C7H); OutByte(reg1); OutInt(cmd.param); //mov dword[reg1], cmd.param
            reg1 := REG.Drop(R)

        |CODE.opSAVE8C:
            REG.UnOp(R, reg1);
            OutByte(0C6H); OutByte(reg1); OutByte(Byte(cmd.param)); //mov byte[reg1], cmd.param
            reg1 := REG.Drop(R)

        |CODE.opSAVE16C:
            REG.UnOp(R, reg1);
            OutByte(66H); OutByte(0C7H); OutByte(reg1); OutWord(Word(cmd.param)); //mov word[reg1], cmd.param
            reg1 := REG.Drop(R)

        |CODE.opVLOAD32:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte(8BH); OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n))); // mov reg1, dword[ebp + n]
            OutIntByte(n);
            OutByte(8BH); OutByte(reg1 * 9); // mov reg1, dword[reg1]

        |CODE.opGLOAD32:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                //push dword[_bss+cmd.param]
                BIN.PutCode(program, 0FFH);
                BIN.PutCode(program, 035H);
                BIN.PutReloc(program, 3);
                BIN.PutCode32LE(program, cmd.param);

                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                //mov reg1,dword[_bss+cmd.param]
                BIN.PutCode(program, 08BH);
                BIN.PutCode(program,  05H + reg1 * 8);
                BIN.PutReloc(program, 3);
                BIN.PutCode32LE(program, cmd.param)
            END

        |CODE.opLLOAD32:
            next := cmd.next(COMMAND);
            n := cmd.param * 4;
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte(0FFH); OutByte(75H + 40H * ORD(~isByte(n)));
                OutIntByte(n);                   //push dword[ebp + cmd.param * 4]
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte(8BH); // mov reg1, dword[ebp + n]
                OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
                OutIntByte(n)
            END

        |CODE.opLOAD32:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                REG.UnOp(R, reg1);
                OutByte(0FFH); OutByte(30H + reg1); // push dword[reg1]
                reg1 := REG.Drop(R);
                cmd := next
            ELSE
                REG.UnOp(R, reg1);
                OutByte(8BH); OutByte(reg1 * 9) // mov reg1, dword[reg1]
            END

        |CODE.opVLOAD8:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte(8BH); // mov reg1, dword[ebp + n]
            OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
            OutIntByte(n);
            OutByte(0FH); OutByte(0B6H); OutByte(reg1 * 9) // movzx reg1, byte[reg1]

        |CODE.opGLOAD8:
            reg1 := REG.GetAnyReg(R);
            //movzx reg1,byte[_bss+cmd.param]
            BIN.PutCode(program, 00FH);
            BIN.PutCode(program, 0B6H);
            BIN.PutCode(program,  05H + reg1 * 8);
            BIN.PutReloc(program, 3);
            BIN.PutCode32LE(program, cmd.param)

        |CODE.opLLOAD8:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte(0FH);
            OutByte(0B6H); // movzx reg1, byte[ebp + n]
            OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
            OutIntByte(n)

        |CODE.opLOAD8:
            REG.UnOp(R, reg1);
            OutByte(0FH); OutByte(0B6H); OutByte(reg1 * 9) // movzx reg1, byte[reg1]

        |CODE.opVLOAD16:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte(8BH); // mov reg1, dword[ebp + n]
            OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
            OutIntByte(n);
            OutByte(0FH); OutByte(0B7H); OutByte(reg1 * 9) // movzx reg1, word[reg1]

        |CODE.opGLOAD16:
            reg1 := REG.GetAnyReg(R);
            //movzx reg1,word[_bss+cmd.param]
            BIN.PutCode(program, 00FH);
            BIN.PutCode(program, 0B7H);
            BIN.PutCode(program,  05H + reg1 * 8);
            BIN.PutReloc(program, 3);
            BIN.PutCode32LE(program, cmd.param)

        |CODE.opLLOAD16:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte(0FH);
            OutByte(0B7H); // movzx reg1, word[ebp + n]
            OutByte(45H + reg1 * 8 + 40H * ORD(~isByte(n)));
            OutIntByte(n)

        |CODE.opLOAD16:
            REG.UnOp(R, reg1);
            OutByte(0FH); OutByte(0B7H); OutByte(reg1 * 9) // movzx reg1, word[reg1]

        |CODE.opUMINUS:
            REG.UnOp(R, reg1);
            neg(reg1)

        |CODE.opADD:
            REG.BinOp(R, reg1, reg2);
            add(reg1, reg2);
            reg1 := REG.Drop(R)

        |CODE.opADDL, CODE.opADDR:
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opLOAD32 THEN
                next2 := next.next(COMMAND);
                REG.UnOp(R, reg1);
                n := cmd.param;

                IF (next2.opcode = CODE.opPARAM) & (next2.param = 1) THEN
                    OutByte(0FFH); // push dword[reg1 + n]
                    OutByte(70H + reg1 + 40H * ORD(~isByte(n)));
                    OutIntByte(n);
                    reg1 := REG.Drop(R);
                    cmd := next2
                ELSE
                    OutByte(8BH); // mov reg1, dword[reg1 + n]
                    OutByte(40H + reg1 * 9 + 40H * ORD(~isByte(n)));
                    OutIntByte(n);
                    cmd := next
                END

            ELSIF next.opcode = CODE.opLOAD8 THEN
                REG.UnOp(R, reg1);
                n := cmd.param;
                OutByte(0FH);
                OutByte(0B6H); // movzx reg1, byte[reg1 + n]
                OutByte(40H + reg1 * 9 + 40H * ORD(~isByte(n)));
                OutIntByte(n);
                cmd := next
            ELSE
                IF cmd.param # 0 THEN
                    REG.UnOp(R, reg1);
                    IF cmd.param = 1 THEN
                        OutByte(40H + reg1) // inc reg1
                    ELSIF cmd.param = -1 THEN
                        OutByte(48H + reg1) // dec reg1
                    ELSE
                        addrc(reg1, cmd.param)
                    END
                END
            END

        |CODE.opSUB:
            REG.BinOp(R, reg1, reg2);
            OutByte(29H); OutByte(0C0H + reg2 * 8 + reg1); // sub reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opSUBR, CODE.opSUBL:
            REG.UnOp(R, reg1);
            n := cmd.param;
            IF n = 1 THEN
                OutByte(48H + reg1) // dec reg1
            ELSIF n = -1 THEN
                OutByte(40H + reg1) // inc reg1
            ELSIF n # 0 THEN
                OutByte(81H + 2 * ORD(isByte(n))); // sub reg, n
                OutByte(0E8H + reg1);
                OutIntByte(n)
            END;
            IF cmd.opcode = CODE.opSUBL THEN
                neg(reg1)
            END

        |CODE.opMULC:
            REG.UnOp(R, reg1);

            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                neg(reg1)
            ELSIF a = 0 THEN
                OutByte(31H); OutByte(0C0H + reg1 * 9) // xor reg1, reg1
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        neg(reg1)
                    END;

                    IF n # 1 THEN
                        OutByte(0C1H); OutByte(0E0H + reg1); OutByte(n)   // shl reg1, n
                    ELSE
                        OutByte(0D1H); OutByte(0E0H + reg1)               // shl reg1, 1
                    END
                ELSE
                    OutByte(69H + 2 * ORD(isByte(a))); OutByte(0C0H + reg1 * 9); // imul reg1, a
                    OutIntByte(a)
                END
            END

        |CODE.opMUL:
            REG.BinOp(R, reg1, reg2);
            OutByte(0FH); OutByte(0AFH); OutByte(0C0H + reg1 * 8 + reg2); //imul reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opSAVE, CODE.opSAVE32:
            REG.BinOp(R, reg1, reg2);
            OutByte(89H); OutByte(reg2 * 8 + reg1); // mov dword[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opSAVE8:
            REG.BinOp(R, reg1, reg2);
            OutByte(88H); OutByte(reg2 * 8 + reg1); // mov byte[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opSAVE16:
            REG.BinOp(R, reg1, reg2);
            OutByte(66H); OutByte(89H); OutByte(reg2 * 8 + reg1); // mov word[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opSAVEP:
            REG.UnOp(R, reg1);
            //mov dword[reg1],L
            BIN.PutCode(program, 0C7H);
            BIN.PutCode(program,  reg1);
            BIN.PutReloc(program, 5);
            BIN.PutCode32LE(program, program.labels[cmd.param]);

            reg1 := REG.Drop(R)

        |CODE.opSAVEIP:
            REG.UnOp(R, reg1);
            //push dword[L]
            BIN.PutCode(program, 0FFH);
            BIN.PutCode(program, 035H);
            BIN.PutReloc(program, 2);
            BIN.PutCode32LE(program, cmd.param);

            OutByte(8FH); OutByte(reg1); // pop dword[reg1]
            reg1 := REG.Drop(R)

        |CODE.opPUSHP:
            reg1 := REG.GetAnyReg(R);
            //mov reg1,L
            BIN.PutCode(program, 0B8H + reg1);
            BIN.PutReloc(program, 5);
            BIN.PutCode32LE(program, program.labels[cmd.param])

        |CODE.opPUSHIP:
            reg1 := REG.GetAnyReg(R);
            //mov reg1,[L]
            BIN.PutCode(program, 8BH);
            BIN.PutCode(program, 05H + reg1 * 8);
            BIN.PutReloc(program, 2);
            BIN.PutCode32LE(program, cmd.param)

        |CODE.opNOT:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(sete, reg1);
            andrc(reg1, 1)

        |CODE.opORD:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(setne, reg1);
            andrc(reg1, 1)

        |CODE.opSBOOL:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(setne, reg1);
            REG.BinOp(R, reg1, reg2);
            OutByte(88H); OutByte(reg2 * 8 + reg1); // mov byte[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opSBOOLC:
            REG.UnOp(R, reg1);
            OutByte(0C6H);
            OutByte(reg1);
            OutByte(ORD(cmd.param # 0)); // mov byte[reg1], 0/1
            reg1 := REG.Drop(R)

        |CODE.opODD:
            REG.UnOp(R, reg1);
            andrc(reg1, 1)

        |CODE.opGTR, CODE.opLTL, CODE.opGER, CODE.opLEL,
         CODE.opLER, CODE.opGEL, CODE.opLTR, CODE.opGTL,
         CODE.opEQR, CODE.opEQL, CODE.opNER, CODE.opNEL:
            REG.UnOp(R, reg1);
            IF cmd.param = 0 THEN
                test(reg1)
            ELSE
                cmprc(reg1, cmd.param)
            END;
            reg1 := REG.Drop(R);

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jg,  label)
                |CODE.opGER, CODE.opLEL: jcc(jge, label)
                |CODE.opLER, CODE.opGEL: jcc(jle, label)
                |CODE.opLTR, CODE.opGTL: jcc(jl,  label)
                |CODE.opEQR, CODE.opEQL: jcc(je,  label)
                |CODE.opNER, CODE.opNEL: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jle, label)
                |CODE.opGER, CODE.opLEL: jcc(jl,  label)
                |CODE.opLER, CODE.opGEL: jcc(jg,  label)
                |CODE.opLTR, CODE.opGTL: jcc(jge, label)
                |CODE.opEQR, CODE.opEQL: jcc(jne, label)
                |CODE.opNER, CODE.opNEL: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: setcc(setg,  reg1)
                |CODE.opGER, CODE.opLEL: setcc(setge, reg1)
                |CODE.opLER, CODE.opGEL: setcc(setle, reg1)
                |CODE.opLTR, CODE.opGTL: setcc(setl,  reg1)
                |CODE.opEQR, CODE.opEQL: setcc(sete,  reg1)
                |CODE.opNER, CODE.opNEL: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END;

        |CODE.opGT, CODE.opGE, CODE.opLT,
         CODE.opLE, CODE.opEQ, CODE.opNE:
            REG.BinOp(R, reg1, reg2);
            cmprr(reg1, reg2);
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R);

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jg,  label)
                |CODE.opGE: jcc(jge, label)
                |CODE.opLE: jcc(jle, label)
                |CODE.opLT: jcc(jl,  label)
                |CODE.opEQ: jcc(je,  label)
                |CODE.opNE: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jle, label)
                |CODE.opGE: jcc(jl,  label)
                |CODE.opLE: jcc(jg,  label)
                |CODE.opLT: jcc(jge, label)
                |CODE.opEQ: jcc(jne, label)
                |CODE.opNE: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGT: setcc(setg,  reg1)
                |CODE.opGE: setcc(setge, reg1)
                |CODE.opLE: setcc(setle, reg1)
                |CODE.opLT: setcc(setl,  reg1)
                |CODE.opEQ: setcc(sete,  reg1)
                |CODE.opNE: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END

        |CODE.opEQB, CODE.opNEB:
            REG.BinOp(R, reg1, reg2);
            reg2 := REG.Drop(R);
            reg1 := REG.Drop(R);

            test(reg1);
            OutByte(74H); OutByte(5);  // je @f
            movrc(reg1, 1);            // mov reg1, 1
                                       // @@:
            test(reg2);
            OutByte(74H); OutByte(5);  // je @f
            movrc(reg2, 1);            // mov reg2, 1
                                       // @@:

            cmprr(reg1, reg2);
            reg1 := REG.GetAnyReg(R);
            IF cmd.opcode = CODE.opEQB THEN
                setcc(sete, reg1)
            ELSE
                setcc(setne, reg1)
            END;
            andrc(reg1, 1)

        |CODE.opACC:
            IF (R.top # 0) OR (R.stk[0] # eax) THEN
                REG.PushAll(R);
                ASSERT(REG.GetReg(R, eax));
                _pop(eax);
                DEC(R.pushed)
            END

        |CODE.opDROP:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R)

        |CODE.opJE, CODE.opJNE:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            test(reg1);
            IF cmd.opcode = CODE.opJE THEN
                jcc(jne, cmd.label)
            ELSE
                jcc(je, cmd.label)
            END

        |CODE.opJNZ:
            REG.UnOp(R, reg1);
            test(reg1);
            jcc(jne, cmd.label)

        |CODE.opJZ:
            REG.UnOp(R, reg1);
            test(reg1);
            jcc(je, cmd.label)

        |CODE.opSWITCH:
            REG.UnOp(R, reg1);
            IF reg1 # eax THEN
                ASSERT(REG.GetReg(R, eax));
                ASSERT(REG.Exchange(R, reg1, eax));
                reg1 := REG.Drop(R)
            END;
            reg1 := REG.Drop(R)

        |CODE.opENDSW:

        |CODE.opCASE1:
            cmprc(eax, cmd.param);
            jcc(je, cmd.label)

        |CODE.opCASE:
            label := CODE.NewLabel();
            cmprc(eax, cmd.param);
            jcc(jl, label);
            cmprc(eax, cmd.param2);
            jcc(jle, cmd.label);
            BIN.SetLabel(program, label)

        |CODE.opCODE:
            OutByte(Byte(cmd.param))

        |CODE.opGET:
            REG.BinOp(R, reg1, reg2);

            CASE cmd.param OF
            |1:
                OutByte(8AH); OutByte(reg1 * 9); // mov reg1, byte[reg1]
                OutByte(88H); OutByte(reg1 * 8 + reg2) // mov byte[reg2], reg1

            |2:
                OutByte(66H); OutByte(8BH); OutByte(reg1 * 9); // mov reg1, word[reg1]
                OutByte(66H); OutByte(89H); OutByte(reg1 * 8 + reg2) // mov word[reg2], reg1

            |4:
                OutByte(8BH); OutByte(reg1 * 9);        // mov reg1, dword[reg1]
                OutByte(89H); OutByte(reg1 * 8 + reg2) // mov dword[reg2], reg1

            |8:
                reg2 := REG.Drop(R);
                reg1 := REG.Drop(R);
                REG.PushAll(R);
                _push(reg2);
                _push(reg1);
                pushc(8);
                CallRTL(CODE._move)

            END;

            IF cmd.param # 8 THEN
                reg1 := REG.Drop(R);
                reg1 := REG.Drop(R)
            END

        |CODE.opSAVES:
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            REG.PushAll(R);
            _push(reg1);
            //push _data + stroffs + cmd.param
            BIN.PutCode(program, 068H);
            BIN.PutReloc(program, 4);
            BIN.PutCode32LE(program, stroffs + cmd.param);

            pushc(cmd.param2);
            CallRTL(CODE._move)

        |CODE.opCHKIDX:
            REG.UnOp(R, reg1);
            cmprc(reg1, cmd.param);
            jcc(jb, cmd.label)

        |CODE.opCHKIDX2:
            REG.BinOp(R, reg1, reg2);
            cmprr(reg2, reg1);
            _mov(reg1, reg2);
            reg1 := REG.Drop(R);
            jcc(jb, cmd.label)

        |CODE.opLEN:
            n := cmd.param;
            REG.UnOp(R, reg1);
            reg1 := REG.Drop(R);
            R.regs := R.regs - {reg1};

            WHILE n > 0 DO
                REG.UnOp(R, reg2);
                reg2 := REG.Drop(R);
                DEC(n)
            END;

            R.regs := R.regs + {reg1};
            ASSERT(REG.GetReg(R, reg1));

        |CODE.opINC1:
            REG.UnOp(R, reg1);
            OutByte(0FFH); OutByte(reg1); // inc dword[reg1]
            reg1 := REG.Drop(R)

        |CODE.opDEC1:
            REG.UnOp(R, reg1);
            OutByte(0FFH); OutByte(8 + reg1); // dec dword[reg1]
            reg1 := REG.Drop(R)

        |CODE.opINCC:
            REG.UnOp(R, reg1);
            n := cmd.param;
            OutByte(81H + 2 * ORD(isByte(n))); OutByte(reg1); OutIntByte(n); //add dword[reg1], n
            reg1 := REG.Drop(R)

        |CODE.opDECC:
            REG.UnOp(R, reg1);
            n := cmd.param;
            OutByte(81H + 2 * ORD(isByte(n))); OutByte(28H + reg1); OutIntByte(n); //sub dword[reg1], n
            reg1 := REG.Drop(R)

        |CODE.opINC:
            REG.BinOp(R, reg1, reg2);
            OutByte(01H); OutByte(reg2 * 8 + reg1); // add dword[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opDEC:
            REG.BinOp(R, reg1, reg2);
            OutByte(29H); OutByte(reg2 * 8 + reg1); // sub dword[reg1], reg2
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opINC1B:
            REG.UnOp(R, reg1);
            OutByte(0FEH); OutByte(reg1); // inc byte[reg1]
            reg1 := REG.Drop(R)

        |CODE.opDEC1B:
            REG.UnOp(R, reg1);
            OutByte(0FEH); OutByte(08H + reg1); // dec byte[reg1]
            reg1 := REG.Drop(R)

        |CODE.opINCCB:
            REG.UnOp(R, reg1);
            OutByte(80H); OutByte(reg1); OutByte(Byte(cmd.param)); //add byte[reg1], n
            reg1 := REG.Drop(R)

        |CODE.opDECCB:
            REG.UnOp(R, reg1);
            OutByte(80H); OutByte(28H + reg1); OutByte(Byte(cmd.param)); //sub byte[reg1], n
            reg1 := REG.Drop(R)

        |CODE.opINCB, CODE.opDECB:
            REG.BinOp(R, reg1, reg2);

            IF cmd.opcode = CODE.opINCB THEN
                OutByte(0H); OutByte(reg2 * 8 + reg1) // add byte[reg1], reg2
            ELSE
                OutByte(28H); OutByte(reg2 * 8 + reg1) // sub byte[reg1], reg2
            END;

            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R)

        |CODE.opMULS:
            REG.BinOp(R, reg1, reg2);
            OutByte(21H); OutByte(0C0H + reg2 * 8 + reg1); // and reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opMULSC:
            REG.UnOp(R, reg1);
            andrc(reg1, cmd.param)

        |CODE.opDIVS:
            REG.BinOp(R, reg1, reg2);
            OutByte(31H); OutByte(0C0H + reg2 * 8 + reg1); // xor reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opDIVSC:
            n := cmd.param;
            REG.UnOp(R, reg1);
            OutByte(81H + 2 * ORD(isByte(n))); OutByte(0F0H + reg1);  // or reg1, n
            OutIntByte(n)

        |CODE.opADDS:
            REG.BinOp(R, reg1, reg2);
            OutByte(9H); OutByte(0C0H + reg2 * 8 + reg1); // or reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opSUBS:
            REG.BinOp(R, reg1, reg2);
            not(reg2);
            OutByte(21H); OutByte(0C0H + reg2 * 8 + reg1); // and reg1, reg2
            reg1 := REG.Drop(R)

        |CODE.opADDSL, CODE.opADDSR:
            n := cmd.param;
            REG.UnOp(R, reg1);
            OutByte(81H + 2 * ORD(isByte(n))); OutByte(0C8H + reg1);  // or reg1, n
            OutIntByte(n)

        |CODE.opSUBSL:
            REG.UnOp(R, reg1);
            not(reg1);
            andrc(reg1, cmd.param)

        |CODE.opSUBSR:
            REG.UnOp(R, reg1);
            andrc(reg1, ORD(-BITS(cmd.param)));

        |CODE.opUMINS:
            REG.UnOp(R, reg1);
            not(reg1)

        |CODE.opLENGTH:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._length);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opLENGTHW:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._lengthw);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCHR:
            REG.UnOp(R, reg1);
            andrc(reg1, 255)

        |CODE.opWCHR:
            REG.UnOp(R, reg1);
            andrc(reg1, 65535)

        |CODE.opASR, CODE.opROR, CODE.opLSL, CODE.opLSR:
            REG.UnOp(R, reg1);
            IF reg1 # ecx THEN
                ASSERT(REG.GetReg(R, ecx));
                ASSERT(REG.Exchange(R, reg1, ecx));
                reg1 := REG.Drop(R)
            END;

            REG.BinOp(R, reg1, reg2);
            ASSERT(reg2 = ecx);
            OutByte(0D3H);
            CASE cmd.opcode OF
            |CODE.opASR: OutByte(0F8H + reg1)  // sar reg1, cl
            |CODE.opROR: OutByte(0C8H + reg1)  // ror reg1, cl
            |CODE.opLSL: OutByte(0E0H + reg1)  // shl reg1, cl
            |CODE.opLSR: OutByte(0E8H + reg1)  // shr reg1, cl
            END;
            reg1 := REG.Drop(R)

        |CODE.opASR1, CODE.opROR1, CODE.opLSL1, CODE.opLSR1:
            REG.UnOp(R, reg1);
            IF reg1 # ecx THEN
                ASSERT(REG.GetReg(R, ecx));
                ASSERT(REG.Exchange(R, reg1, ecx));
                reg1 := REG.Drop(R)
            END;

            reg1 := REG.GetAnyReg(R);

            movrc(reg1, cmd.param);

            REG.BinOp(R, reg1, reg2);
            ASSERT(reg1 = ecx);
            OutByte(0D3H);
            CASE cmd.opcode OF
            |CODE.opASR1: OutByte(0F8H + reg2)  // sar reg2, cl
            |CODE.opROR1: OutByte(0C8H + reg2)  // ror reg2, cl
            |CODE.opLSL1: OutByte(0E0H + reg2)  // shl reg2, cl
            |CODE.opLSR1: OutByte(0E8H + reg2)  // shr reg2, cl
            END;
            reg1 := REG.Drop(R);
            reg1 := REG.Drop(R);
            ASSERT(REG.GetReg(R, reg2))

        |CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
            REG.UnOp(R, reg1);
            n := ORD(BITS(cmd.param) * {0..4});
            IF n # 1 THEN
                OutByte(0C1H)
            ELSE
                OutByte(0D1H)
            END;

            CASE cmd.opcode OF
            |CODE.opASR2: OutByte(0F8H + reg1) // sar reg1, n
            |CODE.opROR2: OutByte(0C8H + reg1) // ror reg1, n
            |CODE.opLSL2: OutByte(0E0H + reg1) // shl reg1, n
            |CODE.opLSR2: OutByte(0E8H + reg1) // shr reg1, n
            END;

            IF n # 1 THEN
                OutByte(n)
            END

        |CODE.opMIN:
            REG.BinOp(R, reg1, reg2);
            cmprr(reg1, reg2);
            OutCode("7E02");  // jle @f
            _mov(reg1, reg2); // mov reg1, reg2
                              // @@:
            reg2 := REG.Drop(R)

        |CODE.opMAX:
            REG.BinOp(R, reg1, reg2);
            cmprr(reg1, reg2);
            OutCode("7D02");  // jge @f
            _mov(reg1, reg2); // mov reg1, reg2
                              // @@:
            reg2 := REG.Drop(R)

        |CODE.opMINC:
            REG.UnOp(R, reg1);
            cmprc(reg1, cmd.param);
            OutCode("7E05");         // jle @f
            movrc(reg1, cmd.param);  // mov reg1, cmd.param
                                     // @@:

        |CODE.opMAXC:
            REG.UnOp(R, reg1);
            cmprc(reg1, cmd.param);
            OutCode("7D05");         // jge @f
            movrc(reg1, cmd.param);  // mov reg1, cmd.param
                                     // @@:

        |CODE.opIN:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._in);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINR:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._in);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINL:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._in2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSET:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSETR:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSETL:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._set2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSET1:
            REG.UnOp(R, reg1);
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            _push(reg1);
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINCL:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._incl)

        |CODE.opEXCL:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._excl)

        |CODE.opINCLC:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._incl)

        |CODE.opEXCLC:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._excl)

        |CODE.opDIV:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._div);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opDIVR:
            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                REG.UnOp(R, reg1);
                neg(reg1)
            ELSE
                IF n > 0 THEN
                    REG.UnOp(R, reg1);

                    IF a < 0 THEN
                        reg2 := REG.GetAnyReg(R);
                        _mov(reg2, reg1);
                        IF n # 1 THEN
                            OutByte(0C1H); OutByte(0F8H + reg1); OutByte(n)   // sar reg1, n
                        ELSE
                            OutByte(0D1H); OutByte(0F8H + reg1)               // sar reg1, 1
                        END;
                        OutByte(29H); OutByte(0C0H + reg2 * 8 + reg1); // sub reg1, reg2
                        reg2 := REG.Drop(R)
                    ELSE
                        IF n # 1 THEN
                            OutByte(0C1H); OutByte(0F8H + reg1); OutByte(n)   // sar reg1, n
                        ELSE
                            OutByte(0D1H); OutByte(0F8H + reg1)               // sar reg1, 1
                        END
                    END

                ELSE
                    REG.PushAll(R);
                    R.pushed := R.pushed - 1;
                    pushc(cmd.param);
                    CallRTL(CODE._div);
                    ASSERT(REG.GetReg(R, eax))
                END
            END

        |CODE.opDIVL:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._div2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opMOD:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            CallRTL(CODE._mod);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opMODR:
            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF ABS(a) = 1 THEN
                REG.UnOp(R, reg1);
                OutByte(31H); OutByte(0C0H + reg1 * 9) // xor reg1, reg1
            ELSE
                IF n > 0 THEN
                    REG.UnOp(R, reg1);
                    andrc(reg1, ABS(a) - 1);

                    IF a < 0 THEN
                        test(reg1);
                        OutByte(74H);      // je @f
                        IF isByte(a) THEN
                            OutByte(3)
                        ELSE
                            OutByte(6)
                        END;
                        addrc(reg1, a)
                                           // @@:
                    END

                ELSE
                    REG.PushAll(R);
                    R.pushed := R.pushed - 1;
                    pushc(cmd.param);
                    CallRTL(CODE._mod);
                    ASSERT(REG.GetReg(R, eax))
                END
            END

        |CODE.opMODL:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._mod2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opERR:
            CallRTL(CODE._error)

        |CODE.opABS:
            REG.UnOp(R, reg1);
            test(reg1);
            OutCode("7D02"); // jge @f
            neg(reg1);       // neg reg1
                             // @@:

        |CODE.opCOPY:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            pushc(cmd.param);
            CallRTL(CODE._move)

        |CODE.opMOVE:
            REG.PushAll(R);
            R.pushed := R.pushed - 3;
            CallRTL(CODE._move2)

        |CODE.opCOPYA:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            pushc(cmd.param);
            CallRTL(CODE._arrcpy);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCOPYS:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            pushc(cmd.param);
            CallRTL(CODE._strcpy)

        |CODE.opCOPYS2:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            pushc(cmd.param);
            CallRTL(CODE._strcpy2)

        |CODE.opROT:
            REG.PushAll(R);
            OutByte(54H);  // push esp
            pushc(cmd.param);
            CallRTL(CODE._rot)

        |CODE.opNEW:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            n := cmd.param + 8;
            ASSERT(UTILS.align(n, 32));
            pushc(n);
            pushc(cmd.param2);
            CallRTL(CODE._new)

        |CODE.opDISP:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            CallRTL(CODE._dispose)

        |CODE.opEQS, CODE.opNES, CODE.opLTS,
         CODE.opLES, CODE.opGTS, CODE.opGES:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            CASE cmd.opcode OF
            |CODE.opEQS: pushc(0)
            |CODE.opNES: pushc(1)
            |CODE.opLTS: pushc(2)
            |CODE.opLES: pushc(3)
            |CODE.opGTS: pushc(4)
            |CODE.opGES: pushc(5)
            END;
            CallRTL(CODE._strcmp);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQS2, CODE.opNES2, CODE.opLTS2,
         CODE.opLES2, CODE.opGTS2, CODE.opGES2:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            CASE cmd.opcode OF
            |CODE.opEQS2: pushc(0)
            |CODE.opNES2: pushc(1)
            |CODE.opLTS2: pushc(2)
            |CODE.opLES2: pushc(3)
            |CODE.opGTS2: pushc(4)
            |CODE.opGES2: pushc(5)
            END;
            CallRTL(CODE._strcmp2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQSW, CODE.opNESW, CODE.opLTSW,
         CODE.opLESW, CODE.opGTSW, CODE.opGESW:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            CASE cmd.opcode OF
            |CODE.opEQSW: pushc(0)
            |CODE.opNESW: pushc(1)
            |CODE.opLTSW: pushc(2)
            |CODE.opLESW: pushc(3)
            |CODE.opGTSW: pushc(4)
            |CODE.opGESW: pushc(5)
            END;
            CallRTL(CODE._strcmpw);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQSW2, CODE.opNESW2, CODE.opLTSW2,
         CODE.opLESW2, CODE.opGTSW2, CODE.opGESW2:
            REG.PushAll(R);
            R.pushed := R.pushed - 4;
            CASE cmd.opcode OF
            |CODE.opEQSW2: pushc(0)
            |CODE.opNESW2: pushc(1)
            |CODE.opLTSW2: pushc(2)
            |CODE.opLESW2: pushc(3)
            |CODE.opGTSW2: pushc(4)
            |CODE.opGESW2: pushc(5)
            END;
            CallRTL(CODE._strcmpw2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQP, CODE.opNEP, CODE.opEQIP, CODE.opNEIP:
            REG.UnOp(R, reg1);
            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opNEP:
                //cmp reg1,L
                BIN.PutCode(program, 081H);
                BIN.PutCode(program, 0F8H + reg1);
                BIN.PutReloc(program, 5);
                BIN.PutCode32LE(program, program.labels[cmd.label])

            |CODE.opEQIP, CODE.opNEIP:
                //cmp reg1,dword[L]
                BIN.PutCode(program, 3BH);
                BIN.PutCode(program, 05H + reg1 * 8);
                BIN.PutReloc(program, 2);
                BIN.PutCode32LE(program, cmd.label)

            END;
            reg1 := REG.Drop(R);
            reg1 := REG.GetAnyReg(R);

            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opEQIP: setcc(sete,  reg1)
            |CODE.opNEP, CODE.opNEIP: setcc(setne, reg1)
            END;

            andrc(reg1, 1)

        |CODE.opPUSHT:
            REG.UnOp(R, reg1);
            reg2 := REG.GetAnyReg(R);
            OutByte(8BH); OutByte(40H + reg2 * 8 + reg1); OutByte(0FCH);

        |CODE.opISREC:
            REG.PushAll(R);
            R.pushed := R.pushed - 2;
            pushc(cmd.param);
            CallRTL(CODE._isrec);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opTYPEGR:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._guardrec);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opIS:
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._is);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opTYPEG:
            REG.UnOp(R, reg2);
            reg1 := REG.GetAnyReg(R);
            _mov(reg1, reg2);
            REG.PushAll(R);
            R.pushed := R.pushed - 1;
            pushc(cmd.param);
            CallRTL(CODE._guard);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCASET:
            _push(eax);
            _push(eax);
            pushc(cmd.param);
            CallRTL(CODE._guardrec);
            _mov(ecx, eax);
            _pop(eax);
            test(ecx);
            jcc(jne, cmd.label)

        |CODE.opPACK:
            REG.BinOp(R, reg1, reg2);
            _push(reg2);
            OutCode("DB0424"); // fild dword[esp]
            OutByte(0DDH); OutByte(reg1); // fld qword[reg1]
            OutCode("D9FD");   // fscale
            OutByte(0DDH); OutByte(018H + reg1); // fstp qword[reg1]
            OutCode("DB1C24"); // fistp dword[esp]
            _pop(reg2);
            reg1 := REG.Drop(R);
            reg2 := REG.Drop(R)

        |CODE.opPACKC:
            REG.UnOp(R, reg1);
            pushc(cmd.param);
            OutCode("DB0424"); // fild dword[esp]
            OutByte(0DDH); OutByte(reg1); // fld qword[reg1]
            OutCode("D9FD");   // fscale
            OutByte(0DDH); OutByte(018H + reg1); // fstp qword[reg1]
            OutCode("DB1C24"); // fistp dword[esp]
            _pop(reg1);
            reg1 := REG.Drop(R)

        |CODE.opUNPK:
            REG.BinOp(R, reg1, reg2);
            OutByte(0DDH); OutByte(reg1); // fld qword[reg1]
            OutCode("D9F4");   // fxtract
            OutByte(0DDH); OutByte(018H + reg1); // fstp qword[reg1]
            OutByte(0DBH); OutByte(018H + reg2); // fistp dword[reg2]
            reg1 := REG.Drop(R);
            reg2 := REG.Drop(R)

        |CODE.opPUSHF:
            OutCode("83EC08");  // sub esp,8
            OutCode("DD1C24")   // fstp qword[esp]

        |CODE.opLOADF:
            REG.UnOp(R, reg1);
            OutByte(0DDH); OutByte(reg1); // fld qword[reg1]
            reg1 := REG.Drop(R)

        |CODE.opCONSTF:
            IF cmd.float = 0.0 THEN
                OutCode("D9EE"); // fldz
            ELSIF cmd.float = 1.0 THEN
                OutCode("D9E8"); // fld1
            ELSIF cmd.float = -1.0 THEN
                OutCode("D9E8"); // fld1
                OutCode("D9E0")  // fchs
            ELSE
                UTILS.splitf(cmd.float, a, b);
                pushc(b);
                pushc(a);
                OutCode("DD0424"); // fld qword[esp]
                OutCode("83C408")  // add esp,8
            END

        |CODE.opSAVEF:
            REG.UnOp(R, reg1);
            OutByte(0DDH); OutByte(018H + reg1); // fstp qword[reg1]
            reg1 := REG.Drop(R)

        |CODE.opADDF, CODE.opADDFI:
            OutCode("DEC1")  // faddp st1, st

        |CODE.opSUBF:
            OutCode("DEE9")  // fsubp st1, st

        |CODE.opSUBFI:
            OutCode("DEE1")  // fsubrp st1, st

        |CODE.opMULF:
            OutCode("DEC9")  // fmulp st1, st

        |CODE.opDIVF:
            OutCode("DEF9")  // fdivp st1, st

        |CODE.opDIVFI:
            OutCode("DEF1")  // fdivrp st1, st

        |CODE.opUMINF:
            OutCode("D9E0")  // fchs

        |CODE.opFABS:
            OutCode("D9E1")  // fabs

        |CODE.opFLT:
            REG.UnOp(R, reg1);
            _push(reg1);
            OutCode("DB0424"); // fild dword[esp]
            _pop(reg1);
            reg1 := REG.Drop(R)

        |CODE.opFLOOR:
            reg1 := REG.GetAnyReg(R);
            OutCode("83EC089BD97C24049BD97C24066681642404FFF366814C24040004D96C2404D9FCDB1C24");
            (*
                sub esp,8
                fstcw word[esp+4]
                fstcw word[esp+6]
                and word[esp+4],1111001111111111b
                or word[esp+4],0000010000000000b
                fldcw word[esp+4]
                frndint
                fistp dword[esp]
                *)
            _pop(reg1);
            OutCode("D96C240283C404")
            (*
                fldcw word[esp+2]
                add esp,4
                *)

        |CODE.opEQF, CODE.opEQFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A060F94C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setz al
                and eax,1
                L:
                *)

        |CODE.opNEF, CODE.opNEFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A060F95C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setnz al
                and eax,1
                L:
                *)

        |CODE.opLTF, CODE.opGTFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A0E0F92C00F94C485C00F94C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setc al
                setz ah
                test eax,eax
                setz al
                and eax,1
                L:
                *)

        |CODE.opGTF, CODE.opLTFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A0F0F92C00F94C483F8010F94C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setc al
                setz ah
                cmp eax,1
                sete al
                and eax,1
                L:
                *)

        |CODE.opLEF, CODE.opGEFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A060F93C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setnc al
                and eax,1
                L:
                *)

        |CODE.opGEF, CODE.opLEFI:
            ASSERT(REG.GetReg(R, eax));
            OutCode("DAE99BDFE09EB8000000007A100F92C00F94C400E03C010F94C083E001")
            (*
                fucompp
                fstsw ax
                sahf
                mov eax,0
                jp L
                setc al
                setz ah
                add al,ah
                cmp al,1
                sete al
                and eax,1
                L:
                *)

        |CODE.opINF:
            pushc(2146435072);
            pushc(0);
            OutCode("DD0424"); //fld qword[esp]
            OutCode("83C408"); //add esp, 8

        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)

END translate;


PROCEDURE prolog (code: CODE.CODES; target, stack: INTEGER);
BEGIN

    IF target = UTILS.tarDLL THEN   (*
        WriteLn("format PE GUI 4.0 DLL");
        WriteLn("entry DllEntryPoint");
        WriteLn("section '.text' code readable executable");
        WriteLn("DllEntryPoint:");   *)
        dllinit := CODE.NewLabel();
        BIN.SetLabel(program, dllinit);
        OutByte(55H); // push ebp
        OutByte(89H); OutByte(0E5H); // mov ebp,esp
        OutByte(0FFH); OutByte(75H); OutByte(16); // push dword[ebp+16]
        OutByte(0FFH); OutByte(75H); OutByte(12); // push dword[ebp+12]
        OutByte(0FFH); OutByte(75H); OutByte(8);  // push dword[ebp+8]
        CallRTL(CODE._dllentry);
        test(eax);
        jcc(je, dllret)

    ELSIF target = UTILS.tarOBJ THEN
    (*    WriteLn("format MS COFF");
        WriteLn("public EXPORTS");
        WriteLn("section '.flat' code readable align 16");
        WriteLn("lib_init:");*)
        dllinit := CODE.NewLabel();
        BIN.SetLabel(program, dllinit)
    END;

    OutCode("9BDBE3"); // finit

    IF target IN {UTILS.tarKOS, UTILS.tarOBJ} THEN
        BIN.PutCode(program, 068H); //push IMPORT
        BIN.PutReloc(program, 6);
        BIN.PutCode32LE(program, 0)
    ELSE
        BIN.PutCode(program, 6AH);  //push 0
        BIN.PutCode(program, 00H)
    END;

    //push _data
    BIN.PutCode(program, 068H);
    BIN.PutReloc(program, 4);
    BIN.PutCode32LE(program, 0);

    pushc(code.tcount);
    //push _data + code.tcount * 4 + code.dcount
    BIN.PutCode(program, 068H);
    BIN.PutReloc(program, 4);
    BIN.PutCode32LE(program, code.tcount * 4 + code.dcount);

    CallRTL(CODE._init)
END prolog;


PROCEDURE epilog (code: CODE.CODES; modname: ARRAY OF CHAR; target, stack, ver: INTEGER);
VAR
    i, n, dllver: INTEGER;
    exp:  CODE.EXPORT_PROC;


    PROCEDURE import (imp: LISTS.LIST);
    VAR
        lib:  CODE.IMPORT_LIB;
        proc: CODE.IMPORT_PROC;

    BEGIN

        lib := imp.first(CODE.IMPORT_LIB);
        WHILE lib # NIL DO
            BIN.Import(program, lib.name, 0);
            proc := lib.procs.first(CODE.IMPORT_PROC);
            WHILE proc # NIL DO
                BIN.Import(program, proc.name, proc.label);
                proc := proc.next(CODE.IMPORT_PROC)
            END;
            lib := lib.next(CODE.IMPORT_LIB)
        END

    END import;


BEGIN

    IF target = UTILS.tarDLL THEN
        BIN.SetLabel(program, dllret);
        movrc(eax, 1);
        OutByte(0C9H); // leave
        OutCode("C20C00") // ret 12
    END;

    IF target IN {UTILS.tarCON, UTILS.tarGUI, UTILS.tarDLL} THEN
        pushc(0);
        CallRTL(CODE._exit);
    ELSIF target = UTILS.tarKOS THEN
        pushc(0);
        CallRTL(CODE._exit)
    ELSIF target = UTILS.tarOBJ THEN
        movrc(eax, 1);
        OutByte(0C3H); // ret
        dllver := CODE.NewLabel();
        BIN.SetLabel(program, dllver);
   //     Write("_dllver: ");
        OutInt(ver);
    (*    WriteLn("align 16");
        WriteLn("EXPORTS:");
        WriteLn("dd szlib_init,lib_init");
        Write("dd szVersion,"); WriteHexLn(ver);
      *)
        exp := code.export.first(CODE.EXPORT_PROC);
        WHILE exp # NIL DO
         //   Write("dd "); Write("N"); WriteHex(exp.label); Write(",L"); WriteHexLn(exp.label);
            exp := exp.next(CODE.EXPORT_PROC)
        END;

     //   WriteLn("dd 0");

        exp := code.export.first(CODE.EXPORT_PROC);
        WHILE exp # NIL DO
        //    Write("N"); WriteHex(exp.label); Write(" db '"); Write(exp.name); WriteLn("',0");
            exp := exp.next(CODE.EXPORT_PROC)
        END;

     //   WriteLn("szlib_init db 'lib_init',0");
     //   WriteLn("szVersion db 'version',0")
    END;


    i := 0;
    WHILE i < code.tcount DO
        BIN.PutData32LE(program, code.types[i]);
        INC(i)
    END;

    i := 0;
    WHILE i < code.dcount DO
        BIN.PutData(program, code.data[i]);
        INC(i)
    END;

    program.modname := program.dcount;
    BIN.PutDataStr(program, modname);
    BIN.PutData(program, 0);

    program.export := program.dcount;
    IF target = UTILS.tarOBJ THEN
        BIN.Export(program, "lib_init", dllinit);
        BIN.Export(program, "version",  dllver);
    END;

    exp := code.export.first(CODE.EXPORT_PROC);
    WHILE exp # NIL DO
        BIN.Export(program, exp.name, exp.label);
        exp := exp.next(CODE.EXPORT_PROC)
    END;

    program.exp_list.delete(program.exp_list, program.exp_list.first);

    program.import := program.dcount;
    import(code.import);

    n := code.dmin - code.dcount;
    IF n > 0 THEN
        INC(code.gsize, n)
    END;
                           (*
    IF target = UTILS.tarKOS THEN
        WriteLn("align 16")
    ELSE
        WriteLn("section '.bss' data readable writeable")
    END;

    Write("_bss: rb ");  WriteHexLn(code.gsize);  *)
    BIN.SetParams(program, code.gsize, stack * (1024 * 1024), WCHR(ver DIV 65536), WCHR(ver MOD 65536));

END epilog;


PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target, stack, ver: INTEGER);
BEGIN
    program := BIN.create();
    dllret  := CODE.NewLabel();
    label_import  := CODE.NewLabel();
    stroffs := code.tcount * 4;

    error := FALSE;

    R := REG.Create(_push, _pop, _mov, _xch);

    prolog(code, target, stack);
    translate(code);
    epilog(code, outname, target, stack, ver);

    DISPOSE(R);

    BIN.fixup(program);

    IF target IN {UTILS.tarCON, UTILS.tarGUI, UTILS.tarDLL} THEN
        PE.write(program, outname, target = UTILS.tarCON, target = UTILS.tarDLL)
    ELSIF target = UTILS.tarKOS THEN
        KOS.write(program, outname)
    END

END CodeGen;


END X86.