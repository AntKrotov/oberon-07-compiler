(*
    BSD 2-Clause License

    Copyright (c) 2018, Anton Krotov
    All rights reserved.
*)

MODULE X86;

IMPORT CODE, REG, UTILS, LISTS, BIN, PE32, KOS, TARGETS, MACHINE;


CONST

    eax = REG.R0; ecx = REG.R1; edx = REG.R2;

    al = eax; cl = ecx; dl = edx; ah = 4;

    ax = eax; cx = ecx; dx = edx;

    sete = 94H; setne = 95H; setl = 9CH; setge = 9DH; setle = 9EH; setg = 9FH; setc = 92H; setnc = 93H;

    je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H;


TYPE

    COMMAND = CODE.COMMAND;


VAR

    error:   BOOLEAN;

    R:       REG.REGS;

    stroffs: INTEGER;

    program: BIN.PROGRAM;
    dllret:  INTEGER;
    dllinit: INTEGER;
    label_import:  INTEGER;


PROCEDURE Byte (n: INTEGER): BYTE;
    RETURN MACHINE.Byte(n, 0)
END Byte;


PROCEDURE Word (n: INTEGER): INTEGER;
    RETURN MACHINE.Byte(n, 0) + MACHINE.Byte(n, 1) * 256
END Word;


PROCEDURE OutByte (n: INTEGER);
BEGIN
    ASSERT((0 <= n) & (n <= 255));
    BIN.PutCode(program, n)
END OutByte;


PROCEDURE OutByte2 (a, b: INTEGER);
BEGIN
    OutByte(a);
    OutByte(b)
END OutByte2;


PROCEDURE OutByte3 (a, b, c: INTEGER);
BEGIN
    OutByte(a);
    OutByte(b);
    OutByte(c)
END OutByte3;


PROCEDURE OutInt (n: INTEGER);
BEGIN
    BIN.PutCode32LE(program, n)
END OutInt;


PROCEDURE OutWord (n: INTEGER);
BEGIN
    ASSERT((0 <= n) & (n <= 65535));
    OutByte2(n MOD 256, n DIV 256)
END OutWord;


PROCEDURE Reloc (op, value: INTEGER);
BEGIN
    BIN.PutReloc(program, op);
    OutInt(value)
END Reloc;


PROCEDURE isByte (n: INTEGER): BOOLEAN;
    RETURN (-128 <= n) & (n <= 127)
END isByte;


PROCEDURE OutIntByte (n: INTEGER);
BEGIN
    IF isByte(n) THEN
        OutByte(Byte(n))
    ELSE
        OutInt(n)
    END
END OutIntByte;


PROCEDURE mov (reg1, reg2: INTEGER);
BEGIN
    OutByte2(89H, 0C0H + reg2 * 8 + reg1)  // mov reg1, reg2
END mov;


PROCEDURE xchg (reg1, reg2: INTEGER);
VAR
    regs: SET;

BEGIN
    regs := {reg1, reg2};
    IF regs = {eax, ecx} THEN
        OutByte(91H)                // xchg eax, ecx
    ELSIF regs = {eax, edx} THEN
        OutByte(92H)                // xchg eax, edx
    ELSIF regs = {ecx, edx} THEN
        OutByte2(87H, 0D1H)         // xchg ecx, edx
    END
END xchg;


PROCEDURE pop (reg: INTEGER);
BEGIN
    OutByte(58H + reg) // pop reg
END pop;


PROCEDURE push (reg: INTEGER);
BEGIN
    OutByte(50H + reg) // push reg
END push;


PROCEDURE movrc (reg, n: INTEGER);
BEGIN
    OutByte(0B8H + reg); // mov reg, n
    OutInt(n)
END movrc;


PROCEDURE pushc (n: INTEGER);
BEGIN
    OutByte(68H + 2 * ORD(isByte(n))); // push n
    OutIntByte(n)
END pushc;


PROCEDURE test (reg: INTEGER);
BEGIN
    OutByte2(85H, 0C0H + reg * 9)  // test reg, reg
END test;


PROCEDURE neg (reg: INTEGER);
BEGIN
    OutByte2(0F7H, 0D8H + reg)  // neg reg
END neg;


PROCEDURE not (reg: INTEGER);
BEGIN
    OutByte2(0F7H, 0D0H + reg)  // not reg
END not;


PROCEDURE add (reg1, reg2: INTEGER);
BEGIN
    OutByte2(01H, 0C0H + reg2 * 8 + reg1)  // add reg1, reg2
END add;


PROCEDURE andrc (reg, n: INTEGER);
BEGIN
    OutByte2(81H + 2 * ORD(isByte(n)), 0E0H + reg);  // and reg, n
    OutIntByte(n)
END andrc;


PROCEDURE addrc (reg, n: INTEGER);
BEGIN
    OutByte2(81H + 2 * ORD(isByte(n)), 0C0H + reg);  // add reg, n
    OutIntByte(n)
END addrc;


PROCEDURE cmprr (reg1, reg2: INTEGER);
BEGIN
    OutByte2(39H, 0C0H + reg2 * 8 + reg1)  // cmp reg1, reg2
END cmprr;


PROCEDURE cmprc (reg, n: INTEGER);
BEGIN
    OutByte2(81H + 2 * ORD(isByte(n)), 0F8H + reg);  // cmp reg, n
    OutIntByte(n)
END cmprc;


PROCEDURE setcc (cond, reg: INTEGER);
BEGIN
    OutByte3(0FH, cond, 0C0H + reg)  // setcc reg
END setcc;


PROCEDURE log2 (x: INTEGER): INTEGER;
VAR
    n: INTEGER;

BEGIN
    ASSERT(x > 0);

    n := 0;
    WHILE ~ODD(x) DO
        x := x DIV 2;
        INC(n)
    END;

    IF x # 1 THEN
        n := -1
    END

    RETURN n
END log2;


PROCEDURE jcc (opcode, label: INTEGER);
BEGIN
    OutByte2(0FH, opcode); (* je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H; *)
    Reloc(1, label)
END jcc;


PROCEDURE CallRTL (proc: INTEGER);
BEGIN
    OutByte(0E8H);    // call rtl[proc]
    Reloc(1, CODE.codes.rtl[proc])
END CallRTL;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE UnOp (VAR reg: INTEGER);
BEGIN
    REG.UnOp(R, reg)
END UnOp;


PROCEDURE BinOp (VAR reg1, reg2: INTEGER);
BEGIN
    REG.BinOp(R, reg1, reg2)
END BinOp;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    R.pushed := R.pushed - NumberOfParameters
END PushAll;


PROCEDURE translate (code: CODE.CODES);
VAR
    cmd, next, next2: COMMAND;

    reg1, reg2: INTEGER;

    n, a, b, label: INTEGER;

BEGIN
    cmd := code.commands.first(COMMAND);

    WHILE cmd # NIL DO

        CASE cmd.opcode OF

        |CODE.opJMP:
            OutByte(0E9H);         // jmp L
            Reloc(1, cmd.label)

        |CODE.opCALL:
            OutByte(0E8H);         // call L
            Reloc(1, cmd.label)

        |CODE.opCALLI:
            OutByte2(0FFH, 015H);  // call dword[L]
            Reloc(2, cmd.label)

        |CODE.opCALLP:
            UnOp(reg1);
            OutByte2(0FFH, 0D0H + reg1);    // call reg1
            drop;
            ASSERT(R.top = -1)

        |CODE.opPRECALL:
            n := cmd.param;
            IF (cmd.param2 # 0) & (n # 0) THEN
                OutByte3(083H, 0ECH, 008H)  // sub esp, 8
            END;
            WHILE n > 0 DO
                OutByte3(083H, 0ECH, 008H); // sub esp, 8
                OutByte3(0DDH, 01CH, 024H); // fstp qword[esp]
                DEC(n)
            END;
            PushAll(0)

        |CODE.opRES:
            ASSERT(R.top = -1);
            ASSERT(REG.GetReg(R, eax));
            n := cmd.param;
            WHILE n > 0 DO
                OutByte3(0DDH, 004H, 024H); // fld qword[esp]
                OutByte3(083H, 0C4H, 008H); // add esp, 8
                DEC(n)
            END

        |CODE.opRESF:
            n := cmd.param;
            IF n > 0 THEN
                OutByte3(0DDH, 5CH + 40H * ORD(~isByte(n * 8)), 24H);
                OutIntByte(n * 8); // fstp qword[esp + n*8]
                INC(n)
            END;

            WHILE n > 0 DO
                OutByte3(0DDH, 004H, 024H); // fld qword[esp]
                OutByte3(083H, 0C4H, 008H); // add esp, 8
                DEC(n)
            END

        |CODE.opENTER:
            ASSERT(R.top = -1);
            OutByte(055H);          // push ebp
            OutByte2(089H, 0E5H);   // mov ebp, esp

            n := cmd.param;
            IF n > 4 THEN
                movrc(ecx, n);        // mov ecx,n
                pushc(0);             // @@: push 0
                OutByte2(0E2H, 0FCH)  // loop @b
            ELSE
                WHILE n > 0 DO
                    pushc(0);
                    DEC(n)
                END
            END

        |CODE.opLEAVE, CODE.opLEAVER, CODE.opLEAVEF:
            IF cmd.opcode = CODE.opLEAVER THEN
                UnOp(reg1);
                IF reg1 # eax THEN
                    ASSERT(REG.GetReg(R, eax));
                    ASSERT(REG.Exchange(R, reg1, eax));
                    drop
                END;
                drop
            END;

            ASSERT(R.top = -1);

            OutByte2(089H, 0ECH);  // mov esp, ebp
            OutByte(05DH);         // pop ebp

            n := cmd.param;
            IF n > 0 THEN
                n := n * 4;
                OutByte(0C2H); OutWord(Word(n)) // ret n
            ELSE
                OutByte(0C3H) // ret
            END

        |CODE.opERRC:
            pushc(cmd.param)

        |CODE.opPARAM:
            n := cmd.param;
            IF n = 1 THEN
                UnOp(reg1);
                push(reg1);
                drop
            ELSE
                ASSERT(R.top + 1 <= n);
                PushAll(n)
            END

        |CODE.opCLEANUP:
            n := cmd.param * 4;
            IF n # 0 THEN
                OutByte2(81H + 2 * ORD(isByte(n)), 0C4H);  // add esp, n
                OutIntByte(n)
            END

        |CODE.opCONST:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                pushc(cmd.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                movrc(reg1, cmd.param)
            END

        |CODE.opLABEL,
         CODE.opPROC:
            BIN.SetLabel(program, cmd.param) // L:

        |CODE.opNOP:

        |CODE.opGADR:
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opSAVEC THEN
                OutByte2(0C7H, 05H);  // mov dword[_bss + cmd.param], next.param
                Reloc(3, cmd.param);
                OutInt(next.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte(0B8H + reg1);  // mov reg1, _bss + cmd.param
                Reloc(3, cmd.param)
            END

        |CODE.opLADR:
            n := cmd.param * 4;
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opSAVEC THEN
                OutByte2(0C7H, 45H + 40H * ORD(~isByte(n)));  // mov dword[ebp + n], next.param
                OutIntByte(n);
                OutInt(next.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte2(8DH, 45H + reg1 * 8 + 40H * ORD(~isByte(n)));  // lea reg1, dword[ebp + n]
                OutIntByte(n)
            END

        |CODE.opVADR:
            n := cmd.param * 4;
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte2(0FFH, 75H + 40H * ORD(~isByte(n)));  // push dword[ebp + n]
                OutIntByte(n);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte2(8BH, 45H + reg1 * 8 + 40H * ORD(~isByte(n)));  // mov reg1, dword[ebp + n]
                OutIntByte(n)
            END

        |CODE.opSADR:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte(068H);  // push _data + stroffs + cmd.param
                Reloc(4, stroffs + cmd.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte(0B8H + reg1);  // mov reg1, _data + stroffs + cmd.param
                Reloc(4, stroffs + cmd.param)
            END

        |CODE.opSAVEC:
            UnOp(reg1);
            OutByte2(0C7H, reg1); OutInt(cmd.param);  // mov dword[reg1], cmd.param
            drop

        |CODE.opSAVE8C:
            UnOp(reg1);
            OutByte3(0C6H, reg1, Byte(cmd.param));  // mov byte[reg1], cmd.param
            drop

        |CODE.opSAVE16C:
            UnOp(reg1);
            OutByte3(66H, 0C7H, reg1); OutWord(Word(cmd.param));  // mov word[reg1], cmd.param
            drop

        |CODE.opVLOAD32:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte2(8BH, 45H + reg1 * 8 + 40H * ORD(~isByte(n)));  // mov reg1, dword[ebp + n]
            OutIntByte(n);
            OutByte2(8BH, reg1 * 9)  // mov reg1, dword[reg1]

        |CODE.opGLOAD32:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte2(0FFH, 035H);  // push dword[_bss + cmd.param]
                Reloc(3, cmd.param);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte2(08BH, 05H + reg1 * 8);  // mov reg1, dword[_bss + cmd.param]
                Reloc(3, cmd.param)
            END

        |CODE.opLLOAD32:
            next := cmd.next(COMMAND);
            n := cmd.param * 4;
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                OutByte2(0FFH, 75H + 40H * ORD(~isByte(n)));  // push dword[ebp + n]
                OutIntByte(n);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                OutByte2(8BH, 45H + reg1 * 8 + 40H * ORD(~isByte(n)));  // mov reg1, dword[ebp + n]
                OutIntByte(n)
            END

        |CODE.opLOAD32:
            next := cmd.next(COMMAND);
            IF (next.opcode = CODE.opPARAM) & (next.param = 1) THEN
                UnOp(reg1);
                OutByte2(0FFH, 30H + reg1);  // push dword[reg1]
                drop;
                cmd := next
            ELSE
                UnOp(reg1);
                OutByte2(8BH, reg1 * 9)  // mov reg1, dword[reg1]
            END

        |CODE.opVLOAD8:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte2(8BH, 45H + reg1 * 8 + 40H * ORD(~isByte(n))); // mov reg1, dword[ebp + n]
            OutIntByte(n);
            OutByte3(0FH, 0B6H, reg1 * 9) // movzx reg1, byte[reg1]

        |CODE.opGLOAD8:
            reg1 := REG.GetAnyReg(R);
            OutByte3(00FH, 0B6H, 05H + reg1 * 8);  // movzx reg1, byte[_bss + cmd.param]
            Reloc(3, cmd.param)

        |CODE.opLLOAD8:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte3(0FH, 0B6H, 45H + reg1 * 8 + 40H * ORD(~isByte(n))); // movzx reg1, byte[ebp + n]
            OutIntByte(n)

        |CODE.opLOAD8:
            UnOp(reg1);
            OutByte3(0FH, 0B6H, reg1 * 9) // movzx reg1, byte[reg1]

        |CODE.opVLOAD16:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte2(8BH, 45H + reg1 * 8 + 40H * ORD(~isByte(n))); // mov reg1, dword[ebp + n]
            OutIntByte(n);
            OutByte3(0FH, 0B7H, reg1 * 9) // movzx reg1, word[reg1]

        |CODE.opGLOAD16:
            reg1 := REG.GetAnyReg(R);
            OutByte3(00FH, 0B7H, 05H + reg1 * 8);  // movzx reg1, word[_bss + cmd.param]
            Reloc(3, cmd.param)

        |CODE.opLLOAD16:
            n := cmd.param * 4;
            reg1 := REG.GetAnyReg(R);
            OutByte3(0FH, 0B7H, 45H + reg1 * 8 + 40H * ORD(~isByte(n))); // movzx reg1, word[ebp + n]
            OutIntByte(n)

        |CODE.opLOAD16:
            UnOp(reg1);
            OutByte3(0FH, 0B7H, reg1 * 9) // movzx reg1, word[reg1]

        |CODE.opUMINUS:
            UnOp(reg1);
            neg(reg1)

        |CODE.opADD:
            BinOp(reg1, reg2);
            add(reg1, reg2);
            drop

        |CODE.opADDL, CODE.opADDR:
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opLOAD32 THEN
                next2 := next.next(COMMAND);
                UnOp(reg1);
                n := cmd.param;

                IF (next2.opcode = CODE.opPARAM) & (next2.param = 1) THEN
                    OutByte2(0FFH, 70H + reg1 + 40H * ORD(~isByte(n))); // push dword[reg1 + n]
                    OutIntByte(n);
                    drop;
                    cmd := next2
                ELSE
                    OutByte2(8BH, 40H + reg1 * 9 + 40H * ORD(~isByte(n))); // mov reg1, dword[reg1 + n]
                    OutIntByte(n);
                    cmd := next
                END

            ELSIF next.opcode = CODE.opLOAD8 THEN
                UnOp(reg1);
                n := cmd.param;
                OutByte3(0FH, 0B6H, 40H + reg1 * 9 + 40H * ORD(~isByte(n))); // movzx reg1, byte[reg1 + n]
                OutIntByte(n);
                cmd := next
            ELSE
                IF cmd.param # 0 THEN
                    UnOp(reg1);
                    IF cmd.param = 1 THEN
                        OutByte(40H + reg1) // inc reg1
                    ELSIF cmd.param = -1 THEN
                        OutByte(48H + reg1) // dec reg1
                    ELSE
                        addrc(reg1, cmd.param)
                    END
                END
            END

        |CODE.opSUB:
            BinOp(reg1, reg2);
            OutByte2(29H, 0C0H + reg2 * 8 + reg1); // sub reg1, reg2
            drop

        |CODE.opSUBR, CODE.opSUBL:
            UnOp(reg1);
            n := cmd.param;
            IF n = 1 THEN
                OutByte(48H + reg1) // dec reg1
            ELSIF n = -1 THEN
                OutByte(40H + reg1) // inc reg1
            ELSIF n # 0 THEN
                OutByte2(81H + 2 * ORD(isByte(n)), 0E8H + reg1); // sub reg, n
                OutIntByte(n)
            END;
            IF cmd.opcode = CODE.opSUBL THEN
                neg(reg1)
            END

        |CODE.opMULC:
            UnOp(reg1);

            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                neg(reg1)
            ELSIF a = 0 THEN
                OutByte2(31H, 0C0H + reg1 * 9) // xor reg1, reg1
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        neg(reg1)
                    END;

                    IF n # 1 THEN
                        OutByte3(0C1H, 0E0H + reg1, n)   // shl reg1, n
                    ELSE
                        OutByte2(0D1H, 0E0H + reg1)      // shl reg1, 1
                    END
                ELSE
                    OutByte2(69H + 2 * ORD(isByte(a)), 0C0H + reg1 * 9); // imul reg1, a
                    OutIntByte(a)
                END
            END

        |CODE.opMUL:
            BinOp(reg1, reg2);
            OutByte3(0FH, 0AFH, 0C0H + reg1 * 8 + reg2); // imul reg1, reg2
            drop

        |CODE.opSAVE, CODE.opSAVE32:
            BinOp(reg1, reg2);
            OutByte2(89H, reg2 * 8 + reg1); // mov dword[reg1], reg2
            drop;
            drop

        |CODE.opSAVE8:
            BinOp(reg1, reg2);
            OutByte2(88H, reg2 * 8 + reg1); // mov byte[reg1], reg2
            drop;
            drop

        |CODE.opSAVE16:
            BinOp(reg1, reg2);
            OutByte3(66H, 89H, reg2 * 8 + reg1); // mov word[reg1], reg2
            drop;
            drop

        |CODE.opSAVEP:
            UnOp(reg1);
            OutByte2(0C7H, reg1);  // mov dword[reg1], L
            Reloc(5, program.labels[cmd.param]);
            drop

        |CODE.opSAVEIP:
            UnOp(reg1);
            OutByte2(0FFH, 035H);  // push dword[L]
            Reloc(2, cmd.param);
            OutByte2(8FH, reg1);   // pop dword[reg1]
            drop

        |CODE.opPUSHP:
            reg1 := REG.GetAnyReg(R);
            OutByte(0B8H + reg1);  // mov reg1, L
            Reloc(5, program.labels[cmd.param])

        |CODE.opPUSHIP:
            reg1 := REG.GetAnyReg(R);
            OutByte2(8BH, 05H + reg1 * 8);  // mov reg1, [L]
            Reloc(2, cmd.param)

        |CODE.opNOT:
            UnOp(reg1);
            drop;
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(sete, reg1);
            andrc(reg1, 1)

        |CODE.opORD:
            UnOp(reg1);
            drop;
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(setne, reg1);
            andrc(reg1, 1)

        |CODE.opSBOOL:
            UnOp(reg1);
            drop;
            test(reg1);
            reg1 := REG.GetAnyReg(R);
            setcc(setne, reg1);
            BinOp(reg1, reg2);
            OutByte2(88H, reg2 * 8 + reg1); // mov byte[reg1], reg2
            drop;
            drop

        |CODE.opSBOOLC:
            UnOp(reg1);
            OutByte3(0C6H, reg1, ORD(cmd.param # 0)); // mov byte[reg1], 0/1
            drop

        |CODE.opODD:
            UnOp(reg1);
            andrc(reg1, 1)

        |CODE.opGTR, CODE.opLTL, CODE.opGER, CODE.opLEL,
         CODE.opLER, CODE.opGEL, CODE.opLTR, CODE.opGTL,
         CODE.opEQR, CODE.opEQL, CODE.opNER, CODE.opNEL:
            UnOp(reg1);
            IF cmd.param = 0 THEN
                test(reg1)
            ELSE
                cmprc(reg1, cmd.param)
            END;
            drop;

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jg,  label)
                |CODE.opGER, CODE.opLEL: jcc(jge, label)
                |CODE.opLER, CODE.opGEL: jcc(jle, label)
                |CODE.opLTR, CODE.opGTL: jcc(jl,  label)
                |CODE.opEQR, CODE.opEQL: jcc(je,  label)
                |CODE.opNER, CODE.opNEL: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jle, label)
                |CODE.opGER, CODE.opLEL: jcc(jl,  label)
                |CODE.opLER, CODE.opGEL: jcc(jg,  label)
                |CODE.opLTR, CODE.opGTL: jcc(jge, label)
                |CODE.opEQR, CODE.opEQL: jcc(jne, label)
                |CODE.opNER, CODE.opNEL: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: setcc(setg,  reg1)
                |CODE.opGER, CODE.opLEL: setcc(setge, reg1)
                |CODE.opLER, CODE.opGEL: setcc(setle, reg1)
                |CODE.opLTR, CODE.opGTL: setcc(setl,  reg1)
                |CODE.opEQR, CODE.opEQL: setcc(sete,  reg1)
                |CODE.opNER, CODE.opNEL: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END;

        |CODE.opGT, CODE.opGE, CODE.opLT,
         CODE.opLE, CODE.opEQ, CODE.opNE:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            drop;
            drop;

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jg,  label)
                |CODE.opGE: jcc(jge, label)
                |CODE.opLE: jcc(jle, label)
                |CODE.opLT: jcc(jl,  label)
                |CODE.opEQ: jcc(je,  label)
                |CODE.opNE: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).label;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jle, label)
                |CODE.opGE: jcc(jl,  label)
                |CODE.opLE: jcc(jg,  label)
                |CODE.opLT: jcc(jge, label)
                |CODE.opEQ: jcc(jne, label)
                |CODE.opNE: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGT: setcc(setg,  reg1)
                |CODE.opGE: setcc(setge, reg1)
                |CODE.opLE: setcc(setle, reg1)
                |CODE.opLT: setcc(setl,  reg1)
                |CODE.opEQ: setcc(sete,  reg1)
                |CODE.opNE: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END

        |CODE.opEQB, CODE.opNEB:
            BinOp(reg1, reg2);
            drop;
            drop;

            test(reg1);
            OutByte2(74H, 5);  // je @f
            movrc(reg1, 1);    // mov reg1, 1
                               // @@:
            test(reg2);
            OutByte2(74H, 5);  // je @f
            movrc(reg2, 1);    // mov reg2, 1
                               // @@:

            cmprr(reg1, reg2);
            reg1 := REG.GetAnyReg(R);
            IF cmd.opcode = CODE.opEQB THEN
                setcc(sete, reg1)
            ELSE
                setcc(setne, reg1)
            END;
            andrc(reg1, 1)

        |CODE.opACC:
            IF (R.top # 0) OR (R.stk[0] # eax) THEN
                PushAll(0);
                ASSERT(REG.GetReg(R, eax));
                pop(eax);
                DEC(R.pushed)
            END

        |CODE.opDROP:
            UnOp(reg1);
            drop

        |CODE.opJE, CODE.opJNE:
            UnOp(reg1);
            drop;
            test(reg1);
            IF cmd.opcode = CODE.opJE THEN
                jcc(jne, cmd.label)
            ELSE
                jcc(je, cmd.label)
            END

        |CODE.opJNZ:
            UnOp(reg1);
            test(reg1);
            jcc(jne, cmd.label)

        |CODE.opJZ:
            UnOp(reg1);
            test(reg1);
            jcc(je, cmd.label)

        |CODE.opSWITCH:
            UnOp(reg1);
            IF reg1 # eax THEN
                ASSERT(REG.GetReg(R, eax));
                ASSERT(REG.Exchange(R, reg1, eax));
                drop
            END;
            drop

        |CODE.opENDSW:

        |CODE.opCASE1:
            cmprc(eax, cmd.param);
            jcc(je, cmd.label)

        |CODE.opCASE:
            label := CODE.NewLabel();
            cmprc(eax, cmd.param);
            jcc(jl, label);
            cmprc(eax, cmd.param2);
            jcc(jle, cmd.label);
            BIN.SetLabel(program, label)

        |CODE.opCODE:
            OutByte(Byte(cmd.param))

        |CODE.opGET:
            BinOp(reg1, reg2);
            drop;
            drop;

            CASE cmd.param OF
            |1:
                OutByte2(8AH, reg1 * 9);       // mov reg1, byte[reg1]
                OutByte2(88H, reg1 * 8 + reg2) // mov byte[reg2], reg1

            |2:
                OutByte3(66H, 8BH, reg1 * 9);       // mov reg1, word[reg1]
                OutByte3(66H, 89H, reg1 * 8 + reg2) // mov word[reg2], reg1

            |4:
                OutByte2(8BH, reg1 * 9);        // mov reg1, dword[reg1]
                OutByte2(89H, reg1 * 8 + reg2)  // mov dword[reg2], reg1

            |8:
                PushAll(0);
                push(reg2);
                push(reg1);
                pushc(8);
                CallRTL(CODE._move)

            END

        |CODE.opSAVES:
            UnOp(reg1);
            drop;
            PushAll(0);
            push(reg1);
            OutByte(068H);  // push _data + stroffs + cmd.param
            Reloc(4, stroffs + cmd.param);
            pushc(cmd.param2);
            CallRTL(CODE._move)

        |CODE.opCHKIDX:
            UnOp(reg1);
            cmprc(reg1, cmd.param);
            jcc(jb, cmd.label)

        |CODE.opCHKIDX2:
            BinOp(reg1, reg2);
            cmprr(reg2, reg1);
            mov(reg1, reg2);
            drop;
            jcc(jb, cmd.label)

        |CODE.opLEN:
            n := cmd.param;
            UnOp(reg1);
            drop;
            EXCL(R.regs, reg1);

            WHILE n > 0 DO
                UnOp(reg2);
                drop;
                DEC(n)
            END;

            INCL(R.regs, reg1);
            ASSERT(REG.GetReg(R, reg1))

        |CODE.opINC1:
            UnOp(reg1);
            OutByte2(0FFH, reg1); // inc dword[reg1]
            drop

        |CODE.opDEC1:
            UnOp(reg1);
            OutByte2(0FFH, 8 + reg1); // dec dword[reg1]
            drop

        |CODE.opINCC:
            UnOp(reg1);
            n := cmd.param;
            OutByte2(81H + 2 * ORD(isByte(n)), reg1); OutIntByte(n); // add dword[reg1], n
            drop

        |CODE.opDECC:
            UnOp(reg1);
            n := cmd.param;
            OutByte2(81H + 2 * ORD(isByte(n)), 28H + reg1); OutIntByte(n); // sub dword[reg1], n
            drop

        |CODE.opINC:
            BinOp(reg1, reg2);
            OutByte2(01H, reg2 * 8 + reg1); // add dword[reg1], reg2
            drop;
            drop

        |CODE.opDEC:
            BinOp(reg1, reg2);
            OutByte2(29H, reg2 * 8 + reg1); // sub dword[reg1], reg2
            drop;
            drop

        |CODE.opINC1B:
            UnOp(reg1);
            OutByte2(0FEH, reg1); // inc byte[reg1]
            drop

        |CODE.opDEC1B:
            UnOp(reg1);
            OutByte2(0FEH, 08H + reg1); // dec byte[reg1]
            drop

        |CODE.opINCCB:
            UnOp(reg1);
            OutByte3(80H, reg1, Byte(cmd.param)); // add byte[reg1], n
            drop

        |CODE.opDECCB:
            UnOp(reg1);
            OutByte3(80H, 28H + reg1, Byte(cmd.param)); // sub byte[reg1], n
            drop

        |CODE.opINCB, CODE.opDECB:
            BinOp(reg1, reg2);

            IF cmd.opcode = CODE.opINCB THEN
                OutByte2(00H, reg2 * 8 + reg1) // add byte[reg1], reg2
            ELSE
                OutByte2(28H, reg2 * 8 + reg1) // sub byte[reg1], reg2
            END;

            drop;
            drop

        |CODE.opMULS:
            BinOp(reg1, reg2);
            OutByte2(21H, 0C0H + reg2 * 8 + reg1); // and reg1, reg2
            drop

        |CODE.opMULSC:
            UnOp(reg1);
            andrc(reg1, cmd.param)

        |CODE.opDIVS:
            BinOp(reg1, reg2);
            OutByte2(31H, 0C0H + reg2 * 8 + reg1); // xor reg1, reg2
            drop

        |CODE.opDIVSC:
            n := cmd.param;
            UnOp(reg1);
            OutByte2(81H + 2 * ORD(isByte(n)), 0F0H + reg1);  // or reg1, n
            OutIntByte(n)

        |CODE.opADDS:
            BinOp(reg1, reg2);
            OutByte2(9H, 0C0H + reg2 * 8 + reg1); // or reg1, reg2
            drop

        |CODE.opSUBS:
            BinOp(reg1, reg2);
            not(reg2);
            OutByte2(21H, 0C0H + reg2 * 8 + reg1); // and reg1, reg2
            drop

        |CODE.opADDSL, CODE.opADDSR:
            n := cmd.param;
            UnOp(reg1);
            OutByte2(81H + 2 * ORD(isByte(n)), 0C8H + reg1);  // or reg1, n
            OutIntByte(n)

        |CODE.opSUBSL:
            UnOp(reg1);
            not(reg1);
            andrc(reg1, cmd.param)

        |CODE.opSUBSR:
            UnOp(reg1);
            andrc(reg1, ORD(-BITS(cmd.param)));

        |CODE.opUMINS:
            UnOp(reg1);
            not(reg1)

        |CODE.opLENGTH:
            PushAll(2);
            CallRTL(CODE._length);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opLENGTHW:
            PushAll(2);
            CallRTL(CODE._lengthw);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCHR:
            UnOp(reg1);
            andrc(reg1, 255)

        |CODE.opWCHR:
            UnOp(reg1);
            andrc(reg1, 65535)

        |CODE.opASR, CODE.opROR, CODE.opLSL, CODE.opLSR:
            UnOp(reg1);
            IF reg1 # ecx THEN
                ASSERT(REG.GetReg(R, ecx));
                ASSERT(REG.Exchange(R, reg1, ecx));
                drop
            END;

            BinOp(reg1, reg2);
            ASSERT(reg2 = ecx);
            OutByte(0D3H);
            CASE cmd.opcode OF
            |CODE.opASR: OutByte(0F8H + reg1)  // sar reg1, cl
            |CODE.opROR: OutByte(0C8H + reg1)  // ror reg1, cl
            |CODE.opLSL: OutByte(0E0H + reg1)  // shl reg1, cl
            |CODE.opLSR: OutByte(0E8H + reg1)  // shr reg1, cl
            END;
            drop

        |CODE.opASR1, CODE.opROR1, CODE.opLSL1, CODE.opLSR1:
            UnOp(reg1);
            IF reg1 # ecx THEN
                ASSERT(REG.GetReg(R, ecx));
                ASSERT(REG.Exchange(R, reg1, ecx));
                drop
            END;

            reg1 := REG.GetAnyReg(R);

            movrc(reg1, cmd.param);

            BinOp(reg1, reg2);
            ASSERT(reg1 = ecx);
            OutByte(0D3H);
            CASE cmd.opcode OF
            |CODE.opASR1: OutByte(0F8H + reg2)  // sar reg2, cl
            |CODE.opROR1: OutByte(0C8H + reg2)  // ror reg2, cl
            |CODE.opLSL1: OutByte(0E0H + reg2)  // shl reg2, cl
            |CODE.opLSR1: OutByte(0E8H + reg2)  // shr reg2, cl
            END;
            drop;
            drop;
            ASSERT(REG.GetReg(R, reg2))

        |CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
            UnOp(reg1);
            n := ORD(BITS(cmd.param) * {0..4});
            IF n # 1 THEN
                OutByte(0C1H)
            ELSE
                OutByte(0D1H)
            END;

            CASE cmd.opcode OF
            |CODE.opASR2: OutByte(0F8H + reg1) // sar reg1, n
            |CODE.opROR2: OutByte(0C8H + reg1) // ror reg1, n
            |CODE.opLSL2: OutByte(0E0H + reg1) // shl reg1, n
            |CODE.opLSR2: OutByte(0E8H + reg1) // shr reg1, n
            END;

            IF n # 1 THEN
                OutByte(n)
            END

        |CODE.opMIN:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            OutByte2(07EH, 002H);  // jle @f
            mov(reg1, reg2);       // mov reg1, reg2
                                   // @@:
            drop

        |CODE.opMAX:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            OutByte2(07DH, 002H);  // jge @f
            mov(reg1, reg2);       // mov reg1, reg2
                                   // @@:
            drop

        |CODE.opMINC:
            UnOp(reg1);
            cmprc(reg1, cmd.param);
            OutByte2(07EH, 005H);    // jle @f
            movrc(reg1, cmd.param);  // mov reg1, cmd.param
                                     // @@:

        |CODE.opMAXC:
            UnOp(reg1);
            cmprc(reg1, cmd.param);
            OutByte2(07DH, 005H);    // jge @f
            movrc(reg1, cmd.param);  // mov reg1, cmd.param
                                     // @@:

        |CODE.opIN:
            PushAll(2);
            CallRTL(CODE._in);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINR:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._in);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINL:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._in2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSET:
            PushAll(2);
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSETR:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSETL:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._set2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opRSET1:
            UnOp(reg1);
            PushAll(1);
            push(reg1);
            CallRTL(CODE._set);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opINCL:
            PushAll(2);
            CallRTL(CODE._incl)

        |CODE.opEXCL:
            PushAll(2);
            CallRTL(CODE._excl)

        |CODE.opINCLC:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._incl)

        |CODE.opEXCLC:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._excl)

        |CODE.opDIV:
            PushAll(2);
            CallRTL(CODE._div);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opDIVR:
            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                UnOp(reg1);
                neg(reg1)
            ELSE
                IF n > 0 THEN
                    UnOp(reg1);

                    IF a < 0 THEN
                        reg2 := REG.GetAnyReg(R);
                        mov(reg2, reg1);
                        IF n # 1 THEN
                            OutByte3(0C1H, 0F8H + reg1, n)     // sar reg1, n
                        ELSE
                            OutByte2(0D1H, 0F8H + reg1)        // sar reg1, 1
                        END;
                        OutByte2(29H, 0C0H + reg2 * 8 + reg1); // sub reg1, reg2
                        drop
                    ELSE
                        IF n # 1 THEN
                            OutByte3(0C1H, 0F8H + reg1, n)     // sar reg1, n
                        ELSE
                            OutByte2(0D1H, 0F8H + reg1)        // sar reg1, 1
                        END
                    END

                ELSE
                    PushAll(1);
                    pushc(cmd.param);
                    CallRTL(CODE._div);
                    ASSERT(REG.GetReg(R, eax))
                END
            END

        |CODE.opDIVL:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._div2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opMOD:
            PushAll(2);
            CallRTL(CODE._mod);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opMODR:
            a := cmd.param;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF ABS(a) = 1 THEN
                UnOp(reg1);
                OutByte2(31H, 0C0H + reg1 * 9) // xor reg1, reg1
            ELSE
                IF n > 0 THEN
                    UnOp(reg1);
                    andrc(reg1, ABS(a) - 1);

                    IF a < 0 THEN
                        test(reg1);
                        OutByte(74H);      // je @f
                        IF isByte(a) THEN
                            OutByte(3)
                        ELSE
                            OutByte(6)
                        END;
                        addrc(reg1, a)
                                           // @@:
                    END

                ELSE
                    PushAll(1);
                    pushc(cmd.param);
                    CallRTL(CODE._mod);
                    ASSERT(REG.GetReg(R, eax))
                END
            END

        |CODE.opMODL:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._mod2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opERR:
            CallRTL(CODE._error)

        |CODE.opABS:
            UnOp(reg1);
            test(reg1);
            OutByte2(07DH, 002H); // jge @f
            neg(reg1);            // neg reg1
                                  // @@:

        |CODE.opCOPY:
            PushAll(2);
            pushc(cmd.param);
            CallRTL(CODE._move)

        |CODE.opMOVE:
            PushAll(3);
            CallRTL(CODE._move2)

        |CODE.opCOPYA:
            PushAll(4);
            pushc(cmd.param);
            CallRTL(CODE._arrcpy);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCOPYS:
            PushAll(4);
            pushc(cmd.param);
            CallRTL(CODE._strcpy)

        |CODE.opCOPYS2:
            PushAll(4);
            pushc(cmd.param);
            CallRTL(CODE._strcpy2)

        |CODE.opROT:
            PushAll(0);
            OutByte(54H);  // push esp
            pushc(cmd.param);
            CallRTL(CODE._rot)

        |CODE.opNEW:
            PushAll(1);
            n := cmd.param + 8;
            ASSERT(MACHINE.Align(n, 32));
            pushc(n);
            pushc(cmd.param2);
            CallRTL(CODE._new)

        |CODE.opDISP:
            PushAll(1);
            CallRTL(CODE._dispose)

        |CODE.opEQS, CODE.opNES, CODE.opLTS,
         CODE.opLES, CODE.opGTS, CODE.opGES:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQS: pushc(0)
            |CODE.opNES: pushc(1)
            |CODE.opLTS: pushc(2)
            |CODE.opLES: pushc(3)
            |CODE.opGTS: pushc(4)
            |CODE.opGES: pushc(5)
            END;
            CallRTL(CODE._strcmp);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQS2, CODE.opNES2, CODE.opLTS2,
         CODE.opLES2, CODE.opGTS2, CODE.opGES2:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQS2: pushc(0)
            |CODE.opNES2: pushc(1)
            |CODE.opLTS2: pushc(2)
            |CODE.opLES2: pushc(3)
            |CODE.opGTS2: pushc(4)
            |CODE.opGES2: pushc(5)
            END;
            CallRTL(CODE._strcmp2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQSW, CODE.opNESW, CODE.opLTSW,
         CODE.opLESW, CODE.opGTSW, CODE.opGESW:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQSW: pushc(0)
            |CODE.opNESW: pushc(1)
            |CODE.opLTSW: pushc(2)
            |CODE.opLESW: pushc(3)
            |CODE.opGTSW: pushc(4)
            |CODE.opGESW: pushc(5)
            END;
            CallRTL(CODE._strcmpw);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQSW2, CODE.opNESW2, CODE.opLTSW2,
         CODE.opLESW2, CODE.opGTSW2, CODE.opGESW2:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQSW2: pushc(0)
            |CODE.opNESW2: pushc(1)
            |CODE.opLTSW2: pushc(2)
            |CODE.opLESW2: pushc(3)
            |CODE.opGTSW2: pushc(4)
            |CODE.opGESW2: pushc(5)
            END;
            CallRTL(CODE._strcmpw2);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opEQP, CODE.opNEP, CODE.opEQIP, CODE.opNEIP:
            UnOp(reg1);
            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opNEP:
                OutByte2(081H, 0F8H + reg1);  // cmp reg1, L
                Reloc(5, program.labels[cmd.label])

            |CODE.opEQIP, CODE.opNEIP:
                OutByte2(3BH, 05H + reg1 * 8);  // cmp reg1, dword[L]
                Reloc(2, cmd.label)

            END;
            drop;
            reg1 := REG.GetAnyReg(R);

            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opEQIP: setcc(sete,  reg1)
            |CODE.opNEP, CODE.opNEIP: setcc(setne, reg1)
            END;

            andrc(reg1, 1)

        |CODE.opPUSHT:
            UnOp(reg1);
            reg2 := REG.GetAnyReg(R);
            OutByte3(8BH, 40H + reg2 * 8 + reg1, 0FCH)  // mov reg2, dword[reg1 - 4]

        |CODE.opISREC:
            PushAll(2);
            pushc(cmd.param);
            CallRTL(CODE._isrec);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opTYPEGR:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._guardrec);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opIS:
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._is);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opTYPEG:
            UnOp(reg2);
            reg1 := REG.GetAnyReg(R);
            mov(reg1, reg2);
            PushAll(1);
            pushc(cmd.param);
            CallRTL(CODE._guard);
            ASSERT(REG.GetReg(R, eax))

        |CODE.opCASET:
            push(eax);
            push(eax);
            pushc(cmd.param);
            CallRTL(CODE._guardrec);
            mov(ecx, eax);
            pop(eax);
            test(ecx);
            jcc(jne, cmd.label)

        |CODE.opPACK:
            BinOp(reg1, reg2);
            push(reg2);
            OutByte3(0DBH, 004H, 024H);   // fild dword[esp]
            OutByte2(0DDH, reg1);         // fld qword[reg1]
            OutByte2(0D9H, 0FDH);         // fscale
            OutByte2(0DDH, 018H + reg1);  // fstp qword[reg1]
            OutByte3(0DBH, 01CH, 024H);   // fistp dword[esp]
            pop(reg2);
            drop;
            drop

        |CODE.opPACKC:
            UnOp(reg1);
            pushc(cmd.param);
            OutByte3(0DBH, 004H, 024H);   // fild dword[esp]
            OutByte2(0DDH, reg1);         // fld qword[reg1]
            OutByte2(0D9H, 0FDH);         // fscale
            OutByte2(0DDH, 018H + reg1);  // fstp qword[reg1]
            OutByte3(0DBH, 01CH, 024H);   // fistp dword[esp]
            pop(reg1);
            drop

        |CODE.opUNPK:
            BinOp(reg1, reg2);
            OutByte2(0DDH, reg1);         // fld qword[reg1]
            OutByte2(0D9H, 0F4H);         // fxtract
            OutByte2(0DDH, 018H + reg1);  // fstp qword[reg1]
            OutByte2(0DBH, 018H + reg2);  // fistp dword[reg2]
            drop;
            drop

        |CODE.opPUSHF:
            OutByte3(083H, 0ECH, 008H);   // sub esp,8
            OutByte3(0DDH, 01CH, 024H)    // fstp qword[esp]

        |CODE.opLOADF:
            UnOp(reg1);
            OutByte2(0DDH, reg1);         // fld qword[reg1]
            drop

        |CODE.opCONSTF:
            IF cmd.float = 0.0 THEN
                OutByte2(0D9H, 0EEH)      // fldz
            ELSIF cmd.float = 1.0 THEN
                OutByte2(0D9H, 0E8H)      // fld1
            ELSIF cmd.float = -1.0 THEN
                OutByte2(0D9H, 0E8H);     // fld1
                OutByte2(0D9H, 0E0H)      // fchs
            ELSE
                UTILS.splitf(cmd.float, a, b);
                pushc(b);
                pushc(a);
                OutByte3(0DDH, 004H, 024H); // fld qword[esp]
                OutByte3(083H, 0C4H, 008H)  // add esp,8
            END

        |CODE.opSAVEF:
            UnOp(reg1);
            OutByte2(0DDH, 018H + reg1); // fstp qword[reg1]
            drop

        |CODE.opADDF, CODE.opADDFI:
            OutByte2(0DEH, 0C1H)  // faddp st1, st

        |CODE.opSUBF:
            OutByte2(0DEH, 0E9H)  // fsubp st1, st

        |CODE.opSUBFI:
            OutByte2(0DEH, 0E1H)  // fsubrp st1, st

        |CODE.opMULF:
            OutByte2(0DEH, 0C9H)  // fmulp st1, st

        |CODE.opDIVF:
            OutByte2(0DEH, 0F9H)  // fdivp st1, st

        |CODE.opDIVFI:
            OutByte2(0DEH, 0F1H)  // fdivrp st1, st

        |CODE.opUMINF:
            OutByte2(0D9H, 0E0H)  // fchs

        |CODE.opFABS:
            OutByte2(0D9H, 0E1H)  // fabs

        |CODE.opFLT:
            UnOp(reg1);
            push(reg1);
            OutByte3(0DBH, 004H, 024H); // fild dword[esp]
            pop(reg1);
            drop

        |CODE.opFLOOR:
            reg1 := REG.GetAnyReg(R);
            OutByte3(083H, 0ECH, 008H);                                         // sub esp,8
            OutByte2(09BH, 0D9H); OutByte3(07CH, 024H, 004H);                   // fstcw word[esp+4]
            OutByte2(09BH, 0D9H); OutByte3(07CH, 024H, 006H);                   // fstcw word[esp+6]
            OutByte2(066H, 081H); OutByte3(064H, 024H, 004H); OutWord(0F3FFH);  // and word[esp+4], 1111001111111111b
            OutByte2(066H, 081H); OutByte3(04CH, 024H, 004H); OutWord(00400H);  // or  word[esp+4], 0000010000000000b
            OutByte2(0D9H, 06CH); OutByte2(024H, 004H);                         // fldcw word[esp+4]
            OutByte2(0D9H, 0FCH);                                               // frndint
            OutByte3(0DBH, 01CH, 024H);                                         // fistp dword[esp]
            pop(reg1);
            OutByte2(0D9H, 06CH); OutByte2(024H, 002H);                         // fldcw word[esp+2]
            OutByte3(083H, 0C4H, 004H)                                          // add esp,4


        |CODE.opEQF, CODE.opEQFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 006H);       // jp L
            setcc(sete, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opNEF, CODE.opNEFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 006H);       // jp L
            setcc(setne, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opLTF, CODE.opGTFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 00EH);       // jp L
            setcc(setc, al);
            setcc(sete, ah);
            test(eax);
            setcc(sete, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opGTF, CODE.opLTFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 00FH);       // jp L
            setcc(setc, al);
            setcc(sete, ah);
            cmprc(eax, 1);
            setcc(sete, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opLEF, CODE.opGEFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 006H);       // jp L
            setcc(setnc, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opGEF, CODE.opLEFI:
            ASSERT(REG.GetReg(R, eax));
            OutByte2(0DAH, 0E9H);       // fucompp
            OutByte3(09BH, 0DFH, 0E0H); // fstsw ax
            OutByte(09EH);              // sahf
            movrc(eax, 0);
            OutByte2(07AH, 010H);       // jp L
            setcc(setc, al);
            setcc(sete, ah);
            OutByte2(000H, 0E0H);       // add al,ah
            OutByte2(03CH, 001H);       // cmp al,1
            setcc(sete, al);
            andrc(eax, 1)
                                        // L:


        |CODE.opINF:
            pushc(7FF00000H);
            pushc(0);
            OutByte3(0DDH, 004H, 024H);  // fld qword[esp]
            OutByte3(083H, 0C4H, 008H)   // add esp, 8

        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)

END translate;


PROCEDURE prolog (code: CODE.CODES; target, stack: INTEGER);
BEGIN

    IF target = TARGETS.DLL THEN   (*
        WriteLn("format PE GUI 4.0 DLL");
        WriteLn("entry DllEntryPoint");
        WriteLn("section '.text' code readable executable");
        WriteLn("DllEntryPoint:");   *)
        dllinit := CODE.NewLabel();
        BIN.SetLabel(program, dllinit);
        OutByte(55H);             // push ebp
        OutByte2(89H, 0E5H);      // mov ebp,esp
        OutByte3(0FFH, 75H, 16);  // push dword[ebp+16]
        OutByte3(0FFH, 75H, 12);  // push dword[ebp+12]
        OutByte3(0FFH, 75H, 8);   // push dword[ebp+8]
        CallRTL(CODE._dllentry);
        test(eax);
        jcc(je, dllret)

    ELSIF target = TARGETS.OBJ THEN
    (*    WriteLn("format MS COFF");
        WriteLn("public EXPORTS");
        WriteLn("section '.flat' code readable align 16");
        WriteLn("lib_init:");*)
        dllinit := CODE.NewLabel();
        BIN.SetLabel(program, dllinit)
    END;

    OutByte3(09BH, 0DBH, 0E3H); // finit

    IF target IN {TARGETS.KOS, TARGETS.OBJ} THEN
        OutByte(068H);      // push IMPORT
        Reloc(6, 0)
    ELSE
        OutByte2(6AH, 00H)  // push 0
    END;

    OutByte(068H); // push _data
    Reloc(4, 0);

    pushc(code.tcount);

    OutByte(068H); // push _data + code.tcount * 4 + code.dcount
    Reloc(4, code.tcount * 4 + code.dcount);

    CallRTL(CODE._init)
END prolog;


PROCEDURE epilog (code: CODE.CODES; modname: ARRAY OF CHAR; target, stack, ver: INTEGER);
VAR
    i, n, dllver: INTEGER;
    exp:  CODE.EXPORT_PROC;


    PROCEDURE import (imp: LISTS.LIST);
    VAR
        lib:  CODE.IMPORT_LIB;
        proc: CODE.IMPORT_PROC;

    BEGIN

        lib := imp.first(CODE.IMPORT_LIB);
        WHILE lib # NIL DO
            BIN.Import(program, lib.name, 0);
            proc := lib.procs.first(CODE.IMPORT_PROC);
            WHILE proc # NIL DO
                BIN.Import(program, proc.name, proc.label);
                proc := proc.next(CODE.IMPORT_PROC)
            END;
            lib := lib.next(CODE.IMPORT_LIB)
        END

    END import;


BEGIN

    IF target = TARGETS.DLL THEN
        BIN.SetLabel(program, dllret);
        movrc(eax, 1);
        OutByte(0C9H); // leave
        OutByte3(0C2H, 00CH, 000H) // ret 12
    END;

    IF target IN {TARGETS.CON, TARGETS.GUI, TARGETS.DLL} THEN
        pushc(0);
        CallRTL(CODE._exit);
    ELSIF target = TARGETS.KOS THEN
        pushc(0);
        CallRTL(CODE._exit)
    ELSIF target = TARGETS.OBJ THEN
        movrc(eax, 1);
        OutByte(0C3H); // ret
        dllver := CODE.NewLabel();
        BIN.SetLabel(program, dllver);
   //     Write("_dllver: ");
        OutInt(ver);
    (*    WriteLn("align 16");
        WriteLn("EXPORTS:");
        WriteLn("dd szlib_init,lib_init");
        Write("dd szVersion,"); WriteHexLn(ver);
      *)
        exp := code.export.first(CODE.EXPORT_PROC);
        WHILE exp # NIL DO
         //   Write("dd "); Write("N"); WriteHex(exp.label); Write(",L"); WriteHexLn(exp.label);
            exp := exp.next(CODE.EXPORT_PROC)
        END;

     //   WriteLn("dd 0");

        exp := code.export.first(CODE.EXPORT_PROC);
        WHILE exp # NIL DO
        //    Write("N"); WriteHex(exp.label); Write(" db '"); Write(exp.name); WriteLn("',0");
            exp := exp.next(CODE.EXPORT_PROC)
        END;

     //   WriteLn("szlib_init db 'lib_init',0");
     //   WriteLn("szVersion db 'version',0")
    END;


    i := 0;
    WHILE i < code.tcount DO
        BIN.PutData32LE(program, code.types[i]);
        INC(i)
    END;

    i := 0;
    WHILE i < code.dcount DO
        BIN.PutData(program, code.data[i]);
        INC(i)
    END;

    program.modname := program.dcount;
    BIN.PutDataStr(program, modname);
    BIN.PutData(program, 0);

    program.export := program.dcount;
    IF target = TARGETS.OBJ THEN
        BIN.Export(program, "lib_init", dllinit);
        BIN.Export(program, "version",  dllver);
    END;

    exp := code.export.first(CODE.EXPORT_PROC);
    WHILE exp # NIL DO
        BIN.Export(program, exp.name, exp.label);
        exp := exp.next(CODE.EXPORT_PROC)
    END;

    program.exp_list.delete(program.exp_list, program.exp_list.first);

    program.import := program.dcount;
    import(code.import);

    n := code.dmin - code.dcount;
    IF n > 0 THEN
        INC(code.gsize, n)
    END;
                           (*
    IF target = TARGETS.KOS THEN
        WriteLn("align 16")
    ELSE
        WriteLn("section '.bss' data readable writeable")
    END;

    Write("_bss: rb ");  WriteHexLn(code.gsize);  *)
    BIN.SetParams(program, code.gsize, stack * (1024 * 1024), WCHR(ver DIV 65536), WCHR(ver MOD 65536));

END epilog;


PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target, stack, ver: INTEGER);
BEGIN
    program := BIN.create();
    dllret  := CODE.NewLabel();
    label_import  := CODE.NewLabel();
    stroffs := code.tcount * 4;

    error := FALSE;

    R := REG.Create(push, pop, mov, xchg);

    prolog(code, target, stack);
    translate(code);
    epilog(code, outname, target, stack, ver);

    DISPOSE(R);

    BIN.fixup(program);

    IF target IN {TARGETS.CON, TARGETS.GUI, TARGETS.DLL} THEN
        PE32.write(program, outname, target = TARGETS.CON, target = TARGETS.DLL)
    ELSIF target = TARGETS.KOS THEN
        KOS.write(program, outname)
    END

END CodeGen;


END X86.