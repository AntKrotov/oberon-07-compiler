MODULE AMD64;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT CODE,
	WR := WRITER,
	CHL := CHUNKLISTS,
	MACHINE,
	LISTS,
	PATHS,
	REG,
	C := CONSOLE,
	UTILS,
	mConst := modConstante;

CONST

	rax = REG.R0;  al = rax;
	rcx = REG.R1;  cl = rcx;
	rdx = REG.R2;

	je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H;

	sete = 94H; setne = 95H; setl = 9CH; setge = 9DH; setle = 9EH; setg = 9FH; setc = 92H; setnc = 93H;

TYPE

	COMMAND = CODE.COMMAND;

VAR
	file: WR.tpFile;
	eol:  ARRAY 3 OF CHAR;
	regs, regs8, regs16, regs32:  ARRAY 3, 4 OF CHAR;
	R: REG.REGS;

PROCEDURE WriteChar (c: CHAR);
	BEGIN
		WR.Byte_Write(file, ORD(c))
	END WriteChar;

PROCEDURE Write (s: ARRAY OF CHAR);
	VAR
		i: INTEGER;

	BEGIN
		i := 0;
		WHILE s[i] # 0X DO
			WriteChar(s[i]);
			INC(i)
		END
	END Write;

PROCEDURE WriteLn (s: ARRAY OF CHAR);
	BEGIN
		Write(s);
		Write(eol)
	END WriteLn;

PROCEDURE hexdgt (n: INTEGER): CHAR;
	VAR
		res: CHAR;

	BEGIN
		IF n < 10 THEN
			res := CHR(n + ORD("0"))
		ELSE
			res := CHR(n + ORD("a") - 10)
		END

		RETURN res
	END hexdgt;

PROCEDURE WriteHex (n: INTEGER);
	VAR
		b: BYTE;
		i: INTEGER;

	BEGIN
		Write("0x");
		FOR i := 7 TO 0 BY -1 DO
			b := MACHINE.Byte_Get(n, i);
			WriteChar(hexdgt(b DIV 16));
			WriteChar(hexdgt(b MOD 16))
		END
	END WriteHex;

PROCEDURE WriteHexLn (n: INTEGER);
	BEGIN
		WriteHex(n);
		Write(eol)
	END WriteHexLn;

PROCEDURE WriteByte (b: BYTE);
	BEGIN
		Write("0x");
		WriteChar(hexdgt(b DIV 16));
		WriteChar(hexdgt(b MOD 16))
	END WriteByte;

PROCEDURE oprr (op: ARRAY OF CHAR; reg1, reg2: INTEGER);
	BEGIN
		Write(op); Write(" "); Write(regs[reg1]); Write(","); WriteLn(regs[reg2])
	END oprr;

PROCEDURE isLong (n: INTEGER): BOOLEAN;
		RETURN (n > mConst.max32) OR (n < mConst.min32)
	END isLong;

PROCEDURE movr10c (n: INTEGER);
	VAR
		h, l: INTEGER;

	BEGIN
		IF isLong(n) THEN
			h := ASR(n, 16);
			h := ASR(h, 16);
			l := LSL(n, 16);
			l := LSL(l, 16);
			l := ASR(l, 16);
			l := ASR(l, 16);
			Write("mov r10,"); WriteHexLn(h);
			WriteLn("shl r10,32");
			Write("mov r11,"); WriteHexLn(l);
			WriteLn("shl r11,32");
			WriteLn("shr r11,32");
			WriteLn("or r10,r11")
		ELSE
			Write("mov r10,"); WriteHexLn(n)
		END
	END movr10c;

PROCEDURE oprc (op: ARRAY OF CHAR; reg, n: INTEGER);
	BEGIN
		IF isLong(n) THEN
			movr10c(n);
			Write(op); Write(" "); Write(regs[reg]); WriteLn(",r10")
		ELSE
			Write(op); Write(" "); Write(regs[reg]); Write(","); WriteHexLn(n)
		END
	END oprc;

PROCEDURE opr (op: ARRAY OF CHAR; reg: INTEGER);
	BEGIN
		Write(op); Write(" "); WriteLn(regs[reg])
	END opr;

PROCEDURE mov (reg1, reg2: INTEGER);
	BEGIN
		oprr("mov", reg1, reg2)
	END mov;

PROCEDURE xchg (reg1, reg2: INTEGER);
	BEGIN
		oprr("xchg", reg1, reg2)
	END xchg;

PROCEDURE pop (reg: INTEGER);
	BEGIN
		opr("pop", reg)
	END pop;

PROCEDURE push (reg: INTEGER);
	BEGIN
		opr("push", reg)
	END push;

PROCEDURE CallRTL (pic: BOOLEAN; proc: INTEGER);
	VAR
		label: INTEGER;

	BEGIN
		label := CODE.codes.rtl[proc];

		IF label < 0 THEN
			label := -label;
			IF pic THEN
				ASSERT(FALSE)
			ELSE
				Write("call qword[P"); WriteHex(label); WriteLn("]")
			END
		ELSE
			Write("call L"); WriteHexLn(label)
		END
	END CallRTL;

PROCEDURE log2 (x: INTEGER): INTEGER;
	VAR
		n: INTEGER;

	BEGIN
		ASSERT(x > 0);

		n := 0;
		WHILE ~ODD(x) DO
			x := x DIV 2;
			INC(n)
		END;

		IF x # 1 THEN
			n := -1
		END

		RETURN n
	END log2;

PROCEDURE drop;
	BEGIN
		REG.Drop(R)
	END drop;

PROCEDURE UnOp (VAR reg: INTEGER);
	BEGIN
		REG.UnOp(R, reg)
	END UnOp;

PROCEDURE BinOp (VAR reg1, reg2: INTEGER);
	BEGIN
		REG.BinOp(R, reg1, reg2)
	END BinOp;

PROCEDURE PushAll (NumberOfParameters: INTEGER);
	BEGIN
		REG.PushAll(R);
		R.pushed := R.pushed - NumberOfParameters
	END PushAll;

PROCEDURE movrc (reg, n: INTEGER);
	BEGIN
		oprc("mov", reg, n)
	END movrc;

PROCEDURE test (reg: INTEGER);
	BEGIN
		oprr("test", reg, reg)
	END test;

PROCEDURE cmprc (reg, n: INTEGER);
	BEGIN
		oprc("cmp", reg, n)
	END cmprc;

PROCEDURE addrc (reg, n: INTEGER);
	BEGIN
		oprc("add", reg, n)
	END addrc;

PROCEDURE andrc (reg, n: INTEGER);
	BEGIN
		oprc("and", reg, n)
	END andrc;

PROCEDURE pushc (n: INTEGER);
	BEGIN
		IF isLong(n) THEN
			movr10c(n);
			WriteLn("push r10")
		ELSE
			Write("push "); WriteHexLn(n)
		END
	END pushc;

PROCEDURE cmprr (reg1, reg2: INTEGER);
	BEGIN
		oprr("cmp", reg1, reg2)
	END cmprr;

PROCEDURE not (reg: INTEGER);
	BEGIN
		opr("not", reg)
	END not;

PROCEDURE neg (reg: INTEGER);
	BEGIN
		opr("neg", reg)
	END neg;

PROCEDURE jcc (jmp, label: INTEGER);
	BEGIN
		CASE jmp OF
		|je:   Write("je ")
		|jne:  Write("jne ")
		|jl:   Write("jl ")
		|jge:  Write("jge ")
		|jle:  Write("jle ")
		|jg:   Write("jg ")
		|jb:   Write("jb ")
		END;
		Write("L");
		WriteHexLn(label)
	END jcc;

PROCEDURE setcc (set, reg: INTEGER);
	BEGIN
		CASE set OF
		|sete:   Write("sete ")
		|setne:  Write("setne ")
		|setl:   Write("setl ")
		|setge:  Write("setge ")
		|setle:  Write("setle ")
		|setg:   Write("setg ")
		|setc:   Write("setc ")
		|setnc:  Write("setnc ")
		END;
		WriteLn(regs8[reg])
	END setcc;

PROCEDURE translate (commands: LISTS.LIST; pic: BOOLEAN; stroffs: INTEGER);
	VAR
		cmd, next, next2: COMMAND;

		param1, param2, a, b, n, label: INTEGER;

		reg1, reg2: INTEGER;

		float: REAL;

	BEGIN
		cmd := commands.first(COMMAND);
		WHILE cmd # NIL DO

			param1 := cmd.param1;
			param2 := cmd.param2;

			CASE cmd.opcode OF

			|CODE.opJMP:
				Write("jmp "); Write("L"); WriteHexLn(param1)

			|CODE.opCALL:
				Write("call "); Write("L"); WriteHexLn(param1)

			|CODE.opCALLP:
				UnOp(reg1);
				Write("call "); WriteLn(regs[reg1]);
				drop;
				ASSERT(R.top = -1)

			|CODE.opLABEL:
				Write("L"); WriteHex(param2); WriteLn(":")

			|CODE.opERR:
				CallRTL(pic, CODE._error)

			|CODE.opERRC:
				pushc(param2)

			|CODE.opPRECALL:
				n := param2;
				IF (param1 # 0) & (n # 0) THEN
					WriteLn("sub rsp,8")
				END;
				WHILE n > 0 DO
					WriteLn("sub rsp,8");
					WriteLn("fstp qword[rsp]");
					DEC(n)
				END;
				PushAll(0)

			|CODE.opRESF:
				n := param2;
				IF n > 0 THEN
					Write("fstp qword[rsp+"); WriteHex(n * 8); WriteLn("]");
					INC(n)
				END;

				WHILE n > 0 DO
					WriteLn("fld qword[rsp]");
					WriteLn("add rsp,8");
					DEC(n)
				END

			|CODE.opENTER:
				ASSERT(R.top = -1);

				Write("L"); WriteHex(param1); WriteLn(":");

				WriteLn("push rbp");
				WriteLn("mov rbp,rsp");

				n := param2;
				IF n > 4 THEN
					Write("mov rcx,"); WriteHexLn(n);
					WriteLn("@@: push 0");
					WriteLn("loop @b")
				ELSE
					WHILE n > 0 DO
						WriteLn("push 0");
						DEC(n)
					END
				END

			|CODE.opLEAVE, CODE.opLEAVER, CODE.opLEAVEF:
				IF cmd.opcode = CODE.opLEAVER THEN
					UnOp(reg1);
					IF reg1 # rax THEN
						ASSERT(REG.GetReg(R, rax));
						ASSERT(REG.Exchange(R, reg1, rax));
						drop
					END;
					drop
				END;

				ASSERT(R.top = -1);

				WriteLn("mov rsp,rbp");
				WriteLn("pop rbp");
				Write("ret ");
				IF param2 > 0 THEN
					WriteHex(param2 * 8)
				END;
				WriteLn("")

			|CODE.opSAVES:
				UnOp(reg1);
				drop;
				PushAll(0);
				push(reg1);

				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("push _data+"); WriteHexLn(stroffs + param2)
				END;

				pushc(param1);
				CallRTL(pic, CODE._move)

			|CODE.opSADR:
				next := cmd.next(COMMAND);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					IF (next.opcode = CODE.opPARAM) & (next.param2 = 1) THEN
						Write("push _data+"); WriteHexLn(stroffs + param2);
						cmd := next
					ELSE
						reg1 := REG.GetAnyReg(R);
						Write("mov "); Write(regs[reg1]); Write(",_data+"); WriteHexLn(stroffs + param2)
					END
				END

			|CODE.opLOAD8:
				UnOp(reg1);
				Write("movzx "); Write(regs[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]")

			|CODE.opLOAD16:
				UnOp(reg1);
				Write("movzx "); Write(regs[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]")

			|CODE.opLOAD64:
				UnOp(reg1);
				Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]")

			|CODE.opLLOAD64:
				next := cmd.next(COMMAND);
				n := param2 * 8;
				IF (next.opcode = CODE.opPARAM) & (next.param2 = 1) THEN
					Write("push qword[rbp+"); WriteHex(n); WriteLn("]");
					cmd := next
				ELSE
					reg1 := REG.GetAnyReg(R);
					Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
				END

			|CODE.opLLOAD8:
				reg1 := REG.GetAnyReg(R);
				Write("movzx "); Write(regs[reg1]); Write(",byte[rbp+"); WriteHex(param2 * 8); WriteLn("]")

			|CODE.opLLOAD16:
				n := param2 * 8;
				reg1 := REG.GetAnyReg(R);
				Write("movzx "); Write(regs[reg1]); Write(",word[rbp+"); WriteHex(n); WriteLn("]")

			|CODE.opGLOAD64:
				next := cmd.next(COMMAND);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					IF (next.opcode = CODE.opPARAM) & (next.param2 = 1) THEN
						Write("push qword[GLOB+"); WriteHex(param2); WriteLn("]");
						cmd := next
					ELSE
						reg1 := REG.GetAnyReg(R);
						Write("mov "); Write(regs[reg1]); Write(",qword[GLOB+"); WriteHex(param2); WriteLn("]")
					END
				END

			|CODE.opGLOAD8:
				reg1 := REG.GetAnyReg(R);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("movzx "); Write(regs[reg1]); Write(",byte[GLOB+"); WriteHex(param2); WriteLn("]")
				END

			|CODE.opGLOAD16:
				reg1 := REG.GetAnyReg(R);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("movzx "); Write(regs[reg1]); Write(",word[GLOB+"); WriteHex(param2); WriteLn("]")
				END

			|CODE.opVLOAD64:
				n := param2 * 8;
				reg1 := REG.GetAnyReg(R);
				Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
				Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]")

			|CODE.opVLOAD8:
				n := param2 * 8;
				reg1 := REG.GetAnyReg(R);
				Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
				Write("movzx "); Write(regs[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]")

			|CODE.opVLOAD16:
				n := param2 * 8;
				reg1 := REG.GetAnyReg(R);
				Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
				Write("movzx "); Write(regs[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]")

			|CODE.opLADR:
				n := param2 * 8;
				next := cmd.next(COMMAND);
				IF next.opcode = CODE.opSAVEC THEN
					IF isLong(next.param2) THEN
						movr10c(next.param2);
						Write("mov qword[rbp+"); WriteHex(n); WriteLn("],r10")
					ELSE
						Write("mov qword[rbp+"); WriteHex(n); Write("],"); WriteHexLn(next.param2)
					END;
					cmd := next
				ELSE
					reg1 := REG.GetAnyReg(R);
					Write("lea "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
				END

			|CODE.opGADR:
				next := cmd.next(COMMAND);
				IF next.opcode = CODE.opSAVEC THEN
					IF isLong(next.param2) THEN
						movr10c(next.param2);
						Write("mov qword[GLOB+"); WriteHex(param2); WriteLn("],r10")
					ELSE
						Write("mov qword[GLOB+"); WriteHex(param2); Write("],"); WriteHexLn(next.param2)
					END;
					cmd := next
				ELSE
					reg1 := REG.GetAnyReg(R);
					Write("mov "); Write(regs[reg1]); Write(",GLOB+"); WriteHexLn(param2)
				END

			|CODE.opVADR:
				n := param2 * 8;
				next := cmd.next(COMMAND);
				IF (next.opcode = CODE.opPARAM) & (next.param2 = 1) THEN
					Write("push qword[rbp+"); WriteHex(n); WriteLn("]");
					cmd := next
				ELSE
					reg1 := REG.GetAnyReg(R);
					Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]")
				END

			|CODE.opSAVE8C:
				UnOp(reg1);
				Write("mov byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2);
				drop

			|CODE.opSAVE16C:
				UnOp(reg1);
				Write("mov word["); Write(regs[reg1]); Write("],"); WriteHexLn(param2);
				drop

			|CODE.opSAVEC:
				UnOp(reg1);
				IF isLong(param2) THEN
					movr10c(param2);
					Write("mov qword["); Write(regs[reg1]); WriteLn("],r10")
				ELSE
					Write("mov qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
				END;
				drop

			|CODE.opRSET:
				PushAll(2);
				CallRTL(pic, CODE._set);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opRSETR:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._set);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opRSETL:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._set2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opRSET1:
				UnOp(reg1);
				PushAll(1);
				push(reg1);
				CallRTL(pic, CODE._set);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opINCL:
				PushAll(2);
				CallRTL(pic, CODE._incl)

			|CODE.opEXCL:
				PushAll(2);
				CallRTL(pic, CODE._excl)

			|CODE.opINCLC:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._incl)

			|CODE.opEXCLC:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._excl)

			|CODE.opEQS, CODE.opNES, CODE.opLTS,
			 CODE.opLES, CODE.opGTS, CODE.opGES:
				PushAll(4);
				CASE cmd.opcode OF
				|CODE.opEQS: pushc(0)
				|CODE.opNES: pushc(1)
				|CODE.opLTS: pushc(2)
				|CODE.opLES: pushc(3)
				|CODE.opGTS: pushc(4)
				|CODE.opGES: pushc(5)
				END;
				CallRTL(pic, CODE._strcmp);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opEQS2, CODE.opNES2, CODE.opLTS2,
			 CODE.opLES2, CODE.opGTS2, CODE.opGES2:
				PushAll(4);
				CASE cmd.opcode OF
				|CODE.opEQS2: pushc(0)
				|CODE.opNES2: pushc(1)
				|CODE.opLTS2: pushc(2)
				|CODE.opLES2: pushc(3)
				|CODE.opGTS2: pushc(4)
				|CODE.opGES2: pushc(5)
				END;
				CallRTL(pic, CODE._strcmp2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opEQSW, CODE.opNESW, CODE.opLTSW,
			 CODE.opLESW, CODE.opGTSW, CODE.opGESW:
				PushAll(4);
				CASE cmd.opcode OF
				|CODE.opEQSW: pushc(0)
				|CODE.opNESW: pushc(1)
				|CODE.opLTSW: pushc(2)
				|CODE.opLESW: pushc(3)
				|CODE.opGTSW: pushc(4)
				|CODE.opGESW: pushc(5)
				END;
				CallRTL(pic, CODE._strcmpw);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opEQSW2, CODE.opNESW2, CODE.opLTSW2,
			 CODE.opLESW2, CODE.opGTSW2, CODE.opGESW2:
				PushAll(4);
				CASE cmd.opcode OF
				|CODE.opEQSW2: pushc(0)
				|CODE.opNESW2: pushc(1)
				|CODE.opLTSW2: pushc(2)
				|CODE.opLESW2: pushc(3)
				|CODE.opGTSW2: pushc(4)
				|CODE.opGESW2: pushc(5)
				END;
				CallRTL(pic, CODE._strcmpw2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opINC1:
				UnOp(reg1);
				Write("inc qword["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opDEC1:
				UnOp(reg1);
				Write("dec qword["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opCALLI:
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("call qword[P"); WriteHex(param1); WriteLn("]")
				END

			|CODE.opCONST:
				next := cmd.next(COMMAND);
				IF (next.opcode = CODE.opPARAM) & (next.param2 = 1) THEN
					pushc(param2);
					cmd := next
				ELSE
					reg1 := REG.GetAnyReg(R);
					movrc(reg1, param2)
				END

			|CODE.opGT, CODE.opGE, CODE.opLT,
			 CODE.opLE, CODE.opEQ, CODE.opNE:
				BinOp(reg1, reg2);
				cmprr(reg1, reg2);
				drop;
				drop;

				IF cmd.next(COMMAND).opcode = CODE.opJE THEN
					label := cmd.next(COMMAND).param1;
					CASE cmd.opcode OF
					|CODE.opGT: jcc(jg,  label)
					|CODE.opGE: jcc(jge, label)
					|CODE.opLE: jcc(jle, label)
					|CODE.opLT: jcc(jl,  label)
					|CODE.opEQ: jcc(je,  label)
					|CODE.opNE: jcc(jne, label)
					END;
					cmd := cmd.next(COMMAND)

				ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
					label := cmd.next(COMMAND).param1;
					CASE cmd.opcode OF
					|CODE.opGT: jcc(jle, label)
					|CODE.opGE: jcc(jl,  label)
					|CODE.opLE: jcc(jg,  label)
					|CODE.opLT: jcc(jge, label)
					|CODE.opEQ: jcc(jne, label)
					|CODE.opNE: jcc(je,  label)
					END;
					cmd := cmd.next(COMMAND)

				ELSE
					reg1 := REG.GetAnyReg(R);

					CASE cmd.opcode OF
					|CODE.opGT: setcc(setg,  reg1)
					|CODE.opGE: setcc(setge, reg1)
					|CODE.opLE: setcc(setle, reg1)
					|CODE.opLT: setcc(setl,  reg1)
					|CODE.opEQ: setcc(sete,  reg1)
					|CODE.opNE: setcc(setne, reg1)
					END;

					andrc(reg1, 1)
				END

			|CODE.opGTR, CODE.opLTL, CODE.opGER, CODE.opLEL,
			 CODE.opLER, CODE.opGEL, CODE.opLTR, CODE.opGTL,
			 CODE.opEQR, CODE.opEQL, CODE.opNER, CODE.opNEL:
				UnOp(reg1);
				IF param2 = 0 THEN
					test(reg1)
				ELSE
					cmprc(reg1, param2)
				END;
				drop;

				IF cmd.next(COMMAND).opcode = CODE.opJE THEN
					label := cmd.next(COMMAND).param1;
					CASE cmd.opcode OF
					|CODE.opGTR, CODE.opLTL: jcc(jg,  label)
					|CODE.opGER, CODE.opLEL: jcc(jge, label)
					|CODE.opLER, CODE.opGEL: jcc(jle, label)
					|CODE.opLTR, CODE.opGTL: jcc(jl,  label)
					|CODE.opEQR, CODE.opEQL: jcc(je,  label)
					|CODE.opNER, CODE.opNEL: jcc(jne, label)
					END;
					cmd := cmd.next(COMMAND)

				ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
					label := cmd.next(COMMAND).param1;
					CASE cmd.opcode OF
					|CODE.opGTR, CODE.opLTL: jcc(jle, label)
					|CODE.opGER, CODE.opLEL: jcc(jl,  label)
					|CODE.opLER, CODE.opGEL: jcc(jg,  label)
					|CODE.opLTR, CODE.opGTL: jcc(jge, label)
					|CODE.opEQR, CODE.opEQL: jcc(jne, label)
					|CODE.opNER, CODE.opNEL: jcc(je,  label)
					END;
					cmd := cmd.next(COMMAND)

				ELSE
					reg1 := REG.GetAnyReg(R);

					CASE cmd.opcode OF
					|CODE.opGTR, CODE.opLTL: setcc(setg,  reg1)
					|CODE.opGER, CODE.opLEL: setcc(setge, reg1)
					|CODE.opLER, CODE.opGEL: setcc(setle, reg1)
					|CODE.opLTR, CODE.opGTL: setcc(setl,  reg1)
					|CODE.opEQR, CODE.opEQL: setcc(sete,  reg1)
					|CODE.opNER, CODE.opNEL: setcc(setne, reg1)
					END;

					andrc(reg1, 1)
				END;

			|CODE.opCODE:
				Write("db "); WriteByte(param2); WriteLn("")

			|CODE.opPUSHIP:
				reg1 := REG.GetAnyReg(R);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("mov "); Write(regs[reg1]); Write(",qword[P"); WriteHex(param2); WriteLn("]")
				END

			|CODE.opPARAM:
				n := param2;
				IF n = 1 THEN
					UnOp(reg1);
					push(reg1);
					drop
				ELSE
					ASSERT(R.top + 1 <= n);
					PushAll(n)
				END

			|CODE.opRES:
				ASSERT(R.top = -1);
				ASSERT(REG.GetReg(R, rax));
				n := param2;
				WHILE n > 0 DO
					WriteLn("fld qword[rsp]");
					WriteLn("add rsp,8");
					DEC(n)
				END

			|CODE.opACC:
				IF (R.top # 0) OR (R.stk[0] # rax) THEN
					PushAll(0);
					ASSERT(REG.GetReg(R, rax));
					pop(rax);
					DEC(R.pushed)
				END

			|CODE.opJNZ:
				UnOp(reg1);
				test(reg1);
				jcc(jne, param1)

			|CODE.opJZ:
				UnOp(reg1);
				test(reg1);
				jcc(je, param1)

			|CODE.opJE, CODE.opJNE:
				UnOp(reg1);
				drop;
				test(reg1);
				IF cmd.opcode = CODE.opJE THEN
					jcc(jne, param1)
				ELSE
					jcc(je, param1)
				END

			|CODE.opIN:
				PushAll(2);
				CallRTL(pic, CODE._in);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opINR:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._in);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opINL:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._in2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opNOT:
				UnOp(reg1);
				drop;
				test(reg1);
				reg1 := REG.GetAnyReg(R);
				setcc(sete, reg1);
				andrc(reg1, 1)

			|CODE.opORD:
				UnOp(reg1);
				drop;
				test(reg1);
				reg1 := REG.GetAnyReg(R);
				setcc(setne, reg1);
				andrc(reg1, 1)

			|CODE.opABS:
				UnOp(reg1);
				test(reg1);
				WriteLn("jge @f");
				neg(reg1);
				WriteLn("@@:")

			|CODE.opEQB, CODE.opNEB:
				BinOp(reg1, reg2);
				drop;
				drop;

				test(reg1);
				WriteLn("je @f");
				movrc(reg1, 1);
				WriteLn("@@:");
				test(reg2);
				WriteLn("je @f");
				movrc(reg2, 1);
				WriteLn("@@:");

				cmprr(reg1, reg2);
				reg1 := REG.GetAnyReg(R);
				IF cmd.opcode = CODE.opEQB THEN
					setcc(sete, reg1)
				ELSE
					setcc(setne, reg1)
				END;
				andrc(reg1, 1)

			|CODE.opLOADF:
				UnOp(reg1);
				Write("fld qword["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opPUSHF:
				WriteLn("sub rsp,8");
				WriteLn("fstp qword[rsp]")

			|CODE.opCONSTF:
				float := cmd(CODE.COMMANDF).float;
				IF float = 0.0 THEN
					WriteLn("fldz")
				ELSIF float = 1.0 THEN
					WriteLn("fld1")
				ELSIF float = -1.0 THEN
					WriteLn("fld1");
					WriteLn("fchs")
				ELSE
					UTILS.splitf(float, a, b);
					Write("mov r10,"); WriteHexLn(MACHINE.Int32To64(b));
					WriteLn("shl r10,32");
					Write("mov r11,"); WriteHexLn(MACHINE.Int32To64(a));
					WriteLn("shl r11,32");
					WriteLn("shr r11,32");
					WriteLn("or r10,r11");
					WriteLn("push r10");
					WriteLn("fld qword[rsp]");
					WriteLn("add rsp,8")
				END

			|CODE.opSAVEF:
				UnOp(reg1);
				Write("fstp qword["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opADDF, CODE.opADDFI:
				WriteLn("faddp st1,st")

			|CODE.opSUBF:
				WriteLn("fsubp st1,st")

			|CODE.opSUBFI:
				WriteLn("fsubrp st1,st")

			|CODE.opMULF:
				WriteLn("fmulp st1,st")

			|CODE.opDIVF:
				WriteLn("fdivp st1,st")

			|CODE.opDIVFI:
				WriteLn("fdivrp st1,st")

			|CODE.opUMINF:
				WriteLn("fchs")

			|CODE.opFABS:
				WriteLn("fabs")

			|CODE.opFLT:
				UnOp(reg1);
				push(reg1);
				WriteLn("fild qword[rsp]");
				pop(reg1);
				drop

			|CODE.opFLOOR:
				reg1 := REG.GetAnyReg(R);
				WriteLn("sub rsp,16");
				WriteLn("fstcw word[rsp+8]");
				WriteLn("fstcw word[rsp+10]");
				WriteLn("and word[rsp+8],1111001111111111b");
				WriteLn("or word[rsp+8],0000010000000000b");
				WriteLn("fldcw word[rsp+8]");
				WriteLn("frndint");
				WriteLn("fistp qword[rsp]");
				pop(reg1);
				WriteLn("fldcw word[rsp+2]");
				WriteLn("add rsp,8");

			|CODE.opEQF, CODE.opEQFI:
				ASSERT(REG.GetReg(R, rax));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(sete, al);
				andrc(rax, 1);
				WriteLn("@@:")

			|CODE.opNEF, CODE.opNEFI:
				ASSERT(REG.GetReg(R, rax));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(setne, al);
				andrc(rax, 1);
				WriteLn("@@:")

			|CODE.opLTF, CODE.opGTFI:
				ASSERT(REG.GetReg(R, rax));
				ASSERT(REG.GetReg(R, rcx));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(setc, cl);
				setcc(sete, al);
				WriteLn("shl rax,8");
				WriteLn("add al,cl");
				test(rax);
				setcc(sete, al);
				andrc(rax, 1);
				WriteLn("@@:");
				drop

			|CODE.opGTF, CODE.opLTFI:
				ASSERT(REG.GetReg(R, rax));
				ASSERT(REG.GetReg(R, rcx));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(setc, cl);
				setcc(sete, al);
				WriteLn("shl rax,8");
				WriteLn("add al,cl");
				cmprc(rax, 1);
				setcc(sete, al);
				andrc(rax, 1);
				WriteLn("@@:");
				drop

			|CODE.opLEF, CODE.opGEFI:
				ASSERT(REG.GetReg(R, rax));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(setnc, al);
				andrc(rax, 1);
				WriteLn("@@:")

			|CODE.opGEF, CODE.opLEFI:
				ASSERT(REG.GetReg(R, rax));
				ASSERT(REG.GetReg(R, rcx));
				WriteLn("fucompp");
				WriteLn("fstsw ax");
				WriteLn("sahf");
				movrc(rax, 0);
				WriteLn("jp @f");
				setcc(setc, al);
				setcc(sete, cl);
				WriteLn("add al,cl");
				WriteLn("cmp al,1");
				setcc(sete, al);
				andrc(rax, 1);
				WriteLn("@@:");
				drop

			|CODE.opINF:
				WriteLn("mov r10,0x7ff00000");
				WriteLn("shl r10,32");
				WriteLn("push r10");
				WriteLn("fld qword[rsp]");
				WriteLn("add rsp,8")

			|CODE.opPACKC:
				UnOp(reg1);
				pushc(param2);
				WriteLn("fild qword[rsp]");
				Write("fld qword["); Write(regs[reg1]); WriteLn("]");
				WriteLn("fscale");
				Write("fstp qword["); Write(regs[reg1]); WriteLn("]");
				WriteLn("fistp qword[rsp]");
				pop(reg1);
				drop

			|CODE.opMULSC:
				UnOp(reg1);
				andrc(reg1, param2)

			|CODE.opDIVSC:
				UnOp(reg1);
				oprc("xor", reg1, param2)

			|CODE.opADDSL, CODE.opADDSR:
				UnOp(reg1);
				oprc("or", reg1, param2)

			|CODE.opSUBSL:
				UnOp(reg1);
				not(reg1);
				oprc("and", reg1, param2)

			|CODE.opSUBSR:
				UnOp(reg1);
				oprc("and", reg1, ORD(-BITS(param2)))

			|CODE.opMULS:
				BinOp(reg1, reg2);
				oprr("and", reg1, reg2);
				drop

			|CODE.opDIVS:
				BinOp(reg1, reg2);
				oprr("xor", reg1, reg2);
				drop

			|CODE.opUMINS:
				UnOp(reg1);
				not(reg1)

			|CODE.opCOPY:
				PushAll(2);
				pushc(param2);
				CallRTL(pic, CODE._move)

			|CODE.opMOVE:
				PushAll(3);
				CallRTL(pic, CODE._move2)

			|CODE.opCOPYA:
				PushAll(4);
				pushc(param2);
				CallRTL(pic, CODE._arrcpy);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opCOPYS:
				PushAll(4);
				pushc(param2);
				CallRTL(pic, CODE._strcpy)

			|CODE.opCOPYS2:
				PushAll(4);
				pushc(param2);
				CallRTL(pic, CODE._strcpy2)

			|CODE.opROT:
				PushAll(0);
				WriteLn("push rsp");
				pushc(param2);
				CallRTL(pic, CODE._rot)

			|CODE.opNEW:
				PushAll(1);
				n := param2 + 16;
				ASSERT(MACHINE.IsAlign(n, 32));
				pushc(n);
				pushc(param1);
				CallRTL(pic, CODE._new)

			|CODE.opDISP:
				PushAll(1);
				CallRTL(pic, CODE._dispose)

			|CODE.opPUSHT:
				UnOp(reg1);
				reg2 := REG.GetAnyReg(R);
				Write("mov "); Write(regs[reg2]); Write(",qword["); Write(regs[reg1]); WriteLn("-8]")

			|CODE.opISREC:
				PushAll(2);
				pushc(param2);
				CallRTL(pic, CODE._isrec);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opIS:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._is);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opTYPEGR:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._guardrec);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opTYPEGP:
				UnOp(reg1);
				PushAll(0);
				push(reg1);
				pushc(param2);
				CallRTL(pic, CODE._guard);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opTYPEGD:
				UnOp(reg1);
				PushAll(0);
				Write("push qword["); Write(regs[reg1]); WriteLn("-8]");
				pushc(param2);
				CallRTL(pic, CODE._guardrec);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opCASET:
				push(rcx);
				push(rcx);
				pushc(param2);
				CallRTL(pic, CODE._guardrec);
				pop(rcx);
				test(rax);
				jcc(jne, param1)

			|CODE.opSAVEP:
				UnOp(reg1);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("mov qword["); Write(regs[reg1]); Write("],L"); WriteHexLn(param2)
				END;
				drop

			|CODE.opPUSHP:
				reg1 := REG.GetAnyReg(R);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("mov "); Write(regs[reg1]); Write(",L"); WriteHexLn(param2)
				END

			|CODE.opINC:
				BinOp(reg1, reg2);
				Write("add qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
				drop;
				drop

			|CODE.opDEC:
				BinOp(reg1, reg2);
				Write("sub qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
				drop;
				drop

			|CODE.opINCC:
				UnOp(reg1);
				IF isLong(param2) THEN
					movr10c(param2);
					Write("add qword["); Write(regs[reg1]); WriteLn("],r10")
				ELSE
					Write("add qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
				END;
				drop

			|CODE.opDECC:
				UnOp(reg1);
				IF isLong(param2) THEN
					movr10c(param2);
					Write("sub qword["); Write(regs[reg1]); WriteLn("],r10")
				ELSE
					Write("sub qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
				END;
				drop

			|CODE.opDROP:
				UnOp(reg1);
				drop

			|CODE.opSAVE, CODE.opSAVE64:
				BinOp(reg1, reg2);
				Write("mov qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
				drop;
				drop

			|CODE.opSAVE8:
				BinOp(reg1, reg2);
				Write("mov byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2]);
				drop;
				drop

			|CODE.opSAVE16:
				BinOp(reg1, reg2);
				Write("mov word["); Write(regs[reg1]); Write("],"); WriteLn(regs16[reg2]);
				drop;
				drop

			|CODE.opMIN:
				BinOp(reg1, reg2);
				cmprr(reg1, reg2);
				WriteLn("jle @f");
				mov(reg1, reg2);
				WriteLn("@@:");
				drop

			|CODE.opMAX:
				BinOp(reg1, reg2);
				cmprr(reg1, reg2);
				WriteLn("jge @f");
				mov(reg1, reg2);
				WriteLn("@@:");
				drop

			|CODE.opMINC:
				UnOp(reg1);
				cmprc(reg1, param2);
				WriteLn("jle @f");
				movrc(reg1, param2);
				WriteLn("@@:")

			|CODE.opMAXC:
				UnOp(reg1);
				cmprc(reg1, param2);
				WriteLn("jge @f");
				movrc(reg1, param2);
				WriteLn("@@:")

			|CODE.opSBOOL:
				UnOp(reg1);
				drop;
				test(reg1);
				reg1 := REG.GetAnyReg(R);
				setcc(setne, reg1);
				BinOp(reg1, reg2);
				Write("mov byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2]);
				drop;
				drop

			|CODE.opSBOOLC:
				UnOp(reg1);
				Write("mov byte["); Write(regs[reg1]); Write("],"); WriteHexLn(ORD(param2 # 0));
				drop

			|CODE.opODD:
				UnOp(reg1);
				andrc(reg1, 1)

			|CODE.opUMINUS:
				UnOp(reg1);
				neg(reg1)

			|CODE.opADD:
				BinOp(reg1, reg2);
				oprr("add", reg1, reg2);
				drop

			|CODE.opSUB:
				BinOp(reg1, reg2);
				oprr("sub", reg1, reg2);
				drop

			|CODE.opSUBR, CODE.opSUBL:
				UnOp(reg1);
				n := param2;
				IF n = 1 THEN
					opr("dec", reg1)
				ELSIF n = -1 THEN
					opr("inc", reg1)
				ELSIF n # 0 THEN
					oprc("sub", reg1, n)
				END;
				IF cmd.opcode = CODE.opSUBL THEN
					neg(reg1)
				END

			|CODE.opADDL, CODE.opADDR:
				next := cmd.next(COMMAND);
				IF next.opcode = CODE.opLOAD64 THEN
					next2 := next.next(COMMAND);
					UnOp(reg1);
					n := param2;

					IF (next2.opcode = CODE.opPARAM) & (next2.param2 = 1) THEN

						IF isLong(n) THEN
							oprc("add", reg1, n);
							Write("push qword["); Write(regs[reg1]); WriteLn("]")
						ELSE
							Write("push qword["); Write(regs[reg1]); Write("+"); WriteHex(n); WriteLn("]")
						END;

						drop;
						cmd := next2
					ELSE

						IF isLong(n) THEN
							movr10c(n);
							Write("add r10,"); WriteLn(regs[reg1]);
							Write("mov "); Write(regs[reg1]); WriteLn(",qword[r10]")
						ELSE
							Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); Write("+"); WriteHex(n); WriteLn("]")
						END;

						cmd := next
					END

				ELSIF next.opcode = CODE.opLOAD8 THEN
					UnOp(reg1);
					n := param2;

					IF isLong(n) THEN
						movr10c(n);
						Write("add r10,"); WriteLn(regs[reg1]);
						Write("movzx "); Write(regs[reg1]); WriteLn(",byte[r10]")
					ELSE
						Write("movzx "); Write(regs[reg1]); Write(",byte["); Write(regs[reg1]); Write("+"); WriteHex(n); WriteLn("]")
					END;

					cmd := next
				ELSE
					IF param2 # 0 THEN
						UnOp(reg1);
						IF param2 = 1 THEN
							opr("inc", reg1)
						ELSIF param2 = -1 THEN
							opr("dec", reg1)
						ELSE
							addrc(reg1, param2)
						END
					END
				END

			|CODE.opDIV:
				PushAll(2);
				CallRTL(pic, CODE._div);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opDIVR:
				a := param2;
				IF a > 1 THEN
					n := log2(a)
				ELSIF a < -1 THEN
					n := log2(-a)
				ELSE
					n := -1
				END;

				IF a = 1 THEN

				ELSIF a = -1 THEN
					UnOp(reg1);
					neg(reg1)
				ELSE
					IF n > 0 THEN
						UnOp(reg1);

						IF a < 0 THEN
							reg2 := REG.GetAnyReg(R);
							mov(reg2, reg1);
							oprc("sar", reg1, n);
							oprr("sub", reg1, reg2);
							drop
						ELSE
							oprc("sar", reg1, n)
						END

					ELSE
						PushAll(1);
						pushc(param2);
						CallRTL(pic, CODE._div);
						ASSERT(REG.GetReg(R, rax))
					END
				END

			|CODE.opDIVL:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._div2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opMOD:
				PushAll(2);
				CallRTL(pic, CODE._mod);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opMODR:
				a := param2;
				IF a > 1 THEN
					n := log2(a)
				ELSIF a < -1 THEN
					n := log2(-a)
				ELSE
					n := -1
				END;

				IF ABS(a) = 1 THEN
					UnOp(reg1);
					oprr("xor", reg1, reg1);
				ELSE
					IF n > 0 THEN
						UnOp(reg1);
						andrc(reg1, ABS(a) - 1);

						IF a < 0 THEN
							test(reg1);
							WriteLn("je @f");
							addrc(reg1, a);
							WriteLn("@@:")
						END

					ELSE
						PushAll(1);
						pushc(param2);
						CallRTL(pic, CODE._mod);
						ASSERT(REG.GetReg(R, rax))
					END
				END

			|CODE.opMODL:
				PushAll(1);
				pushc(param2);
				CallRTL(pic, CODE._mod2);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opMUL:
				BinOp(reg1, reg2);
				oprr("imul", reg1, reg2);
				drop

			|CODE.opMULC:
				UnOp(reg1);

				a := param2;
				IF a > 1 THEN
					n := log2(a)
				ELSIF a < -1 THEN
					n := log2(-a)
				ELSE
					n := -1
				END;

				IF a = 1 THEN

				ELSIF a = -1 THEN
					neg(reg1)
				ELSIF a = 0 THEN
					oprr("xor", reg1, reg1)
				ELSE
					IF n > 0 THEN
						IF a < 0 THEN
							neg(reg1)
						END;
						oprc("shl", reg1, n)
					ELSE
						oprc("imul", reg1, a)
					END
				END

			|CODE.opADDS:
				BinOp(reg1, reg2);
				oprr("or", reg1, reg2);
				drop

			|CODE.opSUBS:
				BinOp(reg1, reg2);
				not(reg2);
				oprr("and", reg1, reg2);
				drop

			|CODE.opNOP:

			|CODE.opSWITCH:
				UnOp(reg1);
				IF param2 = 0 THEN
					reg2 := rax
				ELSE
					reg2 := rcx
				END;
				IF reg1 # reg2 THEN
					ASSERT(REG.GetReg(R, reg2));
					ASSERT(REG.Exchange(R, reg1, reg2));
					drop
				END;
				drop

			|CODE.opENDSW:

			|CODE.opCASEL:
				cmprc(rax, param1);
				jcc(jl, param2)

			|CODE.opCASER:
				cmprc(rax, param1);
				jcc(jg, param2)

			|CODE.opCASELR:
				cmprc(rax, param1);
				jcc(jl, param2);
				jcc(jg, cmd(CODE.COMMAND3).param3)

			|CODE.opASR, CODE.opROR, CODE.opLSL, CODE.opLSR:
				UnOp(reg1);
				IF reg1 # rcx THEN
					ASSERT(REG.GetReg(R, rcx));
					ASSERT(REG.Exchange(R, reg1, rcx));
					drop
				END;

				BinOp(reg1, reg2);
				ASSERT(reg2 = rcx);
				CASE cmd.opcode OF
				|CODE.opASR: Write("sar ")
				|CODE.opROR: Write("ror ")
				|CODE.opLSL: Write("shl ")
				|CODE.opLSR: Write("shr ")
				END;
				Write(regs[reg1]); WriteLn(",cl");
				drop

			|CODE.opASR1, CODE.opROR1, CODE.opLSL1, CODE.opLSR1:
				UnOp(reg1);
				IF reg1 # rcx THEN
					ASSERT(REG.GetReg(R, rcx));
					ASSERT(REG.Exchange(R, reg1, rcx));
					drop
				END;

				reg1 := REG.GetAnyReg(R);

				movrc(reg1, param2);

				BinOp(reg1, reg2);
				ASSERT(reg1 = rcx);
				CASE cmd.opcode OF
				|CODE.opASR1: Write("sar ")
				|CODE.opROR1: Write("ror ")
				|CODE.opLSL1: Write("shl ")
				|CODE.opLSR1: Write("shr ")
				END;
				Write(regs[reg2]); WriteLn(",cl");
				drop;
				drop;
				ASSERT(REG.GetReg(R, reg2))

			|CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
				UnOp(reg1);
				n := ORD(BITS(param2) * {0..5});

				CASE cmd.opcode OF
				|CODE.opASR2: oprc("sar", reg1, n)
				|CODE.opROR2: oprc("ror", reg1, n)
				|CODE.opLSL2: oprc("shl", reg1, n)
				|CODE.opLSR2: oprc("shr", reg1, n)
				END;

			|CODE.opGET:
				BinOp(reg1, reg2);
				drop;
				drop;

				CASE param2 OF
				|1:
					Write("mov "); Write(regs8[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]");
					Write("mov byte["); Write(regs[reg2]); Write("],"); WriteLn(regs8[reg1])

				|2:
					Write("mov "); Write(regs16[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]");
					Write("mov word["); Write(regs[reg2]); Write("],"); WriteLn(regs16[reg1])

				|4:
					Write("mov "); Write(regs32[reg1]); Write(",dword["); Write(regs[reg1]); WriteLn("]");
					Write("mov dword["); Write(regs[reg2]); Write("],"); WriteLn(regs32[reg1])

				|8:
					Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]");
					Write("mov qword["); Write(regs[reg2]); Write("],"); WriteLn(regs[reg1])

				END

			|CODE.opCHKIDX:
				UnOp(reg1);
				cmprc(reg1, param2);
				jcc(jb, param1)

			|CODE.opCHKIDX2:
				BinOp(reg1, reg2);
				IF param2 # -1 THEN
					cmprr(reg2, reg1);
					mov(reg1, reg2);
					drop;
					jcc(jb, param1)
				ELSE
					INCL(R.regs, reg1);
					DEC(R.top);
					R.stk[R.top] := reg2
				END

			|CODE.opLENGTH:
				PushAll(2);
				CallRTL(pic, CODE._length);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opLENGTHW:
				PushAll(2);
				CallRTL(pic, CODE._lengthw);
				ASSERT(REG.GetReg(R, rax))

			|CODE.opLEN:
				n := param2;
				UnOp(reg1);
				drop;
				EXCL(R.regs, reg1);

				WHILE n > 0 DO
					UnOp(reg2);
					drop;
					DEC(n)
				END;

				INCL(R.regs, reg1);
				ASSERT(REG.GetReg(R, reg1))

			|CODE.opCHR:
				UnOp(reg1);
				andrc(reg1, 255)

			|CODE.opWCHR:
				UnOp(reg1);
				andrc(reg1, 65535)

			|CODE.opEQP, CODE.opNEP, CODE.opEQIP, CODE.opNEIP:
				UnOp(reg1);
				CASE cmd.opcode OF
				|CODE.opEQP, CODE.opNEP:
					IF pic THEN
						ASSERT(FALSE)
					ELSE
						Write("cmp "); Write(regs[reg1]); Write(",L"); WriteHexLn(param1)
					END

				|CODE.opEQIP, CODE.opNEIP:
					IF pic THEN
						ASSERT(FALSE)
					ELSE
						Write("cmp "); Write(regs[reg1]); Write(",qword[P"); WriteHex(param1); WriteLn("]")
					END

				END;
				drop;
				reg1 := REG.GetAnyReg(R);

				CASE cmd.opcode OF
				|CODE.opEQP, CODE.opEQIP: setcc(sete,  reg1)
				|CODE.opNEP, CODE.opNEIP: setcc(setne, reg1)
				END;

				andrc(reg1, 1)

			|CODE.opINC1B:
				UnOp(reg1);
				Write("inc byte["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opDEC1B:
				UnOp(reg1);
				Write("dec byte["); Write(regs[reg1]); WriteLn("]");
				drop

			|CODE.opINCCB:
				UnOp(reg1);
				Write("add byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2 MOD 256);
				drop

			|CODE.opDECCB:
				UnOp(reg1);
				Write("sub byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2 MOD 256);
				drop

			|CODE.opINCB, CODE.opDECB:
				BinOp(reg1, reg2);

				IF cmd.opcode = CODE.opINCB THEN
					Write("add byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2])
				ELSE
					Write("sub byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2])
				END;

				drop;
				drop

			|CODE.opSAVEIP:
				UnOp(reg1);
				IF pic THEN
					ASSERT(FALSE)
				ELSE
					Write("push qword[P"); WriteHex(param2); WriteLn("]");
					Write("pop qword["); Write(regs[reg1]); WriteLn("]")
				END;
				drop

			|CODE.opCLEANUP:
				n := param2 * 8;
				IF n # 0 THEN
					Write("add rsp,"); WriteHexLn(n)
				END

			|CODE.opPACK:
				BinOp(reg1, reg2);
				push(reg2);
				WriteLn("fild qword[rsp]");
				Write("fld qword[");  Write(regs[reg1]); WriteLn("]");
				WriteLn("fscale");
				Write("fstp qword["); Write(regs[reg1]); WriteLn("]");
				WriteLn("fistp qword[rsp]");
				pop(reg2);
				drop;
				drop

			|CODE.opUNPK:
				BinOp(reg1, reg2);
				Write("fld qword[");  Write(regs[reg1]); WriteLn("]");
				WriteLn("fxtract");
				Write("fstp qword["); Write(regs[reg1]); WriteLn("]");
				Write("fistp dword["); Write(regs[reg2]); WriteLn("]");
				drop;
				drop

		  (*
			|CODE.opLLOAD32:
			|CODE.opVLOAD32:
			|CODE.opGLOAD32:
			|CODE.opLOAD32:
			|CODE.opSAVE32:
			*)

			ELSE
				C.Int(cmd.opcode); C.Ln; UTILS.Exit(0)
			END;

			cmd := cmd.next(COMMAND)
		END
	END translate;

PROCEDURE prolog (code: CODE.CODES; pic: BOOLEAN);
	BEGIN
		WriteLn("format PE64 CONSOLE");
		WriteLn("stack 1024*1024");
		WriteLn("entry start");
		WriteLn("section '.text' code readable executable");
		WriteLn("start:");
		WriteLn("sub rsp,40");
		pushc(0);
		pushc(0);
		WriteLn("push TYPES");
		pushc(CHL.Length(code.types));
		WriteLn("push MODNAME");
		CallRTL(pic, CODE._init)
	END prolog;

PROCEDURE epilog (code: CODE.CODES; modname: ARRAY OF CHAR; pic: BOOLEAN);
	VAR
		i: INTEGER;


		PROCEDURE import (code: CODE.CODES);
		VAR
			lib: CODE.IMPORT_LIB;
			proc: CODE.IMPORT_PROC;
			n: INTEGER;

		BEGIN
			WriteLn("section '.idata' import data readable writeable");
			lib := code.import.first(CODE.IMPORT_LIB);
			n := 0;
			WHILE lib # NIL DO
				Write("dd 0,0,0,RVA lib_name"); WriteHex(n); Write(",RVA lib_table"); WriteHexLn(n);
				lib := lib.next(CODE.IMPORT_LIB);
				INC(n)
			END;
			WriteLn("dd 0,0,0,0,0");

			lib := code.import.first(CODE.IMPORT_LIB);
			n := 0;
			WHILE lib # NIL DO
				Write("lib_table"); WriteHex(n); WriteLn(":");
				proc := lib.procs.first(CODE.IMPORT_PROC);
				WHILE proc # NIL DO
					Write("P"); WriteHex(proc.label); Write(" dq RVA N"); WriteHexLn(proc.label);
					proc := proc.next(CODE.IMPORT_PROC)
				END;
				WriteLn("dq 0");
				lib := lib.next(CODE.IMPORT_LIB);
				INC(n)
			END;

			lib := code.import.first(CODE.IMPORT_LIB);
			n := 0;
			WHILE lib # NIL DO
				Write("lib_name"); WriteHex(n); Write(" db '"); Write(lib.name); WriteLn("',0");
				lib := lib.next(CODE.IMPORT_LIB);
				INC(n)
			END;

			lib := code.import.first(CODE.IMPORT_LIB);
			n := 0;
			WHILE lib # NIL DO
				proc := lib.procs.first(CODE.IMPORT_PROC);
				WHILE proc # NIL DO
					Write("N"); WriteHex(proc.label); WriteLn(" dw 0");
					Write("db '"); Write(proc.name); WriteLn("',0");
					proc := proc.next(CODE.IMPORT_PROC)
				END;
				lib := lib.next(CODE.IMPORT_LIB);
				INC(n)
			END

		END import;

	BEGIN
		pushc(0);
		CallRTL(pic, CODE._exit);

		WriteLn("section '.data' data readable writeable");
		WriteLn("_data:");
		WriteLn("TYPES:");
		i := 0;
		WHILE i < CHL.Length(code.types) DO
			IF i MOD 4 = 0 THEN
				WriteLn("");
				Write("dq ")
			ELSE
				Write(",")
			END;
			WriteHex(CHL.GetInt(code.types, i));
			INC(i)
		END;

		WriteLn("");
		WriteLn("STRINGS:");
		i := 0;
		WHILE i < CHL.Length(code.data) DO
			IF i MOD 12 = 0 THEN
				WriteLn("");
				Write("db ")
			ELSE
				Write(",")
			END;
			WriteByte(CHL.GetByte(code.data, i));
			INC(i)
		END;

		WriteLn("");
		Write("MODNAME: db '"); Write(modname); Write(".exe"); WriteLn("',0");

		WriteLn("section '.bss' data readable writeable");
		Write("GLOB: rb "); WriteHexLn(code.bss);

		import(code)
	END epilog;

PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target, stack, base, ver: INTEGER; pic, reloc: BOOLEAN);
	VAR
		path, modname, ext: PATHS.tPath;

	BEGIN

		eol[0] := 0DX;
		eol[1] := 0AX;
		eol[2] := 0X;

		regs[rax] := "rax";
		regs[rcx] := "rcx";
		regs[rdx] := "rdx";

		regs8[rax] := "al";
		regs8[rcx] := "cl";
		regs8[rdx] := "dl";

		regs16[rax] := "ax";
		regs16[rcx] := "cx";
		regs16[rdx] := "dx";

		regs32[rax] := "eax";
		regs32[rcx] := "ecx";
		regs32[rdx] := "edx";

		file := WR.Create(outname);
		PATHS.Split(outname, path, modname, ext);

		R := REG.Create(push, pop, mov, xchg);

		pic := FALSE;
		prolog(code, pic);
		translate(code.commands, pic, CHL.Length(code.types) * 8);
		epilog(code, modname, pic);
		WR.Close(file)

	END CodeGen;

END AMD64.
