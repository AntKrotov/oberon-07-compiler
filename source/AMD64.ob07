(*
    BSD 2-Clause License

    Copyright (c) 2018, 2019, Anton Krotov
    All rights reserved.
*)

MODULE AMD64;

IMPORT CODE, WR := WRITER, CHL := CHUNKLISTS, MACHINE, LISTS, PATHS, REG, (*C := CONSOLE,*) UTILS, mConst := CONSTANTS;


CONST

    rax = REG.R0;
    r10 = REG.R10;
    r11 = REG.R11;

    rcx = REG.R1;
    rdx = REG.R2;
    r8 = REG.R8;
    r9 = REG.R9;

    je = 84H; jne = 85H; jl = 8CH; jge = 8DH; jle = 8EH; jg = 8FH; jb = 82H;

    sete = 94H; setne = 95H; setl = 9CH; setge = 9DH; setle = 9EH; setg = 9FH; setc = 92H; setnc = 93H;


TYPE

    COMMAND = CODE.COMMAND;

    Number = POINTER TO RECORD (LISTS.ITEM) value: INTEGER END;


VAR

    file: WR.FILE;

    eol:  ARRAY 3 OF CHAR;

    regs, regs8, regs16, regs32:  ARRAY 16, 5 OF CHAR;

    R: REG.REGS;

    Numbers: LISTS.LIST;
    Numbers_Count: INTEGER;


PROCEDURE WriteChar (c: CHAR);
BEGIN
    WR.WriteByte(file, ORD(c))
END WriteChar;


PROCEDURE Write (s: ARRAY OF CHAR);
VAR
    i: INTEGER;

BEGIN
    i := 0;
    WHILE s[i] # 0X DO
        WriteChar(s[i]);
        INC(i)
    END
END Write;


PROCEDURE WriteLn (s: ARRAY OF CHAR);
BEGIN
    Write(s);
    Write(eol)
END WriteLn;


PROCEDURE hexdgt (n: INTEGER): CHAR;
VAR
    res: CHAR;

BEGIN
    IF n < 10 THEN
        res := CHR(n + ORD("0"))
    ELSE
        res := CHR(n + ORD("a") - 10)
    END

    RETURN res
END hexdgt;


PROCEDURE WriteHex (n: INTEGER);
VAR
    b: BYTE;
    i: INTEGER;

BEGIN
    Write("0x");
    FOR i := 7 TO 0 BY -1 DO
        b := MACHINE.Byte(n, i);
        WriteChar(hexdgt(b DIV 16));
        WriteChar(hexdgt(b MOD 16))
    END
END WriteHex;


PROCEDURE WriteHexLn (n: INTEGER);
BEGIN
    WriteHex(n);
    Write(eol)
END WriteHexLn;


PROCEDURE WriteByte (b: BYTE);
BEGIN
    Write("0x");
    WriteChar(hexdgt(b DIV 16));
    WriteChar(hexdgt(b MOD 16))
END WriteByte;


PROCEDURE oprr (op: ARRAY OF CHAR; reg1, reg2: INTEGER);
BEGIN
    Write(op); Write(" "); Write(regs[reg1]); Write(","); WriteLn(regs[reg2])
END oprr;


PROCEDURE isLong (n: INTEGER): BOOLEAN;
    RETURN (n > MACHINE.max32) OR (n < MACHINE.min32)
END isLong;


PROCEDURE NewNumber (value: INTEGER);
VAR
    number: Number;

BEGIN
    NEW(number);
    number.value := value;
    LISTS.push(Numbers, number);
    INC(Numbers_Count)
END NewNumber;


PROCEDURE oprc (op: ARRAY OF CHAR; reg, n: INTEGER);
BEGIN
    IF isLong(n) THEN
        Write(op); Write(" "); Write(regs[reg]); Write(",qword["); Write("NUMBERS+"); WriteHex(Numbers_Count * 8); WriteLn("]");
        NewNumber(n)
    ELSE
        Write(op); Write(" "); Write(regs[reg]); Write(","); WriteHexLn(n)
    END
END oprc;


PROCEDURE opr (op: ARRAY OF CHAR; reg: INTEGER);
BEGIN
    Write(op); Write(" "); WriteLn(regs[reg])
END opr;


PROCEDURE mov (reg1, reg2: INTEGER);
BEGIN
    oprr("mov", reg1, reg2)
END mov;


PROCEDURE xchg (reg1, reg2: INTEGER);
BEGIN
    oprr("xchg", reg1, reg2)
END xchg;


PROCEDURE pop (reg: INTEGER);
BEGIN
    opr("pop", reg)
END pop;


PROCEDURE push (reg: INTEGER);
BEGIN
    opr("push", reg)
END push;


PROCEDURE CallRTL (pic: BOOLEAN; proc: INTEGER);
VAR
    label: INTEGER;

BEGIN
    label := CODE.codes.rtl[proc];

    IF label < 0 THEN
        label := -label;
        IF pic THEN
            ASSERT(FALSE)
        ELSE
            Write("call qword[P"); WriteHex(label); WriteLn("]")
        END
    ELSE
        Write("call L"); WriteHexLn(label)
    END
END CallRTL;


PROCEDURE log2 (x: INTEGER): INTEGER;
VAR
    n: INTEGER;

BEGIN
    ASSERT(x > 0);

    n := 0;
    WHILE ~ODD(x) DO
        x := x DIV 2;
        INC(n)
    END;

    IF x # 1 THEN
        n := -1
    END

    RETURN n
END log2;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE UnOp (VAR reg: INTEGER);
BEGIN
    REG.UnOp(R, reg)
END UnOp;


PROCEDURE BinOp (VAR reg1, reg2: INTEGER);
BEGIN
    REG.BinOp(R, reg1, reg2)
END BinOp;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    R.pushed := R.pushed - NumberOfParameters
END PushAll;


PROCEDURE movrc (reg, n: INTEGER);
BEGIN
    oprc("mov", reg, n)
END movrc;


PROCEDURE test (reg: INTEGER);
BEGIN
    oprr("test", reg, reg)
END test;


PROCEDURE cmprc (reg, n: INTEGER);
BEGIN
    oprc("cmp", reg, n)
END cmprc;


PROCEDURE addrc (reg, n: INTEGER);
BEGIN
    oprc("add", reg, n)
END addrc;


PROCEDURE andrc (reg, n: INTEGER);
BEGIN
    oprc("and", reg, n)
END andrc;


PROCEDURE pushc (n: INTEGER);
BEGIN
    IF isLong(n) THEN
        Write("push "); Write("qword["); Write("NUMBERS+"); WriteHex(Numbers_Count * 8); WriteLn("]");
        NewNumber(n)
    ELSE
        Write("push "); WriteHexLn(n)
    END
END pushc;


PROCEDURE cmprr (reg1, reg2: INTEGER);
BEGIN
    oprr("cmp", reg1, reg2)
END cmprr;


PROCEDURE not (reg: INTEGER);
BEGIN
    opr("not", reg)
END not;


PROCEDURE neg (reg: INTEGER);
BEGIN
    opr("neg", reg)
END neg;


PROCEDURE xmmr (xmm: INTEGER);
VAR
    s: ARRAY 5 OF CHAR;

BEGIN
    ASSERT((0 <= xmm) & (xmm <= 5));
    s := "xmm";
    s[3] := hexdgt(xmm);
    s[4] := 0X;
    Write(s)
END xmmr;


PROCEDURE jcc (jmp, label: INTEGER);
BEGIN
    CASE jmp OF
    |je:   Write("je ")
    |jne:  Write("jne ")
    |jl:   Write("jl ")
    |jge:  Write("jge ")
    |jle:  Write("jle ")
    |jg:   Write("jg ")
    |jb:   Write("jb ")
    END;
    Write("L");
    WriteHexLn(label)
END jcc;


PROCEDURE setcc (set, reg: INTEGER);
BEGIN
    CASE set OF
    |sete:   Write("sete ")
    |setne:  Write("setne ")
    |setl:   Write("setl ")
    |setge:  Write("setge ")
    |setle:  Write("setle ")
    |setg:   Write("setg ")
    |setc:   Write("setc ")
    |setnc:  Write("setnc ")
    END;
    WriteLn(regs8[reg])
END setcc;


PROCEDURE PassParam (i: INTEGER; isFloat: BOOLEAN);
BEGIN
    CASE i OF
    |0:
        IF isFloat THEN
            WriteLn("movsd xmm0,qword[rsp]")
        ELSE
            WriteLn("mov rcx,qword[rsp]")
        END

    |1:
        IF isFloat THEN
            WriteLn("movsd xmm1,qword[rsp+8]")
        ELSE
            WriteLn("mov rdx,qword[rsp+8]")
        END

    |2:
        IF isFloat THEN
            WriteLn("movsd xmm2,qword[rsp+16]")
        ELSE
            WriteLn("mov r8,qword[rsp+16]")
        END

    |3:
        IF isFloat THEN
            WriteLn("movsd xmm3,qword[rsp+24]")
        ELSE
            WriteLn("mov r9,qword[rsp+24]")
        END

    END
END PassParam;


PROCEDURE SaveParam (i: INTEGER; isFloat: BOOLEAN);
BEGIN
    CASE i OF
    |0:
        IF isFloat THEN
            WriteLn("movsd qword[rsp+16],xmm0")
        ELSE
            WriteLn("mov qword[rsp+16],rcx")
        END

    |1:
        IF isFloat THEN
            WriteLn("movsd qword[rsp+24],xmm1")
        ELSE
            WriteLn("mov qword[rsp+24],rdx")
        END

    |2:
        IF isFloat THEN
            WriteLn("movsd qword[rsp+32],xmm2")
        ELSE
            WriteLn("mov qword[rsp+32],r8")
        END

    |3:
        IF isFloat THEN
            WriteLn("movsd qword[rsp+40],xmm3")
        ELSE
            WriteLn("mov qword[rsp+40],r9")
        END

    END
END SaveParam;


PROCEDURE translate (commands: LISTS.LIST; pic: BOOLEAN; stroffs: INTEGER);
VAR
    cmd, next: COMMAND;

    param1, param2, param3, a, b, n, label, i: INTEGER;

    reg1, reg2, xmm: INTEGER;

    float: REAL;

BEGIN
    xmm := -1;
    cmd := commands.first(COMMAND);
    WHILE cmd # NIL DO

        param1 := cmd.param1;
        param2 := cmd.param2;

        CASE cmd.opcode OF

        |CODE.opSWAP:
            BinOp(reg1, reg2);
            oprr("xchg", reg1, reg2)

        |CODE.opJMP:
            Write("jmp "); Write("L"); WriteHexLn(param1)

        |CODE.opCALL:
            Write("call "); Write("L"); WriteHexLn(param1)

        |CODE.opCALLP:
            UnOp(reg1);
            Write("call "); WriteLn(regs[reg1]);
            drop;
            ASSERT(R.top = -1)

        |CODE.opCALLI:
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("call qword[P"); WriteHex(param1); WriteLn("]")
            END

        |CODE.opCALL64:
            n := ASR(param2, 4);
            FOR i := 0 TO n - 1 DO
                PassParam(i, i IN BITS(param2))
            END;
            Write("call "); Write("L"); WriteHexLn(param1)

        |CODE.opCALLP64:
            UnOp(reg1);
            IF reg1 # rax THEN
                ASSERT(REG.GetReg(R, rax));
                ASSERT(REG.Exchange(R, reg1, rax));
                drop
            END;
            drop;
            n := ASR(param2, 4);
            FOR i := 0 TO n - 1 DO
                PassParam(i, i IN BITS(param2))
            END;
            WriteLn("call rax");
            ASSERT(R.top = -1)

        |CODE.opCALLI64:
            n := ASR(param2, 4);
            FOR i := 0 TO n - 1 DO
                PassParam(i, i IN BITS(param2))
            END;
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("call qword[P"); WriteHex(param1); WriteLn("]")
            END

        |CODE.opLABEL:
            Write("L"); WriteHex(param2); WriteLn(":")

        |CODE.opERR:
            CallRTL(pic, CODE._error)

        |CODE.opERRC:
            pushc(param2)

        |CODE.opPRECALL:
            n := param2;
            IF (param1 # 0) & (n # 0) THEN
                WriteLn("sub rsp,8")
            END;
            WHILE n > 0 DO
                WriteLn("sub rsp,8");
                Write("movsd qword[rsp],"); xmmr(xmm); WriteLn("");
                DEC(xmm);
                DEC(n)
            END;
            ASSERT(xmm = -1);
            PushAll(0)

        |CODE.opALIGN16:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); WriteLn(",rsp");
            WriteLn("and rsp,-16");
            push(reg1);
            push(reg1);
            IF param2 > 0 THEN
                Write("sub rsp,"); WriteHexLn(param2 * 8)
            END;
            drop

        |CODE.opRESF:
            ASSERT(xmm = -1);
            INC(xmm);
            n := param2;
            IF n > 0 THEN
                Write("movsd qword[rsp+"); WriteHex(n * 8); Write("],"); xmmr(xmm); WriteLn("");
                DEC(xmm);
                INC(n)
            END;

            WHILE n > 0 DO
                INC(xmm);
                Write("movsd "); xmmr(xmm); Write(",qword[rsp]"); WriteLn("");
                WriteLn("add rsp,8");
                DEC(n)
            END

        |CODE.opRES:
            ASSERT(R.top = -1);
            ASSERT(REG.GetReg(R, rax));
            n := param2;
            WHILE n > 0 DO
                INC(xmm);
                Write("movsd "); xmmr(xmm); Write(",qword[rsp]"); WriteLn("");
                WriteLn("add rsp,8");
                DEC(n)
            END

        |CODE.opENTER:
            ASSERT(R.top = -1);

            Write("L"); WriteHex(param1); WriteLn(":");

            param3 := cmd.param3;

            WriteLn("push rbp");
            WriteLn("mov rbp,rsp");

            n := ASR(param3, 4);
            FOR i := 0 TO n - 1 DO
                SaveParam(i, i IN BITS(param3))
            END;

            n := param2;
            IF n > 4 THEN
                WriteLn("mov r10, rcx");
                Write("mov rcx,"); WriteHexLn(n);
                WriteLn("@@: push 0");
                WriteLn("loop @b");
                WriteLn("mov rcx, r10")
            ELSE
                WHILE n > 0 DO
                    WriteLn("push 0");
                    DEC(n)
                END
            END

        |CODE.opLEAVE, CODE.opLEAVER, CODE.opLEAVEF:
            IF cmd.opcode = CODE.opLEAVER THEN
                UnOp(reg1);
                IF reg1 # rax THEN
                    ASSERT(REG.GetReg(R, rax));
                    ASSERT(REG.Exchange(R, reg1, rax));
                    drop
                END;
                drop
            END;

            ASSERT(R.top = -1);

            IF cmd.opcode = CODE.opLEAVEF THEN
                DEC(xmm)
            END;

            ASSERT(xmm = -1);

            WriteLn("mov rsp,rbp");
            WriteLn("pop rbp");
            Write("ret ");
            IF param2 > 0 THEN
                WriteHex(param2 * 8)
            END;
            WriteLn("")

        |CODE.opSAVES:
            UnOp(reg1);
            drop;
            PushAll(0);
            push(reg1);

            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("push _data+"); WriteHexLn(stroffs + param2)
            END;

            pushc(param1);
            CallRTL(pic, CODE._move)
            
        |CODE.opSADR:
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                reg1 := REG.GetAnyReg(R);
                Write("mov "); Write(regs[reg1]); Write(",_data+"); WriteHexLn(stroffs + param2)
            END

        |CODE.opLOAD8:
            UnOp(reg1);
            Write("movzx "); Write(regs[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]")

        |CODE.opLOAD16:
            UnOp(reg1);
            Write("movzx "); Write(regs[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]")

        |CODE.opLOAD32:
            UnOp(reg1);
            Write("mov "); Write(regs32[reg1]); Write(",dword["); Write(regs[reg1]); WriteLn("]");
            oprc("shl", reg1, 32);
            oprc("shr", reg1, 32)
            
        |CODE.opLOAD64:
            UnOp(reg1);
            Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]")
            
        |CODE.opLLOAD64:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opLLOAD8:
            reg1 := REG.GetAnyReg(R);
            Write("movzx "); Write(regs[reg1]); Write(",byte[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opLLOAD16:
            reg1 := REG.GetAnyReg(R);
            Write("movzx "); Write(regs[reg1]); Write(",word[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opLLOAD32:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("mov "); Write(regs32[reg1]); Write(",dword[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opGLOAD64:
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                reg1 := REG.GetAnyReg(R);
                Write("mov "); Write(regs[reg1]); Write(",qword[GLOB+"); WriteHex(param2); WriteLn("]")
            END

        |CODE.opGLOAD8:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("movzx "); Write(regs[reg1]); Write(",byte[GLOB+"); WriteHex(param2); WriteLn("]")
            END

        |CODE.opGLOAD16:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("movzx "); Write(regs[reg1]); Write(",word[GLOB+"); WriteHex(param2); WriteLn("]")
            END    
            
        |CODE.opGLOAD32:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                oprr("xor", reg1, reg1);
                Write("mov "); Write(regs32[reg1]); Write(",dword[GLOB+"); WriteHex(param2); WriteLn("]")
            END

        |CODE.opVLOAD64:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]");
            Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]")

        |CODE.opVLOAD8:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]");
            Write("movzx "); Write(regs[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]")

        |CODE.opVLOAD16:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]");
            Write("movzx "); Write(regs[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]")

        |CODE.opVLOAD32:
            reg1 := REG.GetAnyReg(R);
            reg2 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("mov "); Write(regs[reg2]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]");
            Write("mov "); Write(regs32[reg1]); Write(",dword["); Write(regs[reg2]); WriteLn("]");
            drop;
            
        |CODE.opLADR:
            n := param2 * 8;
            next := cmd.next(COMMAND);
            IF next.opcode = CODE.opSAVEF THEN
                Write("movsd qword[rbp+"); WriteHex(n); Write("],"); xmmr(xmm); WriteLn("");
                DEC(xmm);
                cmd := next
            ELSE
                reg1 := REG.GetAnyReg(R);
                Write("lea "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(n); WriteLn("]");
            END

        |CODE.opGADR:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",GLOB+"); WriteHexLn(param2)

        |CODE.opVADR:
            reg1 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg1]); Write(",qword[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opSAVE8C:
            UnOp(reg1);
            Write("mov byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2);
            drop

        |CODE.opSAVE16C:
            UnOp(reg1);
            Write("mov word["); Write(regs[reg1]); Write("],"); WriteHexLn(param2);
            drop

        |CODE.opSAVEC:
            UnOp(reg1);
            IF isLong(param2) THEN
                reg2 := REG.GetAnyReg(R);
                movrc(reg2, param2);
                Write("mov qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
                drop
            ELSE
                Write("mov qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
            END;
            drop

        |CODE.opRSET:
            PushAll(2);
            CallRTL(pic, CODE._set);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opRSETR:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._set);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opRSETL:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._set2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opRSET1:
            UnOp(reg1);
            PushAll(1);
            push(reg1);
            CallRTL(pic, CODE._set);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opINCL:
            PushAll(2);
            CallRTL(pic, CODE._incl)

        |CODE.opEXCL:
            PushAll(2);
            CallRTL(pic, CODE._excl)

        |CODE.opINCLC:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._incl)

        |CODE.opEXCLC:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._excl)

        |CODE.opEQS, CODE.opNES, CODE.opLTS,
         CODE.opLES, CODE.opGTS, CODE.opGES:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQS: pushc(0)
            |CODE.opNES: pushc(1)
            |CODE.opLTS: pushc(2)
            |CODE.opLES: pushc(3)
            |CODE.opGTS: pushc(4)
            |CODE.opGES: pushc(5)
            END;
            CallRTL(pic, CODE._strcmp);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opEQS2, CODE.opNES2, CODE.opLTS2,
         CODE.opLES2, CODE.opGTS2, CODE.opGES2:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQS2: pushc(0)
            |CODE.opNES2: pushc(1)
            |CODE.opLTS2: pushc(2)
            |CODE.opLES2: pushc(3)
            |CODE.opGTS2: pushc(4)
            |CODE.opGES2: pushc(5)
            END;
            CallRTL(pic, CODE._strcmp2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opEQSW, CODE.opNESW, CODE.opLTSW,
         CODE.opLESW, CODE.opGTSW, CODE.opGESW:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQSW: pushc(0)
            |CODE.opNESW: pushc(1)
            |CODE.opLTSW: pushc(2)
            |CODE.opLESW: pushc(3)
            |CODE.opGTSW: pushc(4)
            |CODE.opGESW: pushc(5)
            END;
            CallRTL(pic, CODE._strcmpw);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opEQSW2, CODE.opNESW2, CODE.opLTSW2,
         CODE.opLESW2, CODE.opGTSW2, CODE.opGESW2:
            PushAll(4);
            CASE cmd.opcode OF
            |CODE.opEQSW2: pushc(0)
            |CODE.opNESW2: pushc(1)
            |CODE.opLTSW2: pushc(2)
            |CODE.opLESW2: pushc(3)
            |CODE.opGTSW2: pushc(4)
            |CODE.opGESW2: pushc(5)
            END;
            CallRTL(pic, CODE._strcmpw2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opINC1:
            UnOp(reg1);
            Write("inc qword["); Write(regs[reg1]); WriteLn("]");
            drop

        |CODE.opDEC1:
            UnOp(reg1);
            Write("dec qword["); Write(regs[reg1]); WriteLn("]");
            drop

        |CODE.opCONST:
            reg1 := REG.GetAnyReg(R);
            movrc(reg1, param2)

        |CODE.opGT, CODE.opGE, CODE.opLT,
         CODE.opLE, CODE.opEQ, CODE.opNE:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            drop;
            drop;

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).param1;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jg,  label)
                |CODE.opGE: jcc(jge, label)
                |CODE.opLE: jcc(jle, label)
                |CODE.opLT: jcc(jl,  label)
                |CODE.opEQ: jcc(je,  label)
                |CODE.opNE: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).param1;
                CASE cmd.opcode OF
                |CODE.opGT: jcc(jle, label)
                |CODE.opGE: jcc(jl,  label)
                |CODE.opLE: jcc(jg,  label)
                |CODE.opLT: jcc(jge, label)
                |CODE.opEQ: jcc(jne, label)
                |CODE.opNE: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGT: setcc(setg,  reg1)
                |CODE.opGE: setcc(setge, reg1)
                |CODE.opLE: setcc(setle, reg1)
                |CODE.opLT: setcc(setl,  reg1)
                |CODE.opEQ: setcc(sete,  reg1)
                |CODE.opNE: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END

        |CODE.opGTR, CODE.opLTL, CODE.opGER, CODE.opLEL,
         CODE.opLER, CODE.opGEL, CODE.opLTR, CODE.opGTL,
         CODE.opEQR, CODE.opEQL, CODE.opNER, CODE.opNEL:
            UnOp(reg1);
            IF param2 = 0 THEN
                test(reg1)
            ELSE
                cmprc(reg1, param2)
            END;
            drop;

            IF cmd.next(COMMAND).opcode = CODE.opJE THEN
                label := cmd.next(COMMAND).param1;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jg,  label)
                |CODE.opGER, CODE.opLEL: jcc(jge, label)
                |CODE.opLER, CODE.opGEL: jcc(jle, label)
                |CODE.opLTR, CODE.opGTL: jcc(jl,  label)
                |CODE.opEQR, CODE.opEQL: jcc(je,  label)
                |CODE.opNER, CODE.opNEL: jcc(jne, label)
                END;
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = CODE.opJNE THEN
                label := cmd.next(COMMAND).param1;
                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: jcc(jle, label)
                |CODE.opGER, CODE.opLEL: jcc(jl,  label)
                |CODE.opLER, CODE.opGEL: jcc(jg,  label)
                |CODE.opLTR, CODE.opGTL: jcc(jge, label)
                |CODE.opEQR, CODE.opEQL: jcc(jne, label)
                |CODE.opNER, CODE.opNEL: jcc(je,  label)
                END;
                cmd := cmd.next(COMMAND)

            ELSE
                reg1 := REG.GetAnyReg(R);

                CASE cmd.opcode OF
                |CODE.opGTR, CODE.opLTL: setcc(setg,  reg1)
                |CODE.opGER, CODE.opLEL: setcc(setge, reg1)
                |CODE.opLER, CODE.opGEL: setcc(setle, reg1)
                |CODE.opLTR, CODE.opGTL: setcc(setl,  reg1)
                |CODE.opEQR, CODE.opEQL: setcc(sete,  reg1)
                |CODE.opNER, CODE.opNEL: setcc(setne, reg1)
                END;

                andrc(reg1, 1)
            END;

        |CODE.opCODE:
            Write("db "); WriteByte(param2); WriteLn("")

        |CODE.opPUSHIP:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("mov "); Write(regs[reg1]); Write(",qword[P"); WriteHex(param2); WriteLn("]")
            END

        |CODE.opPARAM:
            n := param2;
            IF n = 1 THEN
                UnOp(reg1);
                push(reg1);
                drop
            ELSE
                ASSERT(R.top + 1 <= n);
                PushAll(n)
            END

        |CODE.opJNZ:
            UnOp(reg1);
            test(reg1);
            jcc(jne, param1)

        |CODE.opJZ:
            UnOp(reg1);
            test(reg1);
            jcc(je, param1)

        |CODE.opJE:
            UnOp(reg1);
            test(reg1);
            jcc(jne, param1);
            drop;
            
        |CODE.opJNE:
            UnOp(reg1);
            test(reg1);
            jcc(je, param1);
            drop;

        |CODE.opIN:
            PushAll(2);
            CallRTL(pic, CODE._in);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opINR:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._in);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opINL:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._in2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opNOT:
            UnOp(reg1);
            test(reg1);
            setcc(sete, reg1);
            andrc(reg1, 1)

        |CODE.opORD:
            UnOp(reg1);
            test(reg1);
            setcc(setne, reg1);
            andrc(reg1, 1)

        |CODE.opABS:
            UnOp(reg1);
            test(reg1);
            WriteLn("jge @f");
            neg(reg1);
            WriteLn("@@:")

        |CODE.opEQB, CODE.opNEB:
            BinOp(reg1, reg2);
            drop;
            drop;

            test(reg1);
            WriteLn("je @f");
            movrc(reg1, 1);
            WriteLn("@@:");
            test(reg2);
            WriteLn("je @f");
            movrc(reg2, 1);
            WriteLn("@@:");

            cmprr(reg1, reg2);
            reg1 := REG.GetAnyReg(R);
            IF cmd.opcode = CODE.opEQB THEN
                setcc(sete, reg1)
            ELSE
                setcc(setne, reg1)
            END;
            andrc(reg1, 1)

        |CODE.opMULSC:
            UnOp(reg1);
            andrc(reg1, param2)

        |CODE.opDIVSC:
            UnOp(reg1);
            oprc("xor", reg1, param2)

        |CODE.opADDSL, CODE.opADDSR:
            UnOp(reg1);
            oprc("or", reg1, param2)

        |CODE.opSUBSL:
            UnOp(reg1);
            not(reg1);
            oprc("and", reg1, param2)

        |CODE.opSUBSR:
            UnOp(reg1);
            oprc("and", reg1, ORD(-BITS(param2)))

        |CODE.opMULS:
            BinOp(reg1, reg2);
            oprr("and", reg1, reg2);
            drop

        |CODE.opDIVS:
            BinOp(reg1, reg2);
            oprr("xor", reg1, reg2);
            drop

        |CODE.opUMINS:
            UnOp(reg1);
            not(reg1)

        |CODE.opCOPY:
            PushAll(2);
            pushc(param2);
            CallRTL(pic, CODE._move2)

        |CODE.opMOVE:
            PushAll(3);
            CallRTL(pic, CODE._move2)

        |CODE.opCOPYA:
            PushAll(4);
            pushc(param2);
            CallRTL(pic, CODE._arrcpy);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opCOPYS:
            PushAll(4);
            pushc(param2);
            CallRTL(pic, CODE._strcpy)

        |CODE.opCOPYS2:
            PushAll(4);
            pushc(param2);
            CallRTL(pic, CODE._strcpy2)

        |CODE.opROT:
            PushAll(0);
            WriteLn("push rsp");
            pushc(param2);
            CallRTL(pic, CODE._rot)

        |CODE.opNEW:
            PushAll(1);
            n := param2 + 16;
            ASSERT(MACHINE.Align(n, 64));
            pushc(n);
            pushc(param1);
            CallRTL(pic, CODE._new)

        |CODE.opDISP:
            PushAll(1);
            CallRTL(pic, CODE._dispose)

        |CODE.opPUSHT:
            UnOp(reg1);
            reg2 := REG.GetAnyReg(R);
            Write("mov "); Write(regs[reg2]); Write(",qword["); Write(regs[reg1]); WriteLn("-8]")

        |CODE.opISREC:
            PushAll(2);
            pushc(param2);
            CallRTL(pic, CODE._isrec);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opIS:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._is);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opTYPEGR:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._guardrec);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opTYPEGP:
            UnOp(reg1);
            PushAll(0);
            push(reg1);
            pushc(param2);
            CallRTL(pic, CODE._guard);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opTYPEGD:
            UnOp(reg1);
            PushAll(0);
            Write("push qword["); Write(regs[reg1]); WriteLn("-8]");
            pushc(param2);
            CallRTL(pic, CODE._guardrec);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opCASET:
            push(r10);
            push(r10);
            pushc(param2);
            CallRTL(pic, CODE._guardrec);
            pop(r10);
            test(rax);
            jcc(jne, param1)

        |CODE.opSAVEP:
            UnOp(reg1);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("mov qword["); Write(regs[reg1]); Write("],L"); WriteHexLn(param2)
            END;
            drop

        |CODE.opPUSHP:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("mov "); Write(regs[reg1]); Write(",L"); WriteHexLn(param2)
            END

        |CODE.opINC:
            BinOp(reg1, reg2);
            Write("add qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
            drop;
            drop

        |CODE.opDEC:
            BinOp(reg1, reg2);
            Write("sub qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
            drop;
            drop

        |CODE.opINCC:
            UnOp(reg1);
            IF isLong(param2) THEN
                reg2 := REG.GetAnyReg(R);
                movrc(reg2, param2);
                Write("add qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
                drop
            ELSE
                Write("add qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
            END;
            drop

        |CODE.opDECC:
            UnOp(reg1);
            IF isLong(param2) THEN
                reg2 := REG.GetAnyReg(R);
                movrc(reg2, param2);
                Write("sub qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
                drop
            ELSE
                Write("sub qword["); Write(regs[reg1]); Write("],"); WriteHexLn(param2)
            END;
            drop

        |CODE.opDROP:
            UnOp(reg1);
            drop

        |CODE.opSAVE, CODE.opSAVE64:
            BinOp(reg2, reg1);
            Write("mov qword["); Write(regs[reg1]); Write("],"); WriteLn(regs[reg2]);
            drop;
            drop

        |CODE.opSAVE8:
            BinOp(reg2, reg1);
            Write("mov byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2]);
            drop;
            drop

        |CODE.opSAVE16:
            BinOp(reg2, reg1);
            Write("mov word["); Write(regs[reg1]); Write("],"); WriteLn(regs16[reg2]);
            drop;
            drop

        |CODE.opSAVE32:
            BinOp(reg2, reg1);
            Write("mov dword["); Write(regs[reg1]); Write("],"); WriteLn(regs32[reg2]);
            drop;
            drop

        |CODE.opMIN:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            WriteLn("jle @f");
            mov(reg1, reg2);
            WriteLn("@@:");
            drop

        |CODE.opMAX:
            BinOp(reg1, reg2);
            cmprr(reg1, reg2);
            WriteLn("jge @f");
            mov(reg1, reg2);
            WriteLn("@@:");
            drop

        |CODE.opMINC:
            UnOp(reg1);
            cmprc(reg1, param2);
            WriteLn("jle @f");
            movrc(reg1, param2);
            WriteLn("@@:")

        |CODE.opMAXC:
            UnOp(reg1);
            cmprc(reg1, param2);
            WriteLn("jge @f");
            movrc(reg1, param2);
            WriteLn("@@:")

        |CODE.opSBOOL:
            BinOp(reg2, reg1);
            test(reg2);
            setcc(setne, reg2);
            Write("mov byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2]);
            drop;
            drop

        |CODE.opSBOOLC:
            UnOp(reg1);
            Write("mov byte["); Write(regs[reg1]); Write("],"); WriteHexLn(ORD(param2 # 0));
            drop

        |CODE.opODD:
            UnOp(reg1);
            andrc(reg1, 1)

        |CODE.opUMINUS:
            UnOp(reg1);
            neg(reg1)

        |CODE.opADD:
            BinOp(reg1, reg2);
            oprr("add", reg1, reg2);
            drop

        |CODE.opSUB:
            BinOp(reg1, reg2);
            oprr("sub", reg1, reg2);
            drop

        |CODE.opSUBR, CODE.opSUBL:
            UnOp(reg1);
            n := param2;
            IF n = 1 THEN
                opr("dec", reg1)
            ELSIF n = -1 THEN
                opr("inc", reg1)
            ELSIF n # 0 THEN
                oprc("sub", reg1, n)
            END;
            IF cmd.opcode = CODE.opSUBL THEN
                neg(reg1)
            END  

        |CODE.opADDL, CODE.opADDR:
            IF param2 # 0 THEN
                UnOp(reg1);
                IF param2 = 1 THEN
                    opr("inc", reg1)
                ELSIF param2 = -1 THEN
                    opr("dec", reg1)
                ELSE
                    addrc(reg1, param2)
                END
            END

        |CODE.opDIV:
            PushAll(2);
            CallRTL(pic, CODE._div);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opDIVR:
            a := param2;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                UnOp(reg1);
                neg(reg1)
            ELSE
                IF n > 0 THEN
                    UnOp(reg1);

                    IF a < 0 THEN
                        reg2 := REG.GetAnyReg(R);
                        mov(reg2, reg1);
                        oprc("sar", reg1, n);
                        oprr("sub", reg1, reg2);
                        drop
                    ELSE
                        oprc("sar", reg1, n)
                    END

                ELSE
                    PushAll(1);
                    pushc(param2);
                    CallRTL(pic, CODE._div);
                    ASSERT(REG.GetReg(R, rax))
                END
            END

        |CODE.opDIVL:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._div2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opMOD:
            PushAll(2);
            CallRTL(pic, CODE._mod);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opMODR:
            a := param2;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF ABS(a) = 1 THEN
                UnOp(reg1);
                oprr("xor", reg1, reg1);
            ELSE
                IF n > 0 THEN
                    UnOp(reg1);
                    andrc(reg1, ABS(a) - 1);

                    IF a < 0 THEN
                        test(reg1);
                        WriteLn("je @f");
                        addrc(reg1, a);
                        WriteLn("@@:")
                    END

                ELSE
                    PushAll(1);
                    pushc(param2);
                    CallRTL(pic, CODE._mod);
                    ASSERT(REG.GetReg(R, rax))
                END
            END

        |CODE.opMODL:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._mod2);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opMUL:
            BinOp(reg1, reg2);
            oprr("imul", reg1, reg2);
            drop

        |CODE.opMULC:
            UnOp(reg1);

            a := param2;
            IF a > 1 THEN
                n := log2(a)
            ELSIF a < -1 THEN
                n := log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                neg(reg1)
            ELSIF a = 0 THEN
                oprr("xor", reg1, reg1)
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        neg(reg1)
                    END;
                    oprc("shl", reg1, n)
                ELSE
                    oprc("imul", reg1, a)
                END
            END

        |CODE.opADDS:
            BinOp(reg1, reg2);
            oprr("or", reg1, reg2);
            drop

        |CODE.opSUBS:
            BinOp(reg1, reg2);
            not(reg2);
            oprr("and", reg1, reg2);
            drop

        |CODE.opNOP:

        |CODE.opSWITCH:
            UnOp(reg1);
            IF param2 = 0 THEN
                reg2 := rax
            ELSE
                reg2 := r10
            END;
            IF reg1 # reg2 THEN
                ASSERT(REG.GetReg(R, reg2));
                ASSERT(REG.Exchange(R, reg1, reg2));
                drop
            END;
            drop

        |CODE.opENDSW:

        |CODE.opCASEL:
            cmprc(rax, param1);
            jcc(jl, param2)

        |CODE.opCASER:
            cmprc(rax, param1);
            jcc(jg, param2)

        |CODE.opCASELR:
            cmprc(rax, param1);
            jcc(jl, param2);
            jcc(jg, cmd.param3)

        |CODE.opASR, CODE.opROR, CODE.opLSL, CODE.opLSR:
            BinOp(reg1, reg2);
            xchg(reg2, rcx);
            CASE cmd.opcode OF
            |CODE.opASR: Write("sar ")
            |CODE.opROR: Write("ror ")
            |CODE.opLSL: Write("shl ")
            |CODE.opLSR: Write("shr ")
            END;
            Write(regs[reg1]); WriteLn(",cl");
            xchg(reg2, rcx);
            drop

        |CODE.opASR1, CODE.opROR1, CODE.opLSL1, CODE.opLSR1:
            reg1 := REG.GetAnyReg(R);
            movrc(reg1, param2);
            BinOp(reg1, reg2);
            xchg(reg1, rcx);
            CASE cmd.opcode OF
            |CODE.opASR1: Write("sar ")
            |CODE.opROR1: Write("ror ")
            |CODE.opLSL1: Write("shl ")
            |CODE.opLSR1: Write("shr ")
            END;
            Write(regs[reg2]); WriteLn(",cl");
            xchg(reg1, rcx);
            drop;
            drop;
            ASSERT(REG.GetReg(R, reg2))

        |CODE.opASR2, CODE.opROR2, CODE.opLSL2, CODE.opLSR2:
            UnOp(reg1);
            n := ORD(BITS(param2) * {0..5});

            CASE cmd.opcode OF
            |CODE.opASR2: oprc("sar", reg1, n)
            |CODE.opROR2: oprc("ror", reg1, n)
            |CODE.opLSL2: oprc("shl", reg1, n)
            |CODE.opLSR2: oprc("shr", reg1, n)
            END;

        |CODE.opGET:
            BinOp(reg1, reg2);
            drop;
            drop;

            CASE param2 OF
            |1:
                Write("mov "); Write(regs8[reg1]); Write(",byte["); Write(regs[reg1]); WriteLn("]");
                Write("mov byte["); Write(regs[reg2]); Write("],"); WriteLn(regs8[reg1])

            |2:
                Write("mov "); Write(regs16[reg1]); Write(",word["); Write(regs[reg1]); WriteLn("]");
                Write("mov word["); Write(regs[reg2]); Write("],"); WriteLn(regs16[reg1])

            |4:
                Write("mov "); Write(regs32[reg1]); Write(",dword["); Write(regs[reg1]); WriteLn("]");
                Write("mov dword["); Write(regs[reg2]); Write("],"); WriteLn(regs32[reg1])

            |8:
                Write("mov "); Write(regs[reg1]); Write(",qword["); Write(regs[reg1]); WriteLn("]");
                Write("mov qword["); Write(regs[reg2]); Write("],"); WriteLn(regs[reg1])

            END

        |CODE.opCHKIDX:
            UnOp(reg1);
            cmprc(reg1, param2);
            jcc(jb, param1)

        |CODE.opCHKIDX2:
            BinOp(reg1, reg2);
            IF param2 # -1 THEN
                cmprr(reg2, reg1);
                mov(reg1, reg2);
                drop;
                jcc(jb, param1)
            ELSE
                INCL(R.regs, reg1);
                DEC(R.top);
                R.stk[R.top] := reg2
            END

        |CODE.opLENGTH:
            PushAll(2);
            CallRTL(pic, CODE._length);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opLENGTHW:
            PushAll(2);
            CallRTL(pic, CODE._lengthw);
            ASSERT(REG.GetReg(R, rax))

        |CODE.opLEN:
            n := param2;
            UnOp(reg1);
            drop;
            EXCL(R.regs, reg1);

            WHILE n > 0 DO
                UnOp(reg2);
                drop;
                DEC(n)
            END;

            INCL(R.regs, reg1);
            ASSERT(REG.GetReg(R, reg1))

        |CODE.opCHR:
            UnOp(reg1);
            andrc(reg1, 255)

        |CODE.opWCHR:
            UnOp(reg1);
            andrc(reg1, 65535)

        |CODE.opEQP, CODE.opNEP, CODE.opEQIP, CODE.opNEIP:
            UnOp(reg1);
            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opNEP:
                IF pic THEN
                    ASSERT(FALSE)
                ELSE
                    Write("cmp "); Write(regs[reg1]); Write(",L"); WriteHexLn(param1)
                END

            |CODE.opEQIP, CODE.opNEIP:
                IF pic THEN
                    ASSERT(FALSE)
                ELSE
                    Write("cmp "); Write(regs[reg1]); Write(",qword[P"); WriteHex(param1); WriteLn("]")
                END

            END;
            drop;
            reg1 := REG.GetAnyReg(R);

            CASE cmd.opcode OF
            |CODE.opEQP, CODE.opEQIP: setcc(sete,  reg1)
            |CODE.opNEP, CODE.opNEIP: setcc(setne, reg1)
            END;

            andrc(reg1, 1)

        |CODE.opINC1B:
            UnOp(reg1);
            Write("inc byte["); Write(regs[reg1]); WriteLn("]");
            drop

        |CODE.opDEC1B:
            UnOp(reg1);
            Write("dec byte["); Write(regs[reg1]); WriteLn("]");
            drop

        |CODE.opINCCB:
            UnOp(reg1);
            Write("add byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2 MOD 256);
            drop

        |CODE.opDECCB:
            UnOp(reg1);
            Write("sub byte["); Write(regs[reg1]); Write("],"); WriteHexLn(param2 MOD 256);
            drop

        |CODE.opINCB, CODE.opDECB:
            BinOp(reg1, reg2);

            IF cmd.opcode = CODE.opINCB THEN
                Write("add byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2])
            ELSE
                Write("sub byte["); Write(regs[reg1]); Write("],"); WriteLn(regs8[reg2])
            END;

            drop;
            drop

        |CODE.opSAVEIP:
            UnOp(reg1);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("push qword[P"); WriteHex(param2); WriteLn("]");
                Write("pop qword["); Write(regs[reg1]); WriteLn("]")
            END;
            drop

        |CODE.opCLEANUP16:
            n := MAX(param2 + ORD(ODD(param2)), 4) * 8;
            Write("add rsp,"); WriteHexLn(n);
            WriteLn("pop rsp")

        |CODE.opCLEANUP:
            n := param2 * 8;
            IF n # 0 THEN
                Write("add rsp,"); WriteHexLn(n)
            END

        |CODE.opLOADF:
            UnOp(reg1);
            INC(xmm);
            Write("movsd "); xmmr(xmm); Write(",qword["); Write(regs[reg1]); WriteLn("]");
            drop

        |CODE.opPUSHF:
            WriteLn("sub rsp,8");
            Write("movsd qword [rsp],"); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opCONSTF:
            float := cmd.float;
            INC(xmm);
            Write("movsd "); xmmr(xmm); Write(",qword[NUMBERS+"); WriteHex(Numbers_Count * 8); WriteLn("]");
            NewNumber(UTILS.splitf(float, a, b))

        |CODE.opSAVEF:
            UnOp(reg1);
            Write("movsd qword["); Write(regs[reg1]); Write("],"); xmmr(xmm); WriteLn("");
            DEC(xmm);
            drop

        |CODE.opADDF, CODE.opADDFI:
            Write("addsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opSUBF:
            Write("subsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opSUBFI:
            Write("subsd "); xmmr(xmm); Write(","); xmmr(xmm - 1); WriteLn("");
            Write("movsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opMULF:
            Write("mulsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opDIVF:
            Write("divsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opDIVFI:
            Write("divsd "); xmmr(xmm); Write(","); xmmr(xmm - 1); WriteLn("");
            Write("movsd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            DEC(xmm)

        |CODE.opUMINF:
            Write("xorpd "); xmmr(xmm); WriteLn(",[NUMBERS]")

        |CODE.opFABS:
            Write("andpd "); xmmr(xmm); WriteLn(",[NUMBERS+16]")

        |CODE.opFLT:
            UnOp(reg1);
            INC(xmm);
            Write("cvtsi2sd "); xmmr(xmm); Write(","); WriteLn(regs[reg1]);
            drop

        |CODE.opFLOOR:
            reg1 := REG.GetAnyReg(R);
            WriteLn("sub rsp,8");
            WriteLn("stmxcsr dword[rsp+4]");
            WriteLn("stmxcsr dword[rsp]");
            WriteLn("and dword[rsp],11111111111111111001111111111111b");
            WriteLn("or dword[rsp],00000000000000000010000000000000b");
            WriteLn("ldmxcsr dword[rsp]");
            Write("cvtsd2si "); Write(regs[reg1]); Write(","); xmmr(xmm); WriteLn("");
            WriteLn("ldmxcsr dword[rsp+4]");
            WriteLn("add rsp,8");
            DEC(xmm)

        |CODE.opEQF, CODE.opEQFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            WriteLn("jp @f");
            setcc(sete, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opNEF, CODE.opNEFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            WriteLn("jp @f");
            setcc(setne, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opLTF, CODE.opGTFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            WriteLn("jp @f");
            setcc(setc, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opGTF, CODE.opLTFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm); Write(","); xmmr(xmm - 1); WriteLn("");
            WriteLn("jp @f");
            setcc(setc, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opLEF, CODE.opGEFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm); Write(","); xmmr(xmm - 1); WriteLn("");
            WriteLn("jp @f");
            setcc(setnc, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opGEF, CODE.opLEFI:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("comisd "); xmmr(xmm - 1); Write(","); xmmr(xmm); WriteLn("");
            WriteLn("jp @f");
            setcc(setnc, reg1);
            WriteLn("@@:");
            DEC(xmm, 2)

        |CODE.opINF:
            INC(xmm);
            Write("movsd "); xmmr(xmm); WriteLn(",qword[NUMBERS+32]")

        |CODE.opPACKC:
            PushAll(1);
            pushc(param2);
            CallRTL(pic, CODE._pack)

        |CODE.opPACK:
            PushAll(2);
            CallRTL(pic, CODE._pack)

        |CODE.opUNPK:
            PushAll(2);
            CallRTL(pic, CODE._unpk) 
            
        |CODE.opSADR_PARAM:   
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("push _data+"); WriteHexLn(stroffs + param2)
            END
            
        |CODE.opLOAD64_PARAM:
            UnOp(reg1);
            Write("push qword["); Write(regs[reg1]); WriteLn("]");
            drop      
            
        |CODE.opLLOAD64_PARAM:
            Write("push qword[rbp+"); WriteHex(param2 * 8); WriteLn("]") 
            
        |CODE.opVADR_PARAM:
            Write("push qword[rbp+"); WriteHex(param2 * 8); WriteLn("]") 
            
        |CODE.opCONST_PARAM:
            pushc(param2)     
            
        |CODE.opGLOAD32_PARAM:
            reg1 := REG.GetAnyReg(R);
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                oprr("xor", reg1, reg1);
                Write("mov "); Write(regs32[reg1]); Write(",dword[GLOB+"); WriteHex(param2); WriteLn("]");
                push(reg1);
                drop
            END    
            
        |CODE.opLOAD32_PARAM:
            UnOp(reg1);
            Write("mov "); Write(regs32[reg1]); Write(",dword["); Write(regs[reg1]); WriteLn("]");
            oprc("shl", reg1, 32);
            oprc("shr", reg1, 32);
            push(reg1);
            drop

        |CODE.opLLOAD32_PARAM:
            reg1 := REG.GetAnyReg(R);
            oprr("xor", reg1, reg1);
            Write("mov "); Write(regs32[reg1]); Write(",dword[rbp+"); WriteHex(param2 * 8); WriteLn("]");
            push(reg1);
            drop  
            
        |CODE.opGLOAD64_PARAM:
            IF pic THEN
                ASSERT(FALSE)
            ELSE
                Write("push qword[GLOB+"); WriteHex(param2); WriteLn("]")
            END   
            
        |CODE.opLADR_SAVEC:
            n := param1 * 8;
            IF isLong(param2) THEN
                reg1 := REG.GetAnyReg(R);
                movrc(reg1, param2);
                Write("mov qword[rbp+"); WriteHex(n); Write("],"); WriteLn(regs[reg1]);
                drop
            ELSE
                Write("mov qword[rbp+"); WriteHex(n); Write("],"); WriteHexLn(param2)
            END

        |CODE.opGADR_SAVEC:
            IF isLong(param2) THEN
                reg1 := REG.GetAnyReg(R);
                movrc(reg1, param2);
                Write("mov qword[GLOB+"); WriteHex(param1); Write("],"); WriteLn(regs[reg1]);
                drop
            ELSE
                Write("mov qword[GLOB+"); WriteHex(param1); Write("],"); WriteHexLn(param2)
            END   
            
        |CODE.opLADR_SAVE:
            UnOp(reg1);
            Write("mov qword[rbp+"); WriteHex(param2 * 8); Write("],"); WriteLn(regs[reg1]);
            drop  
            
        |CODE.opLADR_INC1:
            Write("inc qword[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        |CODE.opLADR_DEC1:
            Write("dec qword[rbp+"); WriteHex(param2 * 8); WriteLn("]")

        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1);
    ASSERT(xmm = -1)
END translate;


PROCEDURE prolog (code: CODE.CODES; pic: BOOLEAN; target, stack_size: INTEGER);
BEGIN
    IF target = mConst.Target_iConsole64 THEN
        WriteLn("format PE64 console");
        Write("stack 1024*1024*"); WriteHexLn(stack_size);
        WriteLn("entry start");
        WriteLn("section '.text' code readable executable");
        WriteLn("start:");

    ELSIF target = mConst.Target_iGUI64 THEN
        WriteLn("format PE64 GUI 5.0");
        Write("stack 1024*1024*"); WriteHexLn(stack_size);
        WriteLn("entry start");
        WriteLn("section '.text' code readable executable");
        WriteLn("start:");

    ELSIF target = mConst.Target_iDLL64 THEN
        WriteLn("format PE64 DLL");
        WriteLn("entry start");

        WriteLn("macro export dllname,[label,string]");
        WriteLn(" { common");
        WriteLn("    local module,addresses,names,ordinal,count");
        WriteLn("    count = 0");
        WriteLn("   forward");
        WriteLn("    count = count+1");
        WriteLn("   common");
        WriteLn("    dd 0,0,0,RVA module,1");
        WriteLn("    dd count,count,RVA addresses,RVA names,RVA ordinal");
        WriteLn("    addresses:");
        WriteLn("   forward");
        WriteLn("    dd RVA label");
        WriteLn("   common");
        WriteLn("    names:");
        WriteLn("   forward");
        WriteLn("    local name");
        WriteLn("    dd RVA name");
        WriteLn("   common");
        WriteLn("    ordinal: count = 0");
        WriteLn("   forward");
        WriteLn("    dw count");
        WriteLn("    count = count+1");
        WriteLn("   common");
        WriteLn("    module db dllname,0");
        WriteLn("   forward");
        WriteLn("    name db string,0");
        WriteLn("   common");
        WriteLn("    local x,y,z,str1,str2,v1,v2");
        WriteLn("    x = count shr 1");
        WriteLn("    while x > 0");
        WriteLn("     y = x");
        WriteLn("     while y < count");
        WriteLn("      z = y");
        WriteLn("      while z-x >= 0");
        WriteLn("       load v1 dword from names+z*4");
        WriteLn("       str1=($-RVA $)+v1");
        WriteLn("       load v2 dword from names+(z-x)*4");
        WriteLn("       str2=($-RVA $)+v2");
        WriteLn("       while v1 > 0");
        WriteLn("        load v1 from str1+%-1");
        WriteLn("        load v2 from str2+%-1");
        WriteLn("        if v1 <> v2");
        WriteLn("         break");
        WriteLn("        end if");
        WriteLn("       end while");
        WriteLn("       if v1<v2");
        WriteLn("        load v1 dword from names+z*4");
        WriteLn("        load v2 dword from names+(z-x)*4");
        WriteLn("        store dword v1 at names+(z-x)*4");
        WriteLn("        store dword v2 at names+z*4");
        WriteLn("        load v1 word from ordinal+z*2");
        WriteLn("        load v2 word from ordinal+(z-x)*2");
        WriteLn("        store word v1 at ordinal+(z-x)*2");
        WriteLn("        store word v2 at ordinal+z*2");
        WriteLn("       else");
        WriteLn("        break");
        WriteLn("       end if");
        WriteLn("       z = z-x");
        WriteLn("      end while");
        WriteLn("      y = y+1");
        WriteLn("     end while");
        WriteLn("     x = x shr 1");
        WriteLn("    end while }");

        WriteLn("section '.text' code readable executable");
        WriteLn("start:");
        WriteLn("push r8");
        WriteLn("push rdx");
        WriteLn("push rcx");
        CallRTL(pic, CODE._dllentry);
        test(rax);
        WriteLn("je DLLRET")
    END;

    pushc(0);
    pushc(0);
    WriteLn("push TYPES");
    pushc(CHL.Length(code.types));
    WriteLn("push MODNAME");
    CallRTL(pic, CODE._init)
END prolog;


PROCEDURE epilog (code: CODE.CODES; modname: ARRAY OF CHAR; pic: BOOLEAN; target: INTEGER);
VAR
    i, n: INTEGER;
    number: Number;
    exp: CODE.EXPORT_PROC;


    PROCEDURE import (code: CODE.CODES);
    VAR
        lib: CODE.IMPORT_LIB;
        proc: CODE.IMPORT_PROC;
        n: INTEGER;

    BEGIN
        WriteLn("section '.idata' import data readable writeable");
        lib := code.import.first(CODE.IMPORT_LIB);
        n := 0;
        WHILE lib # NIL DO
            Write("dd 0,0,0,RVA lib_name"); WriteHex(n); Write(",RVA lib_table"); WriteHexLn(n);
            lib := lib.next(CODE.IMPORT_LIB);
            INC(n)
        END;
        WriteLn("dd 0,0,0,0,0");

        lib := code.import.first(CODE.IMPORT_LIB);
        n := 0;
        WHILE lib # NIL DO
            Write("lib_table"); WriteHex(n); WriteLn(":");
            proc := lib.procs.first(CODE.IMPORT_PROC);
            WHILE proc # NIL DO
                Write("P"); WriteHex(proc.label); Write(" dq RVA N"); WriteHexLn(proc.label);
                proc := proc.next(CODE.IMPORT_PROC)
            END;
            WriteLn("dq 0");
            lib := lib.next(CODE.IMPORT_LIB);
            INC(n)
        END;

        lib := code.import.first(CODE.IMPORT_LIB);
        n := 0;
        WHILE lib # NIL DO
            Write("lib_name"); WriteHex(n); Write(" db '"); Write(lib.name); WriteLn("',0");
            lib := lib.next(CODE.IMPORT_LIB);
            INC(n)
        END;

        lib := code.import.first(CODE.IMPORT_LIB);
        n := 0;
        WHILE lib # NIL DO
            proc := lib.procs.first(CODE.IMPORT_PROC);
            WHILE proc # NIL DO
                Write("N"); WriteHex(proc.label); WriteLn(" dw 0");
                Write("db '"); Write(proc.name); WriteLn("',0");
                proc := proc.next(CODE.IMPORT_PROC)
            END;
            lib := lib.next(CODE.IMPORT_LIB);
            INC(n)
        END

    END import;

BEGIN
    IF target = mConst.Target_iDLL64 THEN
        WriteLn("DLLRET: ret")
    ELSE
        pushc(0);
        CallRTL(pic, CODE._exit)
    END;

    WriteLn("section '.data' data readable writeable");
    WriteLn("_data:");
    WriteLn("TYPES:");
    i := 0;
    WHILE i < CHL.Length(code.types) DO
        IF i MOD 4 = 0 THEN
            WriteLn("");
            Write("dq ")
        ELSE
            Write(",")
        END;
        WriteHex(CHL.GetInt(code.types, i));
        INC(i)
    END;

    WriteLn("");
    WriteLn("STRINGS:");
    i := 0;
    WHILE i < CHL.Length(code.data) DO
        IF i MOD 12 = 0 THEN
            WriteLn("");
            Write("db ")
        ELSE
            Write(",")
        END;
        WriteByte(CHL.GetByte(code.data, i));
        INC(i)
    END;

    WriteLn("");
    Write("MODNAME: db '"); Write(modname); Write(".exe"); WriteLn("',0");
    WriteLn("align 16");
    WriteLn("NUMBERS:");
    number := Numbers.first(Number);
    FOR i := 0 TO Numbers_Count - 1 DO
        Write("dq "); WriteHexLn(number.value);
        number := number.next(Number)
    END;

    WriteLn("section '.bss' data readable writeable");

    n := code.dmin - CHL.Length(code.data);
    IF n > 0 THEN
        INC(code.bss, n)
    END;

    Write("GLOB: rb "); WriteHexLn(MAX(code.bss, 8));

    IF target = mConst.Target_iDLL64 THEN
        exp := code.export.first(CODE.EXPORT_PROC);
        IF exp # NIL THEN
            WriteLn("section '.edata' export data readable");

            Write("export '"); Write(modname); Write(".dll"); Write("'");

            WHILE exp # NIL DO
                WriteLn(",\");
                Write("L"); WriteHex(exp.label); Write(",'"); Write(exp.name); Write("'");
                exp := exp.next(CODE.EXPORT_PROC)
            END;

            WriteLn("")
        END
    END;

    import(code);

    WriteLn("section '.reloc' fixups data readable discardable")
END epilog;


PROCEDURE CodeGen* (code: CODE.CODES; outname: ARRAY OF CHAR; target, stack, base, ver: INTEGER; pic, reloc: BOOLEAN);
VAR
    path, modname, ext: PATHS.PATH;

BEGIN

    eol[0] := 0DX;
    eol[1] := 0AX;
    eol[2] := 0X;

    regs[rax] := "rax";
    regs[rcx] := "rcx";
    regs[rdx] := "rdx";
    regs[r8]  := "r8";
    regs[r9]  := "r9";
    regs[r10] := "r10";
    regs[r11] := "r11";

    regs8[rax] := "al";
    regs8[rcx] := "cl";
    regs8[rdx] := "dl";
    regs8[r8]  := "r8l";
    regs8[r9]  := "r9l";
    regs8[r10] := "r10l";
    regs8[r11] := "r11l";

    regs16[rax] := "ax";
    regs16[rcx] := "cx";
    regs16[rdx] := "dx";
    regs16[r8]  := "r8w";
    regs16[r9]  := "r9w";
    regs16[r10] := "r10w";
    regs16[r11] := "r11w";

    regs32[rax] := "eax";
    regs32[rcx] := "ecx";
    regs32[rdx] := "edx";
    regs32[r8]  := "r8d";
    regs32[r9]  := "r9d";
    regs32[r10] := "r10d";
    regs32[r11] := "r11d";

    file := WR.Create(outname);
    PATHS.split(outname, path, modname, ext);

    R := REG.Create(push, pop, mov, xchg, {rax, r10, r11});

    Numbers := LISTS.create(NIL);
    Numbers_Count := 0;
    NewNumber(ROR(1, 1));      (* 8000000000000000H *)
    NewNumber(0);
    NewNumber(ROR(-2, 1));     (* 7FFFFFFFFFFFFFFFH *)
    NewNumber(-1);
    NewNumber(ROR(7FFH, 12));  (* +Infinity *)

    pic := FALSE;
    prolog(code, pic, target, stack);
    translate(code.commands, pic, CHL.Length(code.types) * 8);
    epilog(code, modname, pic, target);
    WR.Close(file)

END CodeGen;


END AMD64.