MODULE FILES;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mUtil := UTILS,
	mCol := COLLECTIONS, CONSOLE;

TYPE
	tpFile* = POINTER TO RECORD (mCol.tpItem)
		ptr: INTEGER;
		buffer: ARRAY 64*1024 OF BYTE;
		count:  INTEGER
	END;

VAR
	files: mCol.tpCollection;

PROCEDURE Copy (pSrc: ARRAY OF BYTE; pSrcIdx: INTEGER; VAR pDst: ARRAY OF BYTE; pDstIdx: INTEGER; pBytes: INTEGER);
	(* Copy array of bytes from source to destinace *)
	BEGIN
		WHILE pBytes > 0 DO
			pDst[pDstIdx] := pSrc[pSrcIdx];
			INC(pDstIdx);
			INC(pSrcIdx);
			DEC(pBytes)
		END
	END Copy;


PROCEDURE Flush (pFile: tpFile): INTEGER;
	VAR
		iRes: INTEGER;
	BEGIN
		IF pFile # NIL THEN
			iRes := mUtil.FileWrite(pFile.ptr, pFile.buffer, pFile.count);
			IF iRes < 0 THEN
				iRes := 0
			END
		ELSE
			iRes := 0
		END

		RETURN iRes
	END Flush;

PROCEDURE New(): tpFile;
	VAR
		fileRes:  tpFile;
		citem: mCol.tpItem;

	BEGIN
		citem := mCol.Pop(files);
		IF citem = NIL THEN
			NEW(fileRes)
		ELSE
			fileRes := citem(tpFile)
		END

		RETURN fileRes
	END New;

PROCEDURE Create* (pName: ARRAY OF CHAR): tpFile;
	VAR
		fileRes: tpFile;
		ptr:  INTEGER;

	BEGIN
		ptr := mUtil.FileCreate(pName);

		IF ptr > 0 THEN
			fileRes := New();
			fileRes.ptr := ptr;
			fileRes.count := 0
		ELSE
			fileRes := NIL
		END

		RETURN fileRes
	END Create;

PROCEDURE Open* (pName: ARRAY OF CHAR): tpFile;
	VAR
		fileRes: tpFile;
		ptr:  INTEGER;

	BEGIN
		ptr := mUtil.FileOpen(pName);

		IF ptr > 0 THEN
			fileRes := New();
			fileRes.ptr := ptr;
			fileRes.count := -1
		ELSE
			fileRes := NIL
		END

		RETURN fileRes
	END Open;

PROCEDURE Close* (VAR pFile: tpFile);
	VAR
		n: INTEGER;

	BEGIN
		IF pFile # NIL THEN

			IF pFile.count > 0 THEN
				n := Flush(pFile)
			END;

			pFile.count := -1;

			mUtil.FileClose(pFile.ptr);
			pFile.ptr := 0;

			mCol.Push(files, pFile);
			pFile := NIL
		END
	END Close;

PROCEDURE Read* (pFile: tpFile; VAR pChunk: ARRAY OF BYTE; pBytes: INTEGER): INTEGER;
	VAR
		iRes: INTEGER;
	BEGIN
		IF pFile # NIL THEN
			iRes := mUtil.FileRead(pFile.ptr, pChunk, MAX(MIN(pBytes, LEN(pChunk)), 0));
			IF iRes < 0 THEN
				iRes := 0
			END
		ELSE
			iRes := 0
		END
		RETURN iRes
	END Read;

PROCEDURE Write* (pFile: tpFile; pChunk: ARRAY OF BYTE; pBytes: INTEGER): INTEGER;
	VAR
		free, n, k, iRes, idx: INTEGER;

	BEGIN
		idx := 0;
		iRes := 0;
		IF (pFile # NIL) & (pFile.count >= 0) THEN

			free := LEN(pFile.buffer) - pFile.count;
			WHILE pBytes > 0 DO
				n := MIN(free, pBytes);
				Copy(pChunk, idx, pFile.buffer, pFile.count, n);
				INC(iRes, n);
				DEC(free, n);
				DEC(pBytes, n);
				INC(idx, n);
				INC(pFile.count, n);
				IF free = 0 THEN
					k := Flush(pFile);
					IF k # LEN(pFile.buffer) THEN
						pBytes := 0;
						DEC(iRes, n)
					ELSE
						pFile.count := 0;
						free := LEN(pFile.buffer)
					END
				END
			END

		END

		RETURN iRes
	END Write;

PROCEDURE WriteByte* (pFile: tpFile; pByte: BYTE): BOOLEAN;
	VAR
		bRes: BOOLEAN;

	BEGIN
		bRes := TRUE;
		IF (pFile # NIL) & (pFile.count >= 0) THEN
			IF pFile.count = LEN(pFile.buffer) THEN
				IF Flush(pFile) # LEN(pFile.buffer) THEN
					bRes := FALSE
				ELSE
					pFile.buffer[0] := pByte;
					pFile.count := 1
				END
			ELSE
				pFile.buffer[pFile.count] := pByte;
				INC(pFile.count)
			END
		ELSE
			bRes := FALSE
		END

		RETURN bRes
	END WriteByte;

BEGIN
	files := mCol.New()
END FILES.
