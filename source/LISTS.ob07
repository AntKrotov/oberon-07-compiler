MODULE LISTS;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mCol := COLLECTIONS;

TYPE
	tpItem* = POINTER TO RECORD (mCol.tpItem)
		prev*, next*: tpItem
	END;

	tpList* = POINTER TO RECORD
		first*, last*: tpItem
	END;

PROCEDURE Add* (pList: tpList; pItem: tpItem);
	BEGIN
		ASSERT(pList # NIL);
		ASSERT(pItem # NIL);

		IF pList.first = NIL THEN
			pList.first := pItem;
			pList.last  := pItem;
			pItem.prev  := NIL;
			pItem.next  := NIL
		ELSE
			ASSERT(pList.last # NIL);

			pItem.prev := pList.last;
			pList.last.next := pItem;
			pItem.next := NIL;
			pList.last := pItem
		END
	END Add;

PROCEDURE Delete* (pList: tpList): tpItem;
	VAR
		_last: tpItem;
	BEGIN
		ASSERT(pList # NIL);

		_last := pList.last;

		IF _last # NIL THEN
			IF _last = pList.first THEN
				pList.first := NIL;
				pList.last := NIL
			ELSE
				pList.last := _last.prev;
				pList.last.next := NIL
			END;

			_last.next := NIL;
			_last.prev := NIL
		END

		RETURN _last
	END Delete;

PROCEDURE Insert* (pList: tpList; pCur, pNov: tpItem);
	VAR
		_next: tpItem;
	BEGIN
		ASSERT(pList # NIL);
		ASSERT(pNov # NIL);
		ASSERT(pCur # NIL);

		_next := pCur.next;

		IF _next # NIL THEN
			_next.prev := pNov;
			pNov.next := _next;
			pCur.next := pNov;
			pNov.prev := pCur
		ELSE
			Add(pList, pNov)
		END

	END Insert;

PROCEDURE InsertL* (pList: tpList; pCur, pNov: tpItem);
	VAR
		_prev: tpItem;
	BEGIN
		ASSERT(pList # NIL);
		ASSERT(pNov # NIL);
		ASSERT(pCur # NIL);

		_prev := pCur.prev;

		IF _prev # NIL THEN
			_prev.next := pNov;
			pNov.prev := _prev;
			pCur.prev := pNov;
			pNov.next := pCur
		ELSE
			pNov.prev := NIL;
			pCur.prev := pNov;
			pNov.next := pCur;
			pList.first := pNov
		END

	END InsertL;

PROCEDURE Del* (pList: tpList; pItem: tpItem);
	VAR
		_prev, _next: tpItem;
	BEGIN
		ASSERT(pList # NIL);
		ASSERT(pItem # NIL);

		_prev := pItem.prev;
		_next := pItem.next;

		IF (_next # NIL) & (_prev # NIL) THEN
			_prev.next := _next;
			_next.prev := _prev
		ELSIF (_next = NIL) & (_prev = NIL) THEN
			pList.first := NIL;
			pList.last := NIL
		ELSIF (_next = NIL) & (_prev # NIL) THEN
			_prev.next := NIL;
			pList.last := _prev
		ELSIF (_next # NIL) & (_prev = NIL) THEN
			_next.prev := NIL;
			pList.first := _next
		END
	END Del;

PROCEDURE Count_Get* (pList: tpList): INTEGER;
	VAR
		_item: tpItem;
		res:  INTEGER;
	BEGIN
		ASSERT(pList # NIL);
		res := 0;

		_item := pList.first;
		WHILE _item # NIL DO
			INC(res);
			_item := _item.next
		END

		RETURN res
	END Count_Get;

PROCEDURE New* (pList: tpList): tpList;
	BEGIN
		IF pList = NIL THEN
			NEW(pList)
		END;

		pList.first  := NIL;
		pList.last   := NIL

		RETURN pList
	END New;

END LISTS.
