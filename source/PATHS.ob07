MODULE PATHS;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mStr := STRINGS,
	mUtil := UTILS,
	mConst := modConstante;

TYPE
	tPath* = ARRAY mConst.pathLen OF CHAR;

PROCEDURE Split* (pFileName: ARRAY OF CHAR; VAR pPath, pName, pExt: ARRAY OF CHAR);
	VAR
		_pos1, _pos2, _len: INTEGER;
	BEGIN
		_len := LENGTH(pFileName);
		_pos1 := _len - 1;
		_pos2 := _len - 1;
		mStr.search(pFileName, _pos1, mConst.slash, FALSE);
		mStr.search(pFileName, _pos2,   ".", FALSE);

		pPath := pFileName;
		pPath[_pos1 + 1] := 0X;

		IF (_pos2 = -1) OR (_pos2 < _pos1) THEN
			_pos2 := _len
		END;

		INC(_pos1);

		mStr.copy(pFileName, pName, _pos1, 0, _pos2 - _pos1);
		pName[_pos2 - _pos1] := 0X;
		mStr.copy(pFileName, pExt, _pos2, 0, _len - _pos2);
		pExt[_len - _pos2] := 0X;

	END Split;

PROCEDURE RelPath* (pAbsolute, pRelative: ARRAY OF CHAR; VAR pRes: ARRAY OF CHAR);
	VAR
		_i, _j: INTEGER;
		_bError: BOOLEAN;
	BEGIN
		COPY(pAbsolute, pRes);
		_i := LENGTH(pRes) - 1;
		WHILE (_i >= 0) & (pRes[_i] # mConst.slash) DO
			DEC(_i)
		END;

		INC(_i);
		pRes[_i] := 0X;

		_bError := FALSE;
		_j := 0;
		WHILE ~_bError & (pRelative[_j] # 0X) DO
			IF (pRelative[_j] = ".") & (pRelative[_j + 1] = ".") & (pRelative[_j + 2] = mConst.slash) & (_i > 0) & (pRes[_i - 1] = mConst.slash) THEN
				DEC(_i, 2);
				WHILE (_i >= 0) & (pRes[_i] # mConst.slash) DO
					DEC(_i)
				END;
				IF _i < 0 THEN
					_bError := TRUE
				ELSE
					INC(_i);
					INC(_j, 3)
				END
			ELSE
				pRes[_i] := pRelative[_j];
				INC(_i);
				INC(_j)
			END
		END;

		IF _bError THEN
			COPY(pRelative, pRes)
		ELSE
			pRes[_i] := 0X
		END
	END RelPath;   

PROCEDURE IsRelative* (pPath: ARRAY OF CHAR): BOOLEAN;
		RETURN mUtil.isRelative(pPath)
	END IsRelative;  

PROCEDURE CurrentDirectory_Get* (VAR pPath: ARRAY OF CHAR);
	BEGIN
		mUtil.GetCurrentDirectory(pPath)
	END CurrentDirectory_Get;

END PATHS.
