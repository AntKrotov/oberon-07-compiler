MODULE CODE;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mList := LISTS,
	mScan := SCAN,
	mStr  := STRINGS,
	mChl := CHUNKLISTS,
	mConst := modConstante;

CONST
	numRegsFloat* = 8; (* NOT CHANGE!!! This num CPU Float Registers!! *)

	opCOPYS* = 2; opGADR* = 3; opCONST* = 4; opLLOAD32* = 5;
	opCOPYA* = 6; opCASET* = 7; opMULC* = 8; opMUL* = 9;
	opDIV* = 10; opMOD* = 11; opDIVL* = 12; opMODL* = 13; opDIVR* = 14; opMODR* = 15;
	opUMINUS* = 16;
	opADD* = 17; opSUB* = 18; opADDL* = 19; opSUBL* = 20; opADDR* = 21; opSUBR* = 22;
	opSAVE* = 23; opSAVEC* = 24; opSAVE8* = 25; opSAVE8C* = 26; opACC* = 27; opDROP* = 28;
	opNOT* = 29;

	opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
	opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
	opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

	opVLOAD32* = 48; opGLOAD32* = 49;

	opJNE* = 50; opJE* = 51;

	opEQS* = 52; opNES* = 53; opLTS* = 54; opLES* = 55; opGTS* = 56; opGES* = 57;

	opSAVE32* = 58; opLLOAD8* = 59;

	opCONSTF* = 60; opLOADF* = 61; opSAVEF* = 62; opMULF* = 63; opDIVF* = 64; opDIVFI* = 65;
	opUMINF* = 66; opADDFI* = 67; opSUBFI* = 68; opADDF* = 69; opSUBF* = 70;

	opINC1B* = 71; opDEC1B* = 72; opINCCB* = 73; opDECCB* = 74; opINCB* = 75; opDECB* = 76;

	opCASEL* = 77; opCASER* = 78; opCASELR* = 79;

	opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
	opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

	opLOAD8* = 92; opLOAD16* = 93; opLOAD32* = 94; opPRECALL* = 95; opRES* = 96; opRESF* = 97;
	opERRC* = 98; opSWITCH* = 99;

	opSBOOL* = 100; opSBOOLC* = 101; opNOP* = 102;

	opMULS* = 103; opMULSC* = 104; opDIVS* = 105; opDIVSC* = 106;
	opADDS* = 107; opSUBS* = 108; opADDSL* = 109; opSUBSL* = 110; opADDSR* = 111; opSUBSR* = 112;
	opUMINS* = 113; opIN* = 114; opINL* = 115; opINR* = 116;
	opRSET* = 117; opRSETL* = 118; opRSETR* = 119; opRSET1* = 120; opLENGTH* = 121;

	opINC1* = 122; opDEC1* = 123; opINCC* = 124; opDECC* = 125; opINC* = 126; opDEC* = 127;
	opINCL* = 128; opEXCL* = 129; opINCLC* = 130; opEXCLC* = 131; opNEW* = 132; opDISP* = 133;
	opPACK* = 134; opPACKC* = 135; opUNPK* = 136; opCOPY* = 137; opENTER* = 138; opLEAVE* = 139;
	opCALL* = 140; opSAVEP* = 141; opCALLP* = 142; opEQP* = 143; opNEP* = 144; opLEAVER* = 145;
	opGET* = 146; opSAVE16* = 147; opABS* = 148; opFABS* = 149; opFLOOR* = 150; opFLT* = 151;
	opODD* = 152; opORD* = 153; opASR* = 154; opLSL* = 155; opROR* = 156;
	opASR1* = 157; opLSL1* = 158; opROR1* = 159; opASR2* = 160; opLSL2* = 161; opROR2* = 162;
	opPUSHP* = 163; opLADR* = 164; opTYPEGP* = 165; opIS* = 166; opPUSHF* = 167; opVADR* = 168;
	opPUSHT* = 169; opTYPEGR* = 170; opISREC* = 171; opCHKIDX* = 172; opPARAM* = 173;
	opCHKIDX2* = 174; opLEN* = 175; opROT* = 176; opSAVES* = 177; opSADR* = 178; opERR* = 179;

	opCHR* = 180; opENDSW* = 181; opLEAVEF* = 182; opCLEANUP* = 183; opMOVE* = 184;
	opLSR* = 185; opLSR1* = 186; opLSR2* = 187;
	opMIN* = 188; opMINC* = 189; opMAX* = 190; opMAXC* = 191; opJNZ* = 192;
	opEQB* = 193; opNEB* = 194; opINF* = 195; opJZ* = 196; opVLOAD8* = 197; opGLOAD8* = 198;
	opLLOAD16* = 199; opVLOAD16* = 200; opGLOAD16* = 201;
	opLOAD64* = 202; opLLOAD64* = 203; opVLOAD64* = 204; opGLOAD64* = 205; opSAVE64* = 206;

	opTYPEGD* = 207; opCALLI* = 208; opPUSHIP* = 209; opSAVEIP* = 210; opEQIP* = 211; opNEIP* = 212;
	opSAVE16C* = 213; opWCHR* = 214; opCOPYS2* = 215; opLENGTHW* = 216;

	opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
	opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
	opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;

	opCODE* = 235;


	_move      *=   0;
	_move2     *=   1;
	_in        *=   2;
	_in2       *=   3;
	_set       *=   4;
	_set2      *=   5;
	_incl      *=   6;
	_excl      *=   7;
	_div       *=   8;
	_mod       *=   9;
	_div2      *=  10;
	_mod2      *=  11;
	_arrcpy    *=  12;
	_rot       *=  13;
	_new       *=  14;
	_dispose   *=  15;
	_strcmp    *=  16;
	_error     *=  17;
	_is        *=  18;
	_isrec     *=  19;
	_guard     *=  20;
	_guardrec  *=  21;
	_length    *=  22;
	_init      *=  23;
	_dllentry  *=  24;
	_strcpy    *=  25;
	_exit      *=  26;
	_strcpy2   *=  27;
	_lengthw   *=  28;
	_strcmp2   *=  29;
	_strcmpw   *=  30;
	_strcmpw2  *=  31;

TYPE
	tpCommand* = POINTER TO RECORD (mList.tpItem)
			opCode*:  INTEGER; (* Code operation. Defined in modConstante *)
			param1*:  INTEGER; (* Param1 for opCode *)
			param2*:  INTEGER  (* Param2 for opCode *)
		END;

	tpCommand3* = POINTER TO RECORD (tpCommand)
			param3*:  INTEGER
		END;

	tpCommandFloat* = POINTER TO RECORD (tpCommand)
			valFloat*:   REAL
		END;

	tpCmdStack = POINTER TO RECORD
			aData: ARRAY 1000 OF tpCommand;
			top:  INTEGER
		END;

	tpProcExport* = POINTER TO RECORD (mList.tpItem)
			label*: INTEGER;
			lexName*:  mScan.LEXSTR
		END;

	tpLibImport* = POINTER TO RECORD (mList.tpItem)
			lexName*:   mScan.LEXSTR;
			procs*:  mList.tpList
		END;

	tpProcImport* = POINTER TO RECORD (mList.tpItem)
			label*: INTEGER;
			lib*:   tpLibImport;
			lexName*:  mScan.LEXSTR;
			count:  INTEGER
		END;

	tpCodes* = POINTER TO RECORD
			last:       tpCommand;
			call_beg:    tpCmdStack;
			call_end:    tpCmdStack;
			commands*:  mList.tpList;
			export*:    mList.tpList;
			import*:    mList.tpList;
			types*:     mChl.INTLIST;
			data*:      mChl.BYTELIST;
			dmin*:      INTEGER;
			lcount*:    INTEGER;
			bss*:       INTEGER;
			rtl*:       ARRAY 32 OF INTEGER;

			charoffs:   ARRAY 256 OF INTEGER;
			wcharoffs:  ARRAY 65536 OF INTEGER;

			fregs:      INTEGER;
			wstr:       ARRAY 4*1024 OF WCHAR;

			errLabel*:  INTEGER
		END;

VAR
	codes*: tpCodes;

PROCEDURE Last_Set* (pCmd: tpCommand);
	BEGIN
		codes.last := pCmd
	END Last_Set;

PROCEDURE Last_Get* (): tpCommand;
		RETURN codes.last
	END Last_Get;

PROCEDURE Byte_Put (pCodes: tpCodes; pByte: BYTE);
	BEGIN
		mChl.PushByte(pCodes.data, pByte)
	END Byte_Put;

PROCEDURE Str_Put* (pStr: ARRAY OF CHAR): INTEGER;
	VAR
		_i, _n, _res: INTEGER;
	BEGIN
		_res := mChl.Length(codes.data);

		_i := 0;
		_n := LENGTH(pStr);
		WHILE _i < _n DO
			Byte_Put(codes, ORD(pStr[_i]));
			INC(_i)
		END;

		Byte_Put(codes, 0)

		RETURN _res
	END Str_Put;

PROCEDURE Str_Put1* (pNum: INTEGER): INTEGER;
	VAR
		_res: INTEGER;
	BEGIN
		IF codes.charoffs[pNum] = -1 THEN
			_res := mChl.Length(codes.data);
			Byte_Put(codes, pNum);
			Byte_Put(codes, 0);
			codes.charoffs[pNum] := _res
		ELSE
			_res := codes.charoffs[pNum]
		END

		RETURN _res
	END Str_Put1;

PROCEDURE Str_PutW* (pStr: ARRAY OF CHAR): INTEGER;
	VAR
		pNum_i, _n, _res: INTEGER;
	BEGIN
		_res := mChl.Length(codes.data);
		IF ODD(_res) THEN
			Byte_Put(codes, 0);
			INC(_res)
		END;
		_n := mStr.Utf8To16(pStr, codes.wstr);
		pNum_i := 0;
		WHILE pNum_i < _n DO
			Byte_Put(codes, ORD(codes.wstr[pNum_i]) MOD 256);
			Byte_Put(codes, ORD(codes.wstr[pNum_i]) DIV 256);
			INC(pNum_i)
		END;
		Byte_Put(codes, 0);
		Byte_Put(codes, 0)
		RETURN _res
	END Str_PutW;

PROCEDURE Str_PutW1* (pNum: INTEGER): INTEGER;
	VAR
		_res: INTEGER;
	BEGIN
		IF codes.wcharoffs[pNum] = -1 THEN
			_res := mChl.Length(codes.data);

			IF ODD(_res) THEN
				Byte_Put(codes, 0);
				INC(_res)
			END;

			Byte_Put(codes, pNum MOD 256);
			Byte_Put(codes, pNum DIV 256);
			Byte_Put(codes, 0);
			Byte_Put(codes, 0);

			codes.wcharoffs[pNum] := _res
		ELSE
			_res := codes.wcharoffs[pNum]
		END
		RETURN _res
	END Str_PutW1;

PROCEDURE MinDataSize_Set* (pSize: INTEGER);
	BEGIN
		codes.dmin := mChl.Length(codes.data) + pSize
	END MinDataSize_Set;

PROCEDURE Push (pStack: tpCmdStack; pCmd: tpCommand);
	BEGIN
		INC(pStack.top);
		pStack.aData[pStack.top] := pCmd
	END Push;

PROCEDURE Pop (pStack: tpCmdStack): tpCommand;
	VAR
		_res: tpCommand;
	BEGIN
		_res := pStack.aData[pStack.top];
		DEC(pStack.top)
		RETURN _res
	END Pop;

PROCEDURE BegEnd_Push* (VAR pBeg, pEnd: tpCommand);
	BEGIN
		Push(codes.call_beg, pBeg);
		Push(codes.call_end, pEnd);
		pBeg := codes.last;
		pEnd := pBeg.next(tpCommand)
	END BegEnd_Push;

PROCEDURE BegEnd_Pop* (VAR pBeg, pEnd: tpCommand);
	BEGIN
		pBeg := Pop(codes.call_beg);
		pEnd := Pop(codes.call_end)
	END BegEnd_Pop;

PROCEDURE Rec_Add* (pBase: INTEGER);
	BEGIN
		mChl.PushInt(codes.types, pBase)
	END Rec_Add;

PROCEDURE Insert (pCur, pNow: tpCommand); (* pNow = pNew ???? *)
	BEGIN
		mList.Insert(codes.commands, pCur, pNow);
		codes.last := pNow
	END Insert;

PROCEDURE Cmd_Add* (pOpCode: INTEGER; pNum: INTEGER);
	VAR
		_cmd: tpCommand;
	BEGIN
		NEW(_cmd);
		_cmd.opCode := pOpCode;
		_cmd.param1 := 0;
		_cmd.param2 := pNum;
		Insert(codes.last, _cmd)
	END Cmd_Add;

PROCEDURE Cmd2_Add* (pOpCode: INTEGER; param1, param2: INTEGER);
	VAR
		_cmd: tpCommand;
	BEGIN
		NEW(_cmd);
		_cmd.opCode := pOpCode;
		_cmd.param1 := param1;
		_cmd.param2 := param2;
		Insert(codes.last, _cmd)
	END Cmd2_Add;

PROCEDURE Label_New* (): INTEGER;
	BEGIN
		INC(codes.lcount)
		RETURN codes.lcount - 1
	END Label_New;

PROCEDURE Label_Set* (pLabel: INTEGER);
	BEGIN
		Cmd_Add(mConst.codeLABEL, pLabel)
	END Label_Set;

PROCEDURE LabelErr_Set*;
	BEGIN
		codes.errLabel := Label_New();
		Label_Set(codes.errLabel)
	END LabelErr_Set;

PROCEDURE Cmd0_Add* (pOpCode: INTEGER);
	BEGIN
		Cmd_Add(pOpCode, 0)
	END Cmd0_Add;

PROCEDURE Delete (pCmd: tpCommand);
	BEGIN
		mList.Del(codes.commands, pCmd)
	END Delete;

PROCEDURE CmdJmp_Add* (pOpCode: INTEGER; pLabel: INTEGER);
	VAR
		_prev: tpCommand;
		_not:  BOOLEAN;
	BEGIN
		_prev := codes.last;
		_not := _prev.opCode = opNOT;
		IF _not THEN
			IF pOpCode = opJE THEN
				pOpCode := opJNE
			ELSIF pOpCode = opJNE THEN
				pOpCode := opJE
			ELSE
				_not := FALSE
			END
		END;
		Cmd2_Add(pOpCode, pLabel, pLabel);
		IF _not THEN
			Delete(_prev)
		END
	END CmdJmp_Add;

PROCEDURE OnError* (pLine, pError: INTEGER);
	BEGIN
		Cmd_Add(opERRC, LSL(pLine, 4) + pError);
		CmdJmp_Add(mConst.codeJMP, codes.errLabel)
	END OnError;

PROCEDURE Type_Guard* (pOp, pType: INTEGER; pLine, pError: INTEGER);
	VAR
		_label: INTEGER;
	BEGIN
		Cmd_Add(pOp, pType);
		_label := Label_New();
		CmdJmp_Add(opJE, _label);
		OnError(pLine, pError);
		Label_Set(_label)
	END Type_Guard;

PROCEDURE Type_Check* (pType: INTEGER);
	BEGIN
		Cmd_Add(opIS, pType)
	END Type_Check;

PROCEDURE TypeRec_Check* (pType: INTEGER);
	BEGIN
		Cmd_Add(opISREC, pType)
	END TypeRec_Check;

PROCEDURE New* (pSize, pTypeNum: INTEGER);
	BEGIN
		Cmd2_Add(opNEW, pTypeNum, pSize)
	END New;

PROCEDURE fcmp* (pOpCode: BYTE);
	BEGIN
		Cmd_Add(pOpCode, 0);
		DEC(codes.fregs, 2);
		ASSERT(codes.fregs >= 0)
	END fcmp;

PROCEDURE IsCmp (pOpCode: BYTE): BOOLEAN;
	(*
		opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
		opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
		opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

		opEQS*   =  52; opNES*   =  53; opLTS*   =  54; opLES*   =  55; opGTS*   =  56; opGES*   =  57;
		opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
		opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
		opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;

		opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
		opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

		opEQP* = 143; opNEP* = 144;
																					  *)

		RETURN (opEQ <= pOpCode) & (pOpCode <= opGER) OR (opEQS <= pOpCode) & (pOpCode <= opGES) OR
				(opEQS2 <= pOpCode) & (pOpCode <= opGES2) OR (opEQSW <= pOpCode) & (pOpCode <= opGESW) OR
				(opEQSW2 <= pOpCode) & (pOpCode <= opGESW2) OR
				(opEQF <= pOpCode) & (pOpCode <= opGEFI) OR (pOpCode = opEQP) OR (pOpCode = opNEP)
	END IsCmp;

PROCEDURE Cmp_Inv (pOpCode: BYTE): INTEGER;
	BEGIN
		CASE pOpCode OF

		|opEQ:    pOpCode := opNE
		|opNE:    pOpCode := opEQ
		|opLT:    pOpCode := opGE
		|opLE:    pOpCode := opGT
		|opGT:    pOpCode := opLE
		|opGE:    pOpCode := opLT

		|opEQR:   pOpCode := opNER
		|opNER:   pOpCode := opEQR
		|opLTR:   pOpCode := opGER
		|opLER:   pOpCode := opGTR
		|opGTR:   pOpCode := opLER
		|opGER:   pOpCode := opLTR

		|opEQL:   pOpCode := opNEL
		|opNEL:   pOpCode := opEQL
		|opLTL:   pOpCode := opGEL
		|opLEL:   pOpCode := opGTL
		|opGTL:   pOpCode := opLEL
		|opGEL:   pOpCode := opLTL

		|opEQS:   pOpCode := opNES
		|opNES:   pOpCode := opEQS
		|opLTS:   pOpCode := opGES
		|opLES:   pOpCode := opGTS
		|opGTS:   pOpCode := opLES
		|opGES:   pOpCode := opLTS

		|opEQS2:  pOpCode := opNES2
		|opNES2:  pOpCode := opEQS2
		|opLTS2:  pOpCode := opGES2
		|opLES2:  pOpCode := opGTS2
		|opGTS2:  pOpCode := opLES2
		|opGES2:  pOpCode := opLTS2

		|opEQSW:  pOpCode := opNESW
		|opNESW:  pOpCode := opEQSW
		|opLTSW:  pOpCode := opGESW
		|opLESW:  pOpCode := opGTSW
		|opGTSW:  pOpCode := opLESW
		|opGESW:  pOpCode := opLTSW

		|opEQSW2: pOpCode := opNESW2
		|opNESW2: pOpCode := opEQSW2
		|opLTSW2: pOpCode := opGESW2
		|opLESW2: pOpCode := opGTSW2
		|opGTSW2: pOpCode := opLESW2
		|opGESW2: pOpCode := opLTSW2

		|opEQF:   pOpCode := opNEF
		|opNEF:   pOpCode := opEQF
		|opLTF:   pOpCode := opGEF
		|opLEF:   pOpCode := opGTF
		|opGTF:   pOpCode := opLEF
		|opGEF:   pOpCode := opLTF

		|opEQFI:  pOpCode := opNEFI
		|opNEFI:  pOpCode := opEQFI
		|opLTFI:  pOpCode := opGEFI
		|opLEFI:  pOpCode := opGTFI
		|opGTFI:  pOpCode := opLEFI
		|opGEFI:  pOpCode := opLTFI

		|opEQP:   pOpCode := opNEP
		|opNEP:   pOpCode := opEQP

		END

		RETURN pOpCode
	END Cmp_Inv;

PROCEDURE Not*;
	VAR
		_prev: tpCommand;
	BEGIN
		_prev := codes.last;
		IF _prev.opCode = opNOT THEN
			codes.last := _prev.prev(tpCommand);
			Delete(_prev)
		ELSIF IsCmp(_prev.opCode) THEN
			_prev.opCode := Cmp_Inv(_prev.opCode)
		ELSE
			Cmd0_Add(opNOT)
		END
	END Not;

PROCEDURE Enter* (pLabel: INTEGER): tpCommand;
	BEGIN
		Cmd2_Add(opENTER, pLabel, 0)
		RETURN codes.last
	END Enter;

PROCEDURE Leave* (pResult, pFloat: BOOLEAN; pSize: INTEGER): tpCommand;
	BEGIN
		IF pResult THEN
			IF pFloat THEN
				Cmd_Add(opLEAVEF, pSize)
			ELSE
				Cmd_Add(opLEAVER, pSize)
			END
		ELSE
			Cmd_Add(opLEAVE, pSize)
		END

		RETURN codes.last
	END Leave;

PROCEDURE Call* (pProc: INTEGER);
	BEGIN
		CmdJmp_Add(opCALL, pProc)
	END Call;

PROCEDURE Imp_Call* (pProc: mList.tpItem);
	BEGIN
		CmdJmp_Add(opCALLI, pProc(tpProcImport).label)
	END Imp_Call;

PROCEDURE Proc_Call*;
	BEGIN
		Cmd0_Add(opCALLP)
	END Proc_Call;

PROCEDURE Proc_Assign* (pProc: INTEGER);
	BEGIN
		CmdJmp_Add(opSAVEP, pProc)
	END Proc_Assign;

PROCEDURE ProcImp_Assign* (pProc: mList.tpItem);
	BEGIN
		CmdJmp_Add(opSAVEIP, pProc(tpProcImport).label)
	END ProcImp_Assign;

PROCEDURE Proc_Push* (pProc: INTEGER);
	BEGIN
		CmdJmp_Add(opPUSHP, pProc)
	END Proc_Push;

PROCEDURE ProcImp_Push* (pProc: mList.tpItem);
	BEGIN
		CmdJmp_Add(opPUSHIP, pProc(tpProcImport).label)
	END ProcImp_Push;

PROCEDURE Proc_Cmp* (pProc: INTEGER; pEqu: BOOLEAN);
	BEGIN
		IF pEqu THEN
			CmdJmp_Add(opEQP, pProc)
		ELSE
			CmdJmp_Add(opNEP, pProc)
		END
	END Proc_Cmp;

PROCEDURE ProcImp_Cmp* (pProc: mList.tpItem; pEqu: BOOLEAN);
	BEGIN
		IF pEqu THEN
			CmdJmp_Add(opEQIP, pProc(tpProcImport).label)
		ELSE
			CmdJmp_Add(opNEIP, pProc(tpProcImport).label)
		END
	END ProcImp_Cmp;

PROCEDURE Sys_Get* (pSize: INTEGER);
	BEGIN
		Cmd_Add(opGET, pSize)
	END Sys_Get;

PROCEDURE Load* (pSize: INTEGER);
	VAR
		last: tpCommand;
	BEGIN
		last := codes.last;
		CASE pSize OF
		|1:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD8
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD8
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD8
			ELSE
				Cmd0_Add(opLOAD8)
			END

		|2:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD16
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD16
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD16
			ELSE
				Cmd0_Add(opLOAD16)
			END

		|4:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD32
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD32
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD32
			ELSE
				Cmd0_Add(opLOAD32)
			END

		|8:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD64
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD64
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD64
			ELSE
				Cmd0_Add(opLOAD64)
			END
		END
	END Load;

PROCEDURE Sys_Put* (pSize: INTEGER);
	BEGIN
		CASE pSize OF
		|1: Cmd0_Add(opSAVE8)
		|2: Cmd0_Add(opSAVE16)
		|4: Cmd0_Add(opSAVE32)
		|8: Cmd0_Add(opSAVE64)
		END
	END Sys_Put;

PROCEDURE Float_Save*;
	BEGIN
		Cmd0_Add(opSAVEF);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END Float_Save;

PROCEDURE Float_Push*;
	BEGIN
		Cmd0_Add(opPUSHF);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END Float_Push;

PROCEDURE Float_Load* (): BOOLEAN;
	BEGIN
		Cmd0_Add(opLOADF);
		INC(codes.fregs)
		RETURN codes.fregs < numRegsFloat
	END Float_Load;

PROCEDURE IsInf* (): BOOLEAN;
	BEGIN
		Cmd0_Add(opINF);
		INC(codes.fregs)
		RETURN codes.fregs < numRegsFloat
	END IsInf;

PROCEDURE fbinop* (pOpCode: BYTE);
	BEGIN
		Cmd0_Add(pOpCode);
		DEC(codes.fregs);
		ASSERT(codes.fregs > 0)
	END fbinop;

PROCEDURE Str_Save* (pOffset, pLen: INTEGER);
	BEGIN
		Cmd2_Add(opSAVES, pLen, pOffset)
	END Str_Save;

PROCEDURE Abs_Set* (pFloat: BOOLEAN);
	BEGIN
		IF pFloat THEN
			Cmd0_Add(opFABS)
		ELSE
			Cmd0_Add(opABS)
		END
	END Abs_Set;

PROCEDURE Floor_Set*;
	BEGIN
		Cmd0_Add(opFLOOR);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END Floor_Set;

PROCEDURE IsFloat* (): BOOLEAN;
	BEGIN
		Cmd0_Add(opFLT);
		INC(codes.fregs)
		RETURN codes.fregs < numRegsFloat
	END IsFloat;

PROCEDURE Odd_Set*;
	BEGIN
		Cmd0_Add(opODD)
	END Odd_Set;

PROCEDURE Ord_Set*;
	BEGIN
		Cmd0_Add(opORD)
	END Ord_Set;

PROCEDURE ShiftMinMax_Set* (pOp: CHAR);
	BEGIN
		CASE pOp OF
		|"A": Cmd0_Add(opASR)
		|"L": Cmd0_Add(opLSL)
		|"O": Cmd0_Add(opROR)
		|"R": Cmd0_Add(opLSR)
		|"m": Cmd0_Add(opMIN)
		|"x": Cmd0_Add(opMAX)
		END
	END ShiftMinMax_Set;

PROCEDURE shift_minmax1* (pOp: CHAR; x: INTEGER);
	BEGIN
		CASE pOp OF
		|"A": Cmd_Add(opASR1, x)
		|"L": Cmd_Add(opLSL1, x)
		|"O": Cmd_Add(opROR1, x)
		|"R": Cmd_Add(opLSR1, x)
		|"m": Cmd_Add(opMINC, x)
		|"x": Cmd_Add(opMAXC, x)
		END
	END shift_minmax1;

PROCEDURE shift_minmax2* (pOp: CHAR; x: INTEGER);
	BEGIN
		CASE pOp OF
		|"A": Cmd_Add(opASR2, x)
		|"L": Cmd_Add(opLSL2, x)
		|"O": Cmd_Add(opROR2, x)
		|"R": Cmd_Add(opLSR2, x)
		|"m": Cmd_Add(opMINC, x)
		|"x": Cmd_Add(opMAXC, x)
		END
	END shift_minmax2;

PROCEDURE len* (dim: INTEGER);
	BEGIN
		Cmd_Add(opLEN, dim)
	END len;

PROCEDURE Float* (r: REAL);
	VAR
		cmd: tpCommandFloat;
	BEGIN
		NEW(cmd);
		cmd.opCode := opCONSTF;
		cmd.valFloat := r;
		Insert(codes.last, cmd);
		INC(codes.fregs);
		ASSERT(codes.fregs <= numRegsFloat)
	END Float;

PROCEDURE precall* (IsFloat: BOOLEAN): INTEGER;
	VAR
		res: INTEGER;
	BEGIN
		res := codes.fregs;
		Cmd2_Add(opPRECALL, ORD(IsFloat), res);
		codes.fregs := 0
		RETURN res
	END precall;

PROCEDURE resf* (fregs: INTEGER): BOOLEAN;
	BEGIN
		Cmd_Add(opRESF, fregs);
		codes.fregs := fregs + 1
		RETURN codes.fregs < numRegsFloat
	END resf;

PROCEDURE res* (fregs: INTEGER);
	BEGIN
		Cmd_Add(opRES, fregs);
		codes.fregs := fregs
	END res;

PROCEDURE retf*;
	BEGIN
		DEC(codes.fregs);
		ASSERT(codes.fregs = 0)
	END retf;

PROCEDURE drop*;
	BEGIN
		Cmd0_Add(opDROP)
	END drop;

PROCEDURE case* (a, b, L, R: INTEGER);
	VAR
		cmd: tpCommand3;

	BEGIN
		IF a = b THEN
			NEW(cmd);
			cmd.opCode := opCASELR;
			cmd.param1 := a;
			cmd.param2 := L;
			cmd.param3 := R;
			Insert(codes.last, cmd)
		ELSE
			Cmd2_Add(opCASEL, a, L);
			Cmd2_Add(opCASER, b, R)
		END
	END case;

PROCEDURE caset* (a, label: INTEGER);
	BEGIN
		Cmd2_Add(opCASET, label, a)
	END caset;

PROCEDURE AddExp* (label: INTEGER; name: mScan.LEXSTR);
	VAR
		exp: tpProcExport;
	BEGIN
		NEW(exp);
		exp.label := label;
		exp.lexName  := name;
		mList.Add(codes.export, exp)
	END AddExp;

PROCEDURE AddImp* (dll, pProc: mScan.LEXSTR): tpProcImport;
	VAR
		lib: tpLibImport;
		p:   tpProcImport;
	BEGIN
		lib := codes.import.first(tpLibImport);
		WHILE (lib # NIL) & (lib.lexName # dll) DO
			lib := lib.next(tpLibImport)
		END;

		IF lib = NIL THEN
			NEW(lib);
			lib.lexName := dll;
			lib.procs := mList.New(NIL);
			mList.Add(codes.import, lib)
		END;

		p := lib.procs.first(tpProcImport);
		WHILE (p # NIL) & (p.lexName # pProc) DO
			p := p.next(tpProcImport)
		END;

		IF p = NIL THEN
			NEW(p);
			p.lexName  := pProc;
			p.label := Label_New();
			p.lib   := lib;
			p.count := 1;
			mList.Add(lib.procs, p)
		ELSE
			INC(p.count)
		END

		RETURN p
	END AddImp;

PROCEDURE DelImport* (imp: mList.tpItem);
	VAR
		lib: tpLibImport;
	BEGIN
		DEC(imp(tpProcImport).count);
		IF imp(tpProcImport).count = 0 THEN
			lib := imp(tpProcImport).lib;
			mList.Del(lib.procs, imp);
			IF lib.procs.first = NIL THEN
				mList.Del(codes.import, lib)
			END
		END
	END DelImport;

PROCEDURE init*;
	VAR
		cmd:    tpCommand;
		pNum_i:      INTEGER;
	BEGIN
		NEW(codes);
		NEW(codes.call_beg);
		codes.call_beg.top := -1;
		NEW(codes.call_end);
		codes.call_end.top := -1;
		codes.commands := mList.New(NIL);
		codes.export   := mList.New(NIL);
		codes.import   := mList.New(NIL);
		codes.types    := mChl.CreateIntList();
		codes.data    := mChl.CreateByteList();

		NEW(cmd); cmd.opCode := opNOP; mList.Add(codes.commands, cmd);
		codes.last := cmd;
		NEW(cmd); cmd.opCode := opNOP; mList.Add(codes.commands, cmd);

		Rec_Add(0);

		codes.lcount := 0;

		codes.fregs := 0;

		FOR pNum_i := 0 TO LEN(codes.charoffs) - 1 DO
			codes.charoffs[pNum_i] := -1
		END;

		FOR pNum_i := 0 TO LEN(codes.wcharoffs) - 1 DO
			codes.wcharoffs[pNum_i] := -1
		END
	END init;

END CODE.
