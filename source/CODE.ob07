MODULE CODE;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mList := LISTS,
	mScan := SCAN,
	mStr  := STRINGS,
	mChl := CHUNKLISTS,
	mConst := modConstante;

CONST
	opCOPYS* = 2; opGADR* = 3; opCONST* = 4; opLLOAD32* = 5;
	opCOPYA* = 6; opCASET* = 7; opMULC* = 8; opMUL* = 9;
	opDIV* = 10; opMOD* = 11; opDIVL* = 12; opMODL* = 13; opDIVR* = 14; opMODR* = 15;
	opUMINUS* = 16;
	opADD* = 17; opSUB* = 18; opADDL* = 19; opSUBL* = 20; opADDR* = 21; opSUBR* = 22;
	opSAVE* = 23; opSAVEC* = 24; opSAVE8* = 25; opSAVE8C* = 26; opACC* = 27; opDROP* = 28;
	opNOT* = 29;

	opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
	opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
	opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

	opVLOAD32* = 48; opGLOAD32* = 49;

	opJNE* = 50; opJE* = 51;

	opEQS* = 52; opNES* = 53; opLTS* = 54; opLES* = 55; opGTS* = 56; opGES* = 57;

	opSAVE32* = 58; opLLOAD8* = 59;

	opCONSTF* = 60; opLOADF* = 61; opSAVEF* = 62; opMULF* = 63; opDIVF* = 64; opDIVFI* = 65;
	opUMINF* = 66; opADDFI* = 67; opSUBFI* = 68; opADDF* = 69; opSUBF* = 70;

	opINC1B* = 71; opDEC1B* = 72; opINCCB* = 73; opDECCB* = 74; opINCB* = 75; opDECB* = 76;

	opCASEL* = 77; opCASER* = 78; opCASELR* = 79;

	opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
	opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

	opLOAD8* = 92; opLOAD16* = 93; opLOAD32* = 94; opPRECALL* = 95; opRES* = 96; opRESF* = 97;
	opERRC* = 98; opSWITCH* = 99;

	opSBOOL* = 100; opSBOOLC* = 101; opNOP* = 102;

	opMULS* = 103; opMULSC* = 104; opDIVS* = 105; opDIVSC* = 106;
	opADDS* = 107; opSUBS* = 108; opADDSL* = 109; opSUBSL* = 110; opADDSR* = 111; opSUBSR* = 112;
	opUMINS* = 113; opIN* = 114; opINL* = 115; opINR* = 116;
	opRSET* = 117; opRSETL* = 118; opRSETR* = 119; opRSET1* = 120; opLENGTH* = 121;

	opINC1* = 122; opDEC1* = 123; opINCC* = 124; opDECC* = 125; opINC* = 126; opDEC* = 127;
	opINCL* = 128; opEXCL* = 129; opINCLC* = 130; opEXCLC* = 131; opNEW* = 132; opDISP* = 133;
	opPACK* = 134; opPACKC* = 135; opUNPK* = 136; opCOPY* = 137; opENTER* = 138; opLEAVE* = 139;
	opCALL* = 140; opSAVEP* = 141; opCALLP* = 142; opEQP* = 143; opNEP* = 144; opLEAVER* = 145;
	opGET* = 146; opSAVE16* = 147; opABS* = 148; opFABS* = 149; opFLOOR* = 150; opFLT* = 151;
	opODD* = 152; opORD* = 153; opASR* = 154; opLSL* = 155; opROR* = 156;
	opASR1* = 157; opLSL1* = 158; opROR1* = 159; opASR2* = 160; opLSL2* = 161; opROR2* = 162;
	opPUSHP* = 163; opLADR* = 164; opTYPEGP* = 165; opIS* = 166; opPUSHF* = 167; opVADR* = 168;
	opPUSHT* = 169; opTYPEGR* = 170; opISREC* = 171; opCHKIDX* = 172; opPARAM* = 173;
	opCHKIDX2* = 174; opLEN* = 175; opROT* = 176; opSAVES* = 177; opSADR* = 178; opERR* = 179;

	opCHR* = 180; opENDSW* = 181; opLEAVEF* = 182; opCLEANUP* = 183; opMOVE* = 184;
	opLSR* = 185; opLSR1* = 186; opLSR2* = 187;
	opMIN* = 188; opMINC* = 189; opMAX* = 190; opMAXC* = 191; opJNZ* = 192;
	opEQB* = 193; opNEB* = 194; opINF* = 195; opJZ* = 196; opVLOAD8* = 197; opGLOAD8* = 198;
	opLLOAD16* = 199; opVLOAD16* = 200; opGLOAD16* = 201;
	opLOAD64* = 202; opLLOAD64* = 203; opVLOAD64* = 204; opGLOAD64* = 205; opSAVE64* = 206;

	opTYPEGD* = 207; opCALLI* = 208; opPUSHIP* = 209; opSAVEIP* = 210; opEQIP* = 211; opNEIP* = 212;
	opSAVE16C* = 213; opWCHR* = 214; opCOPYS2* = 215; opLENGTHW* = 216;

	opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
	opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
	opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;

	opCODE* = 235;


	_move      *=   0;
	_move2     *=   1;
	_in        *=   2;
	_in2       *=   3;
	_set       *=   4;
	_set2      *=   5;
	_incl      *=   6;
	_excl      *=   7;
	_div       *=   8;
	_mod       *=   9;
	_div2      *=  10;
	_mod2      *=  11;
	_arrcpy    *=  12;
	_rot       *=  13;
	_new       *=  14;
	_dispose   *=  15;
	_strcmp    *=  16;
	_error     *=  17;
	_is        *=  18;
	_isrec     *=  19;
	_guard     *=  20;
	_guardrec  *=  21;
	_length    *=  22;
	_init      *=  23;
	_dllentry  *=  24;
	_strcpy    *=  25;
	_exit      *=  26;
	_strcpy2   *=  27;
	_lengthw   *=  28;
	_strcmp2   *=  29;
	_strcmpw   *=  30;
	_strcmpw2  *=  31;

TYPE
	tpCommand* = POINTER TO RECORD (mList.tpItem)
			opCode*:  INTEGER; (* Code operation. Defined in modConstante *)
			param1*:  INTEGER; (* Param1 for opCode *)
			param2*:  INTEGER  (* Param2 for opCode *)
		END;

	tpCommand3* = POINTER TO RECORD (tpCommand)
			param3*:  INTEGER
		END;

	tpCommandFloat* = POINTER TO RECORD (tpCommand)
			valFloat*:   REAL
		END;

	tpCmdStack = POINTER TO RECORD
			aData: ARRAY 1000 OF tpCommand;
			top:  INTEGER
		END;

	tpProcExport* = POINTER TO RECORD (mList.tpItem)
			label*: INTEGER;
			lexName*:  mScan.LEXSTR
		END;

	tpLibImport* = POINTER TO RECORD (mList.tpItem)
			lexName*:   mScan.LEXSTR;
			procs*:  mList.tpList
		END;

	tpProcImport* = POINTER TO RECORD (mList.tpItem)
			label*: INTEGER;
			lib*:   tpLibImport;
			lexName*:  mScan.LEXSTR;
			count:  INTEGER
		END;

	tpCodes* = POINTER TO RECORD
			last:       tpCommand;
			call_beg:    tpCmdStack;
			call_end:    tpCmdStack;
			commands*:  mList.tpList;
			export*:    mList.tpList;
			import*:    mList.tpList;
			types*:     mChl.INTLIST;
			data*:      mChl.BYTELIST;
			dmin*:      INTEGER;
			lcount*:    INTEGER;
			bss*:       INTEGER;
			rtl*:       ARRAY 32 OF INTEGER;

			charoffs:   ARRAY 256 OF INTEGER;
			wcharoffs:  ARRAY 65536 OF INTEGER;

			fregs:      INTEGER;
			wstr:       ARRAY 4*1024 OF WCHAR;

			errLabel*:  INTEGER
		END;

VAR
	codes*: tpCodes;

PROCEDURE Last_Set* (pCmd: tpCommand);
	BEGIN
		codes.last := pCmd
	END Last_Set;

PROCEDURE Last_Get* (): tpCommand;
		RETURN codes.last
	END Last_Get;

PROCEDURE Byte_Put (pCodes: tpCodes; pByte: BYTE);
	BEGIN
		mChl.PushByte(pCodes.data, pByte)
	END Byte_Put;

PROCEDURE Str_Put* (pStr: ARRAY OF CHAR): INTEGER;
	VAR
		_i, _n, _res: INTEGER;
	BEGIN
		_res := mChl.Length(codes.data);

		_i := 0;
		_n := LENGTH(pStr);
		WHILE _i < _n DO
			Byte_Put(codes, ORD(pStr[_i]));
			INC(_i)
		END;

		Byte_Put(codes, 0)

		RETURN _res
	END Str_Put;

PROCEDURE Str_Put1* (pNum: INTEGER): INTEGER;
	VAR
		_res: INTEGER;
	BEGIN
		IF codes.charoffs[pNum] = -1 THEN
			_res := mChl.Length(codes.data);
			Byte_Put(codes, pNum);
			Byte_Put(codes, 0);
			codes.charoffs[pNum] := _res
		ELSE
			_res := codes.charoffs[pNum]
		END

		RETURN _res
	END Str_Put1;

PROCEDURE Str_PutW* (pStr: ARRAY OF CHAR): INTEGER;
	VAR
		pNum_i, _n, _res: INTEGER;
	BEGIN
		_res := mChl.Length(codes.data);
		IF ODD(_res) THEN
			Byte_Put(codes, 0);
			INC(_res)
		END;
		_n := mStr.Utf8To16(pStr, codes.wstr);
		pNum_i := 0;
		WHILE pNum_i < _n DO
			Byte_Put(codes, ORD(codes.wstr[pNum_i]) MOD 256);
			Byte_Put(codes, ORD(codes.wstr[pNum_i]) DIV 256);
			INC(pNum_i)
		END;
		Byte_Put(codes, 0);
		Byte_Put(codes, 0)
		RETURN _res
	END Str_PutW;

PROCEDURE Str_PutW1* (pNum: INTEGER): INTEGER;
	VAR
		_res: INTEGER;
	BEGIN
		IF codes.wcharoffs[pNum] = -1 THEN
			_res := mChl.Length(codes.data);

			IF ODD(_res) THEN
				Byte_Put(codes, 0);
				INC(_res)
			END;

			Byte_Put(codes, pNum MOD 256);
			Byte_Put(codes, pNum DIV 256);
			Byte_Put(codes, 0);
			Byte_Put(codes, 0);

			codes.wcharoffs[pNum] := _res
		ELSE
			_res := codes.wcharoffs[pNum]
		END
		RETURN _res
	END Str_PutW1;

PROCEDURE MinDataSize_Set* (size: INTEGER);
	BEGIN
		codes.dmin := mChl.Length(codes.data) + size
	END MinDataSize_Set;

PROCEDURE Push (pStack: tpCmdStack; pCmd: tpCommand);
	BEGIN
		INC(pStack.top);
		pStack.aData[pStack.top] := pCmd
	END Push;

PROCEDURE Pop (pStack: tpCmdStack): tpCommand;
	VAR
		_res: tpCommand;
	BEGIN
		_res := pStack.aData[pStack.top];
		DEC(pStack.top)
		RETURN _res
	END Pop;

PROCEDURE BegEnd_Push* (VAR pBeg, pEnd: tpCommand);
	BEGIN
		Push(codes.call_beg, pBeg);
		Push(codes.call_end, pEnd);
		pBeg := codes.last;
		pEnd := pBeg.next(tpCommand)
	END BegEnd_Push;

PROCEDURE BegEnd_Pop* (VAR pBeg, pEnd: tpCommand);
	BEGIN
		pBeg := Pop(codes.call_beg);
		pEnd := Pop(codes.call_end)
	END BegEnd_Pop;

PROCEDURE Rec_Add* (pBase: INTEGER);
	BEGIN
		mChl.PushInt(codes.types, pBase)
	END Rec_Add;

PROCEDURE insert (cur, nov: tpCommand);
	BEGIN
		mList.Insert(codes.commands, cur, nov);
		codes.last := nov
	END insert;

PROCEDURE AddCmd* (opcode: INTEGER; param: INTEGER);
	VAR
		cmd: tpCommand;
	BEGIN
		NEW(cmd);
		cmd.opCode := opcode;
		cmd.param1 := 0;
		cmd.param2 := param;
		insert(codes.last, cmd)
	END AddCmd;

PROCEDURE AddCmd2* (opcode: INTEGER; param1, param2: INTEGER);
	VAR
		cmd: tpCommand;
	BEGIN
		NEW(cmd);
		cmd.opCode := opcode;
		cmd.param1 := param1;
		cmd.param2 := param2;
		insert(codes.last, cmd)
	END AddCmd2;

PROCEDURE NewLabel* (): INTEGER;
	BEGIN
		INC(codes.lcount)
		RETURN codes.lcount - 1
	END NewLabel;

PROCEDURE SetLabel* (label: INTEGER);
	BEGIN
		AddCmd(mConst.codeLABEL, label)
	END SetLabel;

PROCEDURE SetErrLabel*;
	BEGIN
		codes.errLabel := NewLabel();
		SetLabel(codes.errLabel)
	END SetErrLabel;

PROCEDURE AddCmd0* (opcode: INTEGER);
	BEGIN
		AddCmd(opcode, 0)
	END AddCmd0;

PROCEDURE delete (cmd: tpCommand);
	BEGIN
		mList.Del(codes.commands, cmd)
	END delete;

PROCEDURE AddJmpCmd* (opcode: INTEGER; label: INTEGER);
	VAR
		prev: tpCommand;
		not:  BOOLEAN;
	BEGIN
		prev := codes.last;
		not := prev.opCode = opNOT;
		IF not THEN
			IF opcode = opJE THEN
				opcode := opJNE
			ELSIF opcode = opJNE THEN
				opcode := opJE
			ELSE
				not := FALSE
			END
		END;
		AddCmd2(opcode, label, label);
		IF not THEN
			delete(prev)
		END
	END AddJmpCmd;

PROCEDURE OnError* (line, error: INTEGER);
	BEGIN
		AddCmd(opERRC, LSL(line, 4) + error);
		AddJmpCmd(mConst.codeJMP, codes.errLabel)
	END OnError;

PROCEDURE TypeGuard* (op, t: INTEGER; line, error: INTEGER);
	VAR
		label: INTEGER;
	BEGIN
		AddCmd(op, t);
		label := NewLabel();
		AddJmpCmd(opJE, label);
		OnError(line, error);
		SetLabel(label)
	END TypeGuard;

PROCEDURE TypeCheck* (t: INTEGER);
	BEGIN
		AddCmd(opIS, t)
	END TypeCheck;

PROCEDURE TypeCheckRec* (t: INTEGER);
	BEGIN
		AddCmd(opISREC, t)
	END TypeCheckRec;

PROCEDURE New* (size, typenum: INTEGER);
	BEGIN
		AddCmd2(opNEW, typenum, size)
	END New;

PROCEDURE fcmp* (opcode: BYTE);
	BEGIN
		AddCmd(opcode, 0);
		DEC(codes.fregs, 2);
		ASSERT(codes.fregs >= 0)
	END fcmp;

PROCEDURE isCmp (opcode: BYTE): BOOLEAN;
	(*
		opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
		opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
		opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

		opEQS*   =  52; opNES*   =  53; opLTS*   =  54; opLES*   =  55; opGTS*   =  56; opGES*   =  57;
		opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
		opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
		opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;

		opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
		opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

		opEQP* = 143; opNEP* = 144;
																					  *)

		RETURN (opEQ <= opcode) & (opcode <= opGER) OR (opEQS <= opcode) & (opcode <= opGES) OR
				(opEQS2 <= opcode) & (opcode <= opGES2) OR (opEQSW <= opcode) & (opcode <= opGESW) OR
				(opEQSW2 <= opcode) & (opcode <= opGESW2) OR
				(opEQF <= opcode) & (opcode <= opGEFI) OR (opcode = opEQP) OR (opcode = opNEP)
	END isCmp;

PROCEDURE InvCmp (opcode: BYTE): INTEGER;
	BEGIN

		CASE opcode OF

		|opEQ:    opcode := opNE
		|opNE:    opcode := opEQ
		|opLT:    opcode := opGE
		|opLE:    opcode := opGT
		|opGT:    opcode := opLE
		|opGE:    opcode := opLT

		|opEQR:   opcode := opNER
		|opNER:   opcode := opEQR
		|opLTR:   opcode := opGER
		|opLER:   opcode := opGTR
		|opGTR:   opcode := opLER
		|opGER:   opcode := opLTR

		|opEQL:   opcode := opNEL
		|opNEL:   opcode := opEQL
		|opLTL:   opcode := opGEL
		|opLEL:   opcode := opGTL
		|opGTL:   opcode := opLEL
		|opGEL:   opcode := opLTL

		|opEQS:   opcode := opNES
		|opNES:   opcode := opEQS
		|opLTS:   opcode := opGES
		|opLES:   opcode := opGTS
		|opGTS:   opcode := opLES
		|opGES:   opcode := opLTS

		|opEQS2:  opcode := opNES2
		|opNES2:  opcode := opEQS2
		|opLTS2:  opcode := opGES2
		|opLES2:  opcode := opGTS2
		|opGTS2:  opcode := opLES2
		|opGES2:  opcode := opLTS2

		|opEQSW:  opcode := opNESW
		|opNESW:  opcode := opEQSW
		|opLTSW:  opcode := opGESW
		|opLESW:  opcode := opGTSW
		|opGTSW:  opcode := opLESW
		|opGESW:  opcode := opLTSW

		|opEQSW2: opcode := opNESW2
		|opNESW2: opcode := opEQSW2
		|opLTSW2: opcode := opGESW2
		|opLESW2: opcode := opGTSW2
		|opGTSW2: opcode := opLESW2
		|opGESW2: opcode := opLTSW2

		|opEQF:   opcode := opNEF
		|opNEF:   opcode := opEQF
		|opLTF:   opcode := opGEF
		|opLEF:   opcode := opGTF
		|opGTF:   opcode := opLEF
		|opGEF:   opcode := opLTF

		|opEQFI:  opcode := opNEFI
		|opNEFI:  opcode := opEQFI
		|opLTFI:  opcode := opGEFI
		|opLEFI:  opcode := opGTFI
		|opGTFI:  opcode := opLEFI
		|opGEFI:  opcode := opLTFI

		|opEQP:   opcode := opNEP
		|opNEP:   opcode := opEQP

		END

		RETURN opcode
	END InvCmp;

PROCEDURE not*;
	VAR
		prev: tpCommand;
	BEGIN
		prev := codes.last;
		IF prev.opCode = opNOT THEN
			codes.last := prev.prev(tpCommand);
			delete(prev)
		ELSIF isCmp(prev.opCode) THEN
			prev.opCode := InvCmp(prev.opCode)
		ELSE
			AddCmd0(opNOT)
		END
	END not;

PROCEDURE Enter* (label: INTEGER): tpCommand;
	BEGIN
		AddCmd2(opENTER, label, 0)
		RETURN codes.last
	END Enter;

PROCEDURE Leave* (result, float: BOOLEAN; paramsize: INTEGER): tpCommand;
	BEGIN
		IF result THEN
			IF float THEN
				AddCmd(opLEAVEF, paramsize)
			ELSE
				AddCmd(opLEAVER, paramsize)
			END
		ELSE
			AddCmd(opLEAVE, paramsize)
		END

		RETURN codes.last
	END Leave;

PROCEDURE Call* (proc: INTEGER);
	BEGIN
		AddJmpCmd(opCALL, proc)
	END Call;

PROCEDURE CallImp* (proc: mList.tpItem);
	BEGIN
		AddJmpCmd(opCALLI, proc(tpProcImport).label)
	END CallImp;

PROCEDURE CallP*;
	BEGIN
		AddCmd0(opCALLP)
	END CallP;

PROCEDURE AssignProc* (proc: INTEGER);
	BEGIN
		AddJmpCmd(opSAVEP, proc)
	END AssignProc;

PROCEDURE AssignImpProc* (proc: mList.tpItem);
	BEGIN
		AddJmpCmd(opSAVEIP, proc(tpProcImport).label)
	END AssignImpProc;

PROCEDURE PushProc* (proc: INTEGER);
	BEGIN
		AddJmpCmd(opPUSHP, proc)
	END PushProc;

PROCEDURE PushImpProc* (proc: mList.tpItem);
	BEGIN
		AddJmpCmd(opPUSHIP, proc(tpProcImport).label)
	END PushImpProc;

PROCEDURE ProcCmp* (proc: INTEGER; eq: BOOLEAN);
	BEGIN
		IF eq THEN
			AddJmpCmd(opEQP, proc)
		ELSE
			AddJmpCmd(opNEP, proc)
		END
	END ProcCmp;

PROCEDURE ProcImpCmp* (proc: mList.tpItem; eq: BOOLEAN);
	BEGIN
		IF eq THEN
			AddJmpCmd(opEQIP, proc(tpProcImport).label)
		ELSE
			AddJmpCmd(opNEIP, proc(tpProcImport).label)
		END
	END ProcImpCmp;

PROCEDURE SysGet* (size: INTEGER);
	BEGIN
		AddCmd(opGET, size)
	END SysGet;

PROCEDURE load* (size: INTEGER);
	VAR
		last: tpCommand;
	BEGIN
		last := codes.last;
		CASE size OF
		|1:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD8
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD8
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD8
			ELSE
				AddCmd0(opLOAD8)
			END

		|2:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD16
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD16
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD16
			ELSE
				AddCmd0(opLOAD16)
			END

		|4:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD32
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD32
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD32
			ELSE
				AddCmd0(opLOAD32)
			END

		|8:
			IF last.opCode = opLADR THEN
				last.opCode := opLLOAD64
			ELSIF last.opCode = opVADR THEN
				last.opCode := opVLOAD64
			ELSIF last.opCode = opGADR THEN
				last.opCode := opGLOAD64
			ELSE
				AddCmd0(opLOAD64)
			END
		END
	END load;

PROCEDURE SysPut* (size: INTEGER);
	BEGIN
		CASE size OF
		|1: AddCmd0(opSAVE8)
		|2: AddCmd0(opSAVE16)
		|4: AddCmd0(opSAVE32)
		|8: AddCmd0(opSAVE64)
		END
	END SysPut;

PROCEDURE savef*;
	BEGIN
		AddCmd0(opSAVEF);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END savef;

PROCEDURE pushf*;
	BEGIN
		AddCmd0(opPUSHF);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END pushf;

PROCEDURE loadf* (): BOOLEAN;
	BEGIN
		AddCmd0(opLOADF);
		INC(codes.fregs)
		RETURN codes.fregs < mConst.codeFregs
	END loadf;

PROCEDURE inf* (): BOOLEAN;
	BEGIN
		AddCmd0(opINF);
		INC(codes.fregs)
		RETURN codes.fregs < mConst.codeFregs
	END inf;

PROCEDURE fbinop* (opcode: BYTE);
	BEGIN
		AddCmd0(opcode);
		DEC(codes.fregs);
		ASSERT(codes.fregs > 0)
	END fbinop;

PROCEDURE saves* (offset, length: INTEGER);
	BEGIN
		AddCmd2(opSAVES, length, offset)
	END saves;

PROCEDURE abs* (real: BOOLEAN);
	BEGIN
		IF real THEN
			AddCmd0(opFABS)
		ELSE
			AddCmd0(opABS)
		END
	END abs;

PROCEDURE floor*;
	BEGIN
		AddCmd0(opFLOOR);
		DEC(codes.fregs);
		ASSERT(codes.fregs >= 0)
	END floor;

PROCEDURE flt* (): BOOLEAN;
	BEGIN
		AddCmd0(opFLT);
		INC(codes.fregs)
		RETURN codes.fregs < mConst.codeFregs
	END flt;

PROCEDURE odd*;
	BEGIN
		AddCmd0(opODD)
	END odd;

PROCEDURE ord*;
	BEGIN
		AddCmd0(opORD)
	END ord;

PROCEDURE shift_minmax* (op: CHAR);
	BEGIN
		CASE op OF
		|"A": AddCmd0(opASR)
		|"L": AddCmd0(opLSL)
		|"O": AddCmd0(opROR)
		|"R": AddCmd0(opLSR)
		|"m": AddCmd0(opMIN)
		|"x": AddCmd0(opMAX)
		END
	END shift_minmax;

PROCEDURE shift_minmax1* (op: CHAR; x: INTEGER);
	BEGIN
		CASE op OF
		|"A": AddCmd(opASR1, x)
		|"L": AddCmd(opLSL1, x)
		|"O": AddCmd(opROR1, x)
		|"R": AddCmd(opLSR1, x)
		|"m": AddCmd(opMINC, x)
		|"x": AddCmd(opMAXC, x)
		END
	END shift_minmax1;

PROCEDURE shift_minmax2* (op: CHAR; x: INTEGER);
	BEGIN
		CASE op OF
		|"A": AddCmd(opASR2, x)
		|"L": AddCmd(opLSL2, x)
		|"O": AddCmd(opROR2, x)
		|"R": AddCmd(opLSR2, x)
		|"m": AddCmd(opMINC, x)
		|"x": AddCmd(opMAXC, x)
		END
	END shift_minmax2;

PROCEDURE len* (dim: INTEGER);
	BEGIN
		AddCmd(opLEN, dim)
	END len;

PROCEDURE Float* (r: REAL);
	VAR
		cmd: tpCommandFloat;
	BEGIN
		NEW(cmd);
		cmd.opCode := opCONSTF;
		cmd.valFloat := r;
		insert(codes.last, cmd);
		INC(codes.fregs);
		ASSERT(codes.fregs <= mConst.codeFregs)
	END Float;

PROCEDURE precall* (flt: BOOLEAN): INTEGER;
	VAR
		res: INTEGER;
	BEGIN
		res := codes.fregs;
		AddCmd2(opPRECALL, ORD(flt), res);
		codes.fregs := 0
		RETURN res
	END precall;

PROCEDURE resf* (fregs: INTEGER): BOOLEAN;
	BEGIN
		AddCmd(opRESF, fregs);
		codes.fregs := fregs + 1
		RETURN codes.fregs < mConst.codeFregs
	END resf;

PROCEDURE res* (fregs: INTEGER);
	BEGIN
		AddCmd(opRES, fregs);
		codes.fregs := fregs
	END res;

PROCEDURE retf*;
	BEGIN
		DEC(codes.fregs);
		ASSERT(codes.fregs = 0)
	END retf;

PROCEDURE drop*;
	BEGIN
		AddCmd0(opDROP)
	END drop;

PROCEDURE case* (a, b, L, R: INTEGER);
	VAR
		cmd: tpCommand3;

	BEGIN
		IF a = b THEN
			NEW(cmd);
			cmd.opCode := opCASELR;
			cmd.param1 := a;
			cmd.param2 := L;
			cmd.param3 := R;
			insert(codes.last, cmd)
		ELSE
			AddCmd2(opCASEL, a, L);
			AddCmd2(opCASER, b, R)
		END
	END case;

PROCEDURE caset* (a, label: INTEGER);
	BEGIN
		AddCmd2(opCASET, label, a)
	END caset;

PROCEDURE AddExp* (label: INTEGER; name: mScan.LEXSTR);
	VAR
		exp: tpProcExport;
	BEGIN
		NEW(exp);
		exp.label := label;
		exp.lexName  := name;
		mList.Add(codes.export, exp)
	END AddExp;

PROCEDURE AddImp* (dll, proc: mScan.LEXSTR): tpProcImport;
	VAR
		lib: tpLibImport;
		p:   tpProcImport;
	BEGIN
		lib := codes.import.first(tpLibImport);
		WHILE (lib # NIL) & (lib.lexName # dll) DO
			lib := lib.next(tpLibImport)
		END;

		IF lib = NIL THEN
			NEW(lib);
			lib.lexName := dll;
			lib.procs := mList.New(NIL);
			mList.Add(codes.import, lib)
		END;

		p := lib.procs.first(tpProcImport);
		WHILE (p # NIL) & (p.lexName # proc) DO
			p := p.next(tpProcImport)
		END;

		IF p = NIL THEN
			NEW(p);
			p.lexName  := proc;
			p.label := NewLabel();
			p.lib   := lib;
			p.count := 1;
			mList.Add(lib.procs, p)
		ELSE
			INC(p.count)
		END

		RETURN p
	END AddImp;

PROCEDURE DelImport* (imp: mList.tpItem);
	VAR
		lib: tpLibImport;
	BEGIN
		DEC(imp(tpProcImport).count);
		IF imp(tpProcImport).count = 0 THEN
			lib := imp(tpProcImport).lib;
			mList.Del(lib.procs, imp);
			IF lib.procs.first = NIL THEN
				mList.Del(codes.import, lib)
			END
		END
	END DelImport;

PROCEDURE init*;
	VAR
		cmd:    tpCommand;
		pNum_i:      INTEGER;
	BEGIN
		NEW(codes);
		NEW(codes.call_beg);
		codes.call_beg.top := -1;
		NEW(codes.call_end);
		codes.call_end.top := -1;
		codes.commands := mList.New(NIL);
		codes.export   := mList.New(NIL);
		codes.import   := mList.New(NIL);
		codes.types    := mChl.CreateIntList();
		codes.data    := mChl.CreateByteList();

		NEW(cmd); cmd.opCode := opNOP; mList.Add(codes.commands, cmd);
		codes.last := cmd;
		NEW(cmd); cmd.opCode := opNOP; mList.Add(codes.commands, cmd);

		Rec_Add(0);

		codes.lcount := 0;

		codes.fregs := 0;

		FOR pNum_i := 0 TO LEN(codes.charoffs) - 1 DO
			codes.charoffs[pNum_i] := -1
		END;

		FOR pNum_i := 0 TO LEN(codes.wcharoffs) - 1 DO
			codes.wcharoffs[pNum_i] := -1
		END
	END init;

END CODE.
