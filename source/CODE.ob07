(*
    BSD 2-Clause License

    Copyright (c) 2018, Anton Krotov
    All rights reserved.
*)

MODULE CODE;

IMPORT LISTS, SCAN, PROG, STRINGS;


CONST

    MAXRECORDS = PROG.MAXRECORDS;

    FREGS = 8;


    opJMP* = 0; opLABEL* = 1; opCOPYS* = 2; opGADR* = 3; opCONST* = 4; opLLOAD32* = 5;
    opCOPYA* = 6; opCASET* = 7; opMULC* = 8; opMUL* = 9;
    opDIV* = 10; opMOD* = 11; opDIVL* = 12; opMODL* = 13; opDIVR* = 14; opMODR* = 15;
    opUMINUS* = 16;
    opADD* = 17; opSUB* = 18; opADDL* = 19; opSUBL* = 20; opADDR* = 21; opSUBR* = 22;
    opSAVE* = 23; opSAVEC* = 24; opSAVE8* = 25; opSAVE8C* = 26; opACC* = 27; opDROP* = 28;
    opNOT* = 29;

    opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
    opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
    opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

    opVLOAD32* = 48; opGLOAD32* = 49;

    opJNE* = 50; opJE* = 51;

    opEQS* = 52; opNES* = 53; opLTS* = 54; opLES* = 55; opGTS* = 56; opGES* = 57;

    opSAVE32* = 58; opLLOAD8* = 59;

    opCONSTF* = 60; opLOADF* = 61; opSAVEF* = 62; opMULF* = 63; opDIVF* = 64; opDIVFI* = 65;
    opUMINF* = 66; opADDFI* = 67; opSUBFI* = 68; opADDF* = 69; opSUBF* = 70;

    opINC1B* = 71; opDEC1B* = 72; opINCCB* = 73; opDECCB* = 74; opINCB* = 75; opDECB* = 76;

    opCASE* = 77; opCASE1* = 78; opCODE* = 79;

    opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
    opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

    opLOAD8* = 92; opLOAD16* = 93; opLOAD32* = 94; opPRECALL* = 95; opRES* = 96; opRESF* = 97;
    opERRC* = 98; opSWITCH* = 99;

    opSBOOL* = 100; opSBOOLC* = 101; opNOP* = 102;

    opMULS* = 103; opMULSC* = 104; opDIVS* = 105; opDIVSC* = 106;
    opADDS* = 107; opSUBS* = 108; opADDSL* = 109; opSUBSL* = 110; opADDSR* = 111; opSUBSR* = 112;
    opUMINS* = 113; opIN* = 114; opINL* = 115; opINR* = 116;
    opRSET* = 117; opRSETL* = 118; opRSETR* = 119; opRSET1* = 120; opLENGTH* = 121;

    opINC1* = 122; opDEC1* = 123; opINCC* = 124; opDECC* = 125; opINC* = 126; opDEC* = 127;
    opINCL* = 128; opEXCL* = 129; opINCLC* = 130; opEXCLC* = 131; opNEW* = 132; opDISP* = 133;
    opPACK* = 134; opPACKC* = 135; opUNPK* = 136; opCOPY* = 137; opENTER* = 138; opLEAVE* = 139;
    opCALL* = 140; opSAVEP* = 141; opCALLP* = 142; opEQP* = 143; opNEP* = 144; opLEAVER* = 145;
    opGET* = 146; opSAVE16* = 147; opABS* = 148; opFABS* = 149; opFLOOR* = 150; opFLT* = 151;
    opODD* = 152; opORD* = 153; opASR* = 154; opLSL* = 155; opROR* = 156;
    opASR1* = 157; opLSL1* = 158; opROR1* = 159; opASR2* = 160; opLSL2* = 161; opROR2* = 162;
    opPUSHP* = 163; opLADR* = 164; opTYPEG* = 165; opIS* = 166; opPUSHF* = 167; opVADR* = 168;
    opPUSHT* = 169; opTYPEGR* = 170; opISREC* = 171; opCHKIDX* = 172; opPARAM* = 173;
    opCHKIDX2* = 174; opLEN* = 175; opROT* = 176; opSAVES* = 177; opSADR* = 178; opERR* = 179;

    opCHR* = 180; opENDSW* = 181; opLEAVEF* = 182; opCLEANUP* = 183; opMOVE* = 184;
    opLSR* = 185; opLSR1* = 186; opLSR2* = 187;
    opMIN* = 188; opMINC* = 189; opMAX* = 190; opMAXC* = 191; opJNZ* = 192;
    opEQB* = 193; opNEB* = 194; opINF* = 195; opJZ* = 196; opVLOAD8* = 197; opGLOAD8* = 198;
    opLLOAD16* = 199; opVLOAD16* = 200; opGLOAD16* = 201;
    opLOAD64* = 202; opLLOAD64* = 203; opVLOAD64* = 204; opGLOAD64* = 205; opSAVE64 = 206;

    opPROC* = 207; opCALLI* = 208; opPUSHIP* = 209; opSAVEIP* = 210; opEQIP* = 211; opNEIP* = 212;
    opSAVE16C* = 213; opWCHR* = 214; opCOPYS2* = 215; opLENGTHW* = 216;

    opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
    opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
    opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;


    _move      *=   0;
    _move2     *=   1;
    _in        *=   2;
    _in2       *=   3;
    _set       *=   4;
    _set2      *=   5;
    _incl      *=   6;
    _excl      *=   7;
    _div       *=   8;
    _mod       *=   9;
    _div2      *=  10;
    _mod2      *=  11;
    _arrcpy    *=  12;
    _rot       *=  13;
    _new       *=  14;
    _dispose   *=  15;
    _strcmp    *=  16;
    _error     *=  17;
    _is        *=  18;
    _isrec     *=  19;
    _guard     *=  20;
    _guardrec  *=  21;
    _length    *=  22;
    _init      *=  23;
    _dllentry  *=  24;
    _strcpy    *=  25;
    _exit      *=  26;
    _strcpy2   *=  27;
    _lengthw   *=  28;
    _strcmp2   *=  29;
    _strcmpw   *=  30;
    _strcmpw2  *=  31;


TYPE

    COMMAND* = POINTER TO rCOMMAND;

    rCOMMAND = RECORD (LISTS.ITEM)

        opcode*:  BYTE;
        label*:   INTEGER;
        param*:   INTEGER;
        param2*:  INTEGER;
        float*:   REAL

    END;

    CMDSTACK = POINTER TO RECORD

        data: ARRAY 1000 OF COMMAND;
        top:  INTEGER

    END;

    EXPORT_PROC* = POINTER TO RECORD (LISTS.ITEM)

        label*: INTEGER;
        name*:  SCAN.LEXSTR

    END;

    IMPORT_LIB* = POINTER TO RECORD (LISTS.ITEM)

        name*:   SCAN.LEXSTR;
        procs*:  LISTS.LIST

    END;

    IMPORT_PROC* = POINTER TO RECORD (LISTS.ITEM)

        label*: INTEGER;
        lib*:   IMPORT_LIB;
        name*:  SCAN.LEXSTR;
        count:  INTEGER

    END;

    CODES* = POINTER TO RECORD

        last:       COMMAND;
        begcall:    CMDSTACK;
        endcall:    CMDSTACK;
        commands*:  LISTS.LIST;
        export*:    LISTS.LIST;
        import*:    LISTS.LIST;
        types*:     ARRAY MAXRECORDS + 1 OF INTEGER;
        data*:      ARRAY 1000000 OF BYTE;
        dcount*:    INTEGER;
        dmin*:      INTEGER;
        tcount*:    INTEGER;
        lcount*:    INTEGER;
        gsize*:     INTEGER;
        rtl*:       ARRAY 32 OF INTEGER;

        charoffs:   ARRAY 256 OF INTEGER;
        wcharoffs:  ARRAY 65536 OF INTEGER

    END;


VAR

    codes*: CODES;

    commands:  LISTS.LIST;

    fregs: INTEGER;

    wstr: ARRAY 16*1024 OF WCHAR;


PROCEDURE getlast* (): COMMAND;
    RETURN codes.last
END getlast;


PROCEDURE setlast* (cmd: COMMAND);
BEGIN
    codes.last := cmd
END setlast;


PROCEDURE putstr* (s: ARRAY OF CHAR): INTEGER;
VAR
    i, n, res, idx: INTEGER;
BEGIN
    res := codes.dcount;
    idx := res;
    i := 0;
    n := LENGTH(s);
    WHILE i < n DO
        codes.data[idx] := ORD(s[i]);
        INC(i);
        INC(idx)
    END;
    codes.data[idx] := 0;
    INC(idx);
    codes.dcount := idx

    RETURN res
END putstr;


PROCEDURE putstr1* (c: INTEGER): INTEGER;
VAR
    res, idx: INTEGER;

BEGIN
    IF codes.charoffs[c] = -1 THEN
        res := codes.dcount;
        idx := res;
        codes.data[idx] := c;
        INC(idx);
        codes.data[idx] := 0;
        INC(idx);
        codes.charoffs[c] := res;
        codes.dcount := idx
    ELSE
        res := codes.charoffs[c]
    END

    RETURN res
END putstr1;


PROCEDURE putstrW* (s: ARRAY OF CHAR): INTEGER;
VAR
    i, n, res, idx: INTEGER;

BEGIN
    res := codes.dcount;

    IF ODD(res) THEN
        codes.data[res] := 0;
        INC(res)
    END;

    idx := res;

    n := STRINGS.Utf8To16(s, wstr);

    i := 0;
    WHILE i < n DO
        codes.data[idx] := ORD(wstr[i]) MOD 256;
        INC(idx);
        codes.data[idx] := ORD(wstr[i]) DIV 256;
        INC(idx);
        INC(i)
    END;
    codes.data[idx] := 0;
    INC(idx);
    codes.data[idx] := 0;
    INC(idx);

    codes.dcount := idx

    RETURN res
END putstrW;


PROCEDURE putstrW1* (c: INTEGER): INTEGER;
VAR
    res, idx: INTEGER;

BEGIN
    IF codes.wcharoffs[c] = -1 THEN
        res := codes.dcount;

        IF ODD(res) THEN
            codes.data[res] := 0;
            INC(res)
        END;

        idx := res;
        codes.data[idx] := c MOD 256;
        INC(idx);
        codes.data[idx] := c DIV 256;
        INC(idx);
        codes.data[idx] := 0;
        INC(idx);
        codes.data[idx] := 0;
        INC(idx);
        codes.dcount := idx;
        codes.wcharoffs[c] := res
    ELSE
        res := codes.wcharoffs[c]
    END

    RETURN res
END putstrW1;


PROCEDURE SetMinDataSize* (size: INTEGER);
BEGIN
    codes.dmin := codes.dcount + size
END SetMinDataSize;


PROCEDURE push (stk: CMDSTACK; cmd: COMMAND);
BEGIN
    INC(stk.top);
    stk.data[stk.top] := cmd
END push;


PROCEDURE pop (stk: CMDSTACK): COMMAND;
VAR
    res: COMMAND;
BEGIN
    res := stk.data[stk.top];
    DEC(stk.top)
    RETURN res
END pop;


PROCEDURE pushBegEnd* (VAR beg, end: COMMAND);
BEGIN
    push(codes.begcall, beg);
    push(codes.endcall, end);
    beg := codes.last;
    end := beg.next(COMMAND)
END pushBegEnd;


PROCEDURE popBegEnd* (VAR beg, end: COMMAND);
BEGIN
    beg := pop(codes.begcall);
    end := pop(codes.endcall)
END popBegEnd;


PROCEDURE AddRec* (base: INTEGER);
BEGIN
    codes.types[codes.tcount] := base;
    INC(codes.tcount)
END AddRec;


PROCEDURE insert (cur, nov: COMMAND);
BEGIN
    commands.insert(commands, cur, nov);
    codes.last := nov
END insert;


PROCEDURE AddCmd* (opcode: INTEGER; param: INTEGER);
VAR
    cmd: COMMAND;
BEGIN
    NEW(cmd);
    cmd.opcode := opcode;
    cmd.label := 0;
    cmd.param := param;
    insert(codes.last, cmd)
END AddCmd;


PROCEDURE NewLabel* (): INTEGER;
BEGIN
    INC(codes.lcount)
    RETURN codes.lcount
END NewLabel;


PROCEDURE SetLabel* (label: INTEGER);
BEGIN
    AddCmd(opLABEL, label)
END SetLabel;


PROCEDURE SetProcLabel* (label: INTEGER);
BEGIN
    AddCmd(opPROC, label)
END SetProcLabel;


PROCEDURE AddCmd0* (opcode: INTEGER);
BEGIN
    AddCmd(opcode, 0)
END AddCmd0;


PROCEDURE delete (cmd: COMMAND);
BEGIN
    commands.delete(commands, cmd)
END delete;


PROCEDURE AddJmpCmd* (opcode: INTEGER; label: INTEGER);
VAR
    prev: COMMAND;
    not:  BOOLEAN;

BEGIN
    prev := codes.last;
    not := prev.opcode = opNOT;
    IF not THEN
        IF opcode = opJE THEN
            opcode := opJNE
        ELSIF opcode = opJNE THEN
            opcode := opJE
        ELSE
            not := FALSE
        END
    END;

    AddCmd(opcode, label);
    codes.last.label := label;

    IF not THEN
        delete(prev)
    END

END AddJmpCmd;


PROCEDURE OnError* (errlabel: INTEGER; line, error: INTEGER);
BEGIN
    AddCmd(opERRC, LSL(line, 4) + error);
    AddJmpCmd(opJMP, errlabel)
END OnError;


PROCEDURE TypeGuard* (rec: BOOLEAN; t: INTEGER; errlabel: INTEGER; line, error: INTEGER);
VAR
    label: INTEGER;
BEGIN
    IF rec THEN
        AddCmd(opTYPEGR, t)
    ELSE
        AddCmd(opTYPEG, t)
    END;
    label := NewLabel();
    AddJmpCmd(opJE, label);
    OnError(errlabel, line, error);
    SetLabel(label)
END TypeGuard;


PROCEDURE TypeCheck* (t: INTEGER);
BEGIN
    AddCmd(opIS, t)
END TypeCheck;


PROCEDURE TypeCheckRec* (t: INTEGER);
BEGIN
    AddCmd(opISREC, t)
END TypeCheckRec;


PROCEDURE New* (size, typenum: INTEGER);
BEGIN
    AddCmd(opNEW, size);
    codes.last.param2 := typenum
END New;


PROCEDURE fcmp* (opcode: BYTE);
BEGIN
    AddCmd(opcode, 0);
    DEC(fregs, 2);
    ASSERT(fregs >= 0)
END fcmp;


PROCEDURE isCmp (opcode: BYTE): BOOLEAN;
(*
    opEQ*  = 30; opNE*  = 31; opLT*  = 32; opLE*  = 33; opGT*  = 34; opGE*  = 35;
    opEQL* = 36; opNEL* = 37; opLTL* = 38; opLEL* = 39; opGTL* = 40; opGEL* = 41;
    opEQR* = 42; opNER* = 43; opLTR* = 44; opLER* = 45; opGTR* = 46; opGER* = 47;

    opEQS*   =  52; opNES*   =  53; opLTS*   =  54; opLES*   =  55; opGTS*   =  56; opGES*   =  57;
    opEQS2*  = 217; opNES2*  = 218; opLTS2*  = 219; opLES2*  = 220; opGTS2*  = 221; opGES2*  = 222;
    opEQSW*  = 223; opNESW*  = 224; opLTSW*  = 225; opLESW*  = 226; opGTSW*  = 227; opGESW*  = 228;
    opEQSW2* = 229; opNESW2* = 230; opLTSW2* = 231; opLESW2* = 232; opGTSW2* = 233; opGESW2* = 234;

    opEQF*  = 80; opNEF*  = 81; opLTF*  = 82; opLEF*  = 83; opGTF*  = 84; opGEF*  = 85;
    opEQFI* = 86; opNEFI* = 87; opLTFI* = 88; opLEFI* = 89; opGTFI* = 90; opGEFI* = 91;

    opEQP* = 143; opNEP* = 144;
                                                                                  *)

    RETURN (opEQ <= opcode) & (opcode <= opGER) OR (opEQS <= opcode) & (opcode <= opGES) OR
           (opEQS2 <= opcode) & (opcode <= opGES2) OR (opEQSW <= opcode) & (opcode <= opGESW) OR
           (opEQSW2 <= opcode) & (opcode <= opGESW2) OR
           (opEQF <= opcode) & (opcode <= opGEFI) OR (opcode = opEQP) OR (opcode = opNEP)
END isCmp;


PROCEDURE InvCmp (opcode: BYTE): INTEGER;
BEGIN

    CASE opcode OF

    |opEQ:    opcode := opNE
    |opNE:    opcode := opEQ
    |opLT:    opcode := opGE
    |opLE:    opcode := opGT
    |opGT:    opcode := opLE
    |opGE:    opcode := opLT

    |opEQR:   opcode := opNER
    |opNER:   opcode := opEQR
    |opLTR:   opcode := opGER
    |opLER:   opcode := opGTR
    |opGTR:   opcode := opLER
    |opGER:   opcode := opLTR

    |opEQL:   opcode := opNEL
    |opNEL:   opcode := opEQL
    |opLTL:   opcode := opGEL
    |opLEL:   opcode := opGTL
    |opGTL:   opcode := opLEL
    |opGEL:   opcode := opLTL

    |opEQS:   opcode := opNES
    |opNES:   opcode := opEQS
    |opLTS:   opcode := opGES
    |opLES:   opcode := opGTS
    |opGTS:   opcode := opLES
    |opGES:   opcode := opLTS

    |opEQS2:  opcode := opNES2
    |opNES2:  opcode := opEQS2
    |opLTS2:  opcode := opGES2
    |opLES2:  opcode := opGTS2
    |opGTS2:  opcode := opLES2
    |opGES2:  opcode := opLTS2

    |opEQSW:  opcode := opNESW
    |opNESW:  opcode := opEQSW
    |opLTSW:  opcode := opGESW
    |opLESW:  opcode := opGTSW
    |opGTSW:  opcode := opLESW
    |opGESW:  opcode := opLTSW

    |opEQSW2: opcode := opNESW2
    |opNESW2: opcode := opEQSW2
    |opLTSW2: opcode := opGESW2
    |opLESW2: opcode := opGTSW2
    |opGTSW2: opcode := opLESW2
    |opGESW2: opcode := opLTSW2

    |opEQF:   opcode := opNEF
    |opNEF:   opcode := opEQF
    |opLTF:   opcode := opGEF
    |opLEF:   opcode := opGTF
    |opGTF:   opcode := opLEF
    |opGEF:   opcode := opLTF

    |opEQFI:  opcode := opNEFI
    |opNEFI:  opcode := opEQFI
    |opLTFI:  opcode := opGEFI
    |opLEFI:  opcode := opGTFI
    |opGTFI:  opcode := opLEFI
    |opGEFI:  opcode := opLTFI

    |opEQP:   opcode := opNEP
    |opNEP:   opcode := opEQP

    END

    RETURN opcode
END InvCmp;


PROCEDURE not*;
VAR
    prev: COMMAND;
BEGIN
    prev := codes.last;
    IF prev.opcode = opNOT THEN
        codes.last := prev.prev(COMMAND);
        delete(prev)
    ELSIF isCmp(prev.opcode) THEN
        prev.opcode := InvCmp(prev.opcode)
    ELSE
        AddCmd0(opNOT)
    END
END not;


PROCEDURE Enter* (): COMMAND;
BEGIN
    AddCmd0(opENTER)
    RETURN codes.last
END Enter;


PROCEDURE Leave* (result, float: BOOLEAN; paramsize: INTEGER);
BEGIN
    IF result THEN
        IF float THEN
            AddCmd(opLEAVEF, paramsize)
        ELSE
            AddCmd(opLEAVER, paramsize)
        END
    ELSE
        AddCmd(opLEAVE, paramsize)
    END
END Leave;


PROCEDURE Call* (proc: INTEGER);
BEGIN
    AddJmpCmd(opCALL, proc)
END Call;


PROCEDURE CallImp* (proc: LISTS.ITEM);
BEGIN
    AddJmpCmd(opCALLI, proc(IMPORT_PROC).label)
END CallImp;


PROCEDURE CallP*;
BEGIN
    AddCmd0(opCALLP)
END CallP;


PROCEDURE AssignProc* (proc: INTEGER);
BEGIN
    AddJmpCmd(opSAVEP, proc)
END AssignProc;


PROCEDURE AssignImpProc* (proc: LISTS.ITEM);
BEGIN
    AddJmpCmd(opSAVEIP, proc(IMPORT_PROC).label)
END AssignImpProc;


PROCEDURE PushProc* (proc: INTEGER);
BEGIN
    AddJmpCmd(opPUSHP, proc)
END PushProc;


PROCEDURE PushImpProc* (proc: LISTS.ITEM);
BEGIN
    AddJmpCmd(opPUSHIP, proc(IMPORT_PROC).label)
END PushImpProc;


PROCEDURE ProcCmp* (proc: INTEGER; eq: BOOLEAN);
BEGIN
    IF eq THEN
        AddJmpCmd(opEQP, proc)
    ELSE
        AddJmpCmd(opNEP, proc)
    END
END ProcCmp;


PROCEDURE ProcImpCmp* (proc: LISTS.ITEM; eq: BOOLEAN);
BEGIN
    IF eq THEN
        AddJmpCmd(opEQIP, proc(IMPORT_PROC).label)
    ELSE
        AddJmpCmd(opNEIP, proc(IMPORT_PROC).label)
    END
END ProcImpCmp;


PROCEDURE SysGet* (size: INTEGER);
BEGIN
    AddCmd(opGET, size)
END SysGet;


PROCEDURE load* (size: INTEGER);
VAR
    last: COMMAND;

BEGIN
    last := codes.last;
    CASE size OF
    |1:
        IF last.opcode = opLADR THEN
            last.opcode := opLLOAD8
        ELSIF last.opcode = opVADR THEN
            last.opcode := opVLOAD8
        ELSIF last.opcode = opGADR THEN
            last.opcode := opGLOAD8
        ELSE
            AddCmd0(opLOAD8)
        END

    |2:
        IF last.opcode = opLADR THEN
            last.opcode := opLLOAD16
        ELSIF last.opcode = opVADR THEN
            last.opcode := opVLOAD16
        ELSIF last.opcode = opGADR THEN
            last.opcode := opGLOAD16
        ELSE
            AddCmd0(opLOAD16)
        END

    |4:
        IF last.opcode = opLADR THEN
            last.opcode := opLLOAD32
        ELSIF last.opcode = opVADR THEN
            last.opcode := opVLOAD32
        ELSIF last.opcode = opGADR THEN
            last.opcode := opGLOAD32
        ELSE
            AddCmd0(opLOAD32)
        END

    |8:
        IF last.opcode = opLADR THEN
            last.opcode := opLLOAD64
        ELSIF last.opcode = opVADR THEN
            last.opcode := opVLOAD64
        ELSIF last.opcode = opGADR THEN
            last.opcode := opGLOAD64
        ELSE
            AddCmd0(opLOAD64)
        END
    END
END load;


PROCEDURE SysPut* (size: INTEGER);
BEGIN
    CASE size OF
    |1: AddCmd0(opSAVE8)
    |2: AddCmd0(opSAVE16)
    |4: AddCmd0(opSAVE32)
    |8: AddCmd0(opSAVE64)
    END
END SysPut;


PROCEDURE savef*;
BEGIN
    AddCmd0(opSAVEF);
    DEC(fregs);
    ASSERT(fregs >= 0)
END savef;


PROCEDURE pushf*;
BEGIN
    AddCmd0(opPUSHF);
    DEC(fregs);
    ASSERT(fregs >= 0)
END pushf;


PROCEDURE loadf* (): BOOLEAN;
BEGIN
    AddCmd0(opLOADF);
    INC(fregs)
    RETURN fregs < FREGS
END loadf;


PROCEDURE inf* (): BOOLEAN;
BEGIN
    AddCmd0(opINF);
    INC(fregs)
    RETURN fregs < FREGS
END inf;


PROCEDURE fbinop* (opcode: BYTE);
BEGIN
    AddCmd0(opcode);
    DEC(fregs);
    ASSERT(fregs > 0)
END fbinop;


PROCEDURE saves* (offset, length: INTEGER);
BEGIN
    AddCmd(opSAVES, offset);
    codes.last.param2 := length
END saves;


PROCEDURE abs* (real: BOOLEAN);
BEGIN
    IF real THEN
        AddCmd0(opFABS)
    ELSE
        AddCmd0(opABS)
    END
END abs;


PROCEDURE floor*;
BEGIN
    AddCmd0(opFLOOR);
    DEC(fregs);
    ASSERT(fregs >= 0)
END floor;


PROCEDURE flt* (): BOOLEAN;
BEGIN
    AddCmd0(opFLT);
    INC(fregs)
    RETURN fregs < FREGS
END flt;


PROCEDURE odd*;
BEGIN
    AddCmd0(opODD)
END odd;


PROCEDURE ord*;
BEGIN
    AddCmd0(opORD)
END ord;


PROCEDURE shift_minmax* (op: CHAR);
BEGIN
    CASE op OF
    |"A": AddCmd0(opASR)
    |"L": AddCmd0(opLSL)
    |"O": AddCmd0(opROR)
    |"R": AddCmd0(opLSR)
    |"m": AddCmd0(opMIN)
    |"x": AddCmd0(opMAX)
    END
END shift_minmax;


PROCEDURE shift_minmax1* (op: CHAR; x: INTEGER);
BEGIN
    CASE op OF
    |"A": AddCmd(opASR1, x)
    |"L": AddCmd(opLSL1, x)
    |"O": AddCmd(opROR1, x)
    |"R": AddCmd(opLSR1, x)
    |"m": AddCmd(opMINC, x)
    |"x": AddCmd(opMAXC, x)
    END
END shift_minmax1;


PROCEDURE shift_minmax2* (op: CHAR; x: INTEGER);
BEGIN
    CASE op OF
    |"A": AddCmd(opASR2, x)
    |"L": AddCmd(opLSL2, x)
    |"O": AddCmd(opROR2, x)
    |"R": AddCmd(opLSR2, x)
    |"m": AddCmd(opMINC, x)
    |"x": AddCmd(opMAXC, x)
    END
END shift_minmax2;


PROCEDURE len* (dim: INTEGER);
BEGIN
    AddCmd(opLEN, dim)
END len;


PROCEDURE Float* (r: REAL);
BEGIN
    AddCmd0(opCONSTF);
    codes.last.float := r;
    INC(fregs);
    ASSERT(fregs <= FREGS)
END Float;


PROCEDURE precall* (flt: BOOLEAN): INTEGER;
VAR
    res: INTEGER;
BEGIN
    res := fregs;
    AddCmd(opPRECALL, res);
    codes.last.param2 := ORD(flt);
    fregs := 0
    RETURN res
END precall;


PROCEDURE resf* (_fregs: INTEGER): BOOLEAN;
BEGIN
    AddCmd(opRESF, _fregs);
    fregs := _fregs + 1
    RETURN fregs < FREGS
END resf;


PROCEDURE res* (_fregs: INTEGER);
BEGIN
    AddCmd(opRES, _fregs);
    fregs := _fregs
END res;


PROCEDURE retf*;
BEGIN
    DEC(fregs);
    ASSERT(fregs = 0)
END retf;


PROCEDURE drop*;
BEGIN
    AddCmd0(opDROP)
END drop;


PROCEDURE case* (a, b, label: INTEGER);
BEGIN
    AddCmd0(opCASE);
    codes.last.param  := a;
    codes.last.param2 := b;
    codes.last.label  := label
END case;


PROCEDURE case1* (a, label: INTEGER);
BEGIN
    AddCmd0(opCASE1);
    codes.last.param  := a;
    codes.last.label  := label
END case1;


PROCEDURE caset* (a, label: INTEGER);
BEGIN
    AddCmd0(opCASET);
    codes.last.param  := a;
    codes.last.label  := label
END caset;


PROCEDURE AddExp* (label: INTEGER; name: SCAN.LEXSTR);
VAR
    exp: EXPORT_PROC;

BEGIN
    NEW(exp);
    exp.label := label;
    exp.name  := name;
    codes.export.push(codes.export, exp)
END AddExp;


PROCEDURE AddImp* (dll, proc: SCAN.LEXSTR): IMPORT_PROC;
VAR
    lib: IMPORT_LIB;
    p:   IMPORT_PROC;

BEGIN
    lib := codes.import.first(IMPORT_LIB);
    WHILE (lib # NIL) & (lib.name # dll) DO
        lib := lib.next(IMPORT_LIB)
    END;

    IF lib = NIL THEN
        NEW(lib);
        lib.name := dll;
        lib.procs := LISTS.create(NIL);
        codes.import.push(codes.import, lib)
    END;

    p := lib.procs.first(IMPORT_PROC);
    WHILE (p # NIL) & (p.name # proc) DO
        p := p.next(IMPORT_PROC)
    END;

    IF p = NIL THEN
        NEW(p);
        p.name  := proc;
        p.label := NewLabel();
        p.lib   := lib;
        p.count := 1;
        lib.procs.push(lib.procs, p)
    ELSE
        INC(p.count)
    END

    RETURN p
END AddImp;


PROCEDURE DelImport* (imp: LISTS.ITEM);
VAR
    lib: IMPORT_LIB;

BEGIN
    DEC(imp(IMPORT_PROC).count);
    IF imp(IMPORT_PROC).count = 0 THEN
        lib := imp(IMPORT_PROC).lib;
        lib.procs.delete(lib.procs, imp);
        IF lib.procs.first = NIL THEN
            codes.import.delete(codes.import, lib)
        END
    END
END DelImport;


PROCEDURE init*;
VAR
    cmd: COMMAND;
    i:   INTEGER;

BEGIN
    NEW(codes);
    NEW(codes.begcall);
    codes.begcall.top := -1;
    NEW(codes.endcall);
    codes.endcall.top := -1;
    codes.commands := LISTS.create(NIL);
    codes.export   := LISTS.create(NIL);
    codes.import   := LISTS.create(NIL);
    commands := codes.commands;
    NEW(cmd); cmd.opcode := opNOP; commands.push(commands, cmd);
    codes.last := cmd;
    NEW(cmd); cmd.opcode := opNOP; commands.push(commands, cmd);
    codes.tcount := 1;
    codes.types[0] := 0;
    codes.lcount := 0;
    codes.dcount := 0;

    fregs := 0;

    FOR i := 0 TO LEN(codes.charoffs) - 1 DO
        codes.charoffs[i] := -1
    END;

    FOR i := 0 TO LEN(codes.wcharoffs) - 1 DO
        codes.wcharoffs[i] := -1
    END
END init;


END CODE.