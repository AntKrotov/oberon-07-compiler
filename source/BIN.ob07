(*
    BSD 2-Clause License

    Copyright (c) 2018, Anton Krotov
    All rights reserved.
*)

MODULE BIN;

IMPORT LISTS, MACHINE;


TYPE

    RELOC* = POINTER TO RECORD (LISTS.ITEM)

        opcode*: INTEGER;
        offset*: INTEGER

    END;

    IMPRT* = POINTER TO RECORD (LISTS.ITEM)

        nameoffs*: INTEGER;
        label*:    INTEGER;

        OriginalFirstThunk*,
        FirstThunk*: INTEGER

    END;

    EXPRT* = POINTER TO RECORD (LISTS.ITEM)

        nameoffs*: INTEGER;
        label*:    INTEGER

    END;

    PROGRAM* = POINTER TO RECORD

        code*:      ARRAY 2000000 OF BYTE;     ccount*: INTEGER;
        data*:      ARRAY 1000000 OF BYTE;     dcount*: INTEGER;
        labels*:    ARRAY  100000 OF INTEGER;
        bss*:       INTEGER;
        stack*:     INTEGER;
        vmajor*,
        vminor*:    WCHAR;

        modname*,
        import*,
        export*:    INTEGER;

        rel_list*:  LISTS.LIST;
        imp_list*:  LISTS.LIST;
        exp_list*:  LISTS.LIST

    END;


PROCEDURE create* (): PROGRAM;
VAR
    program: PROGRAM;
    i: INTEGER;
    empty: EXPRT;

BEGIN
    NEW(program);

    program.bss    := 0;
    program.ccount := 0;
    program.dcount := 0;

    FOR i := 0 TO LEN(program.labels) - 1 DO
        program.labels[i] := 0
    END;

    program.rel_list := LISTS.create(NIL);
    program.imp_list := LISTS.create(NIL);
    program.exp_list := LISTS.create(NIL);

    NEW(empty);
    empty.label := 0;
    empty.nameoffs := LEN(program.data) - 1;
    program.data[LEN(program.data) - 1] := 0;
    program.exp_list.push(program.exp_list, empty)

    RETURN program
END create;


PROCEDURE SetParams* (program: PROGRAM; bss, stack: INTEGER; vmajor, vminor: WCHAR);
BEGIN
    program.bss    := bss;
    program.stack  := stack;
    program.vmajor := vmajor;
    program.vminor := vminor
END SetParams;


PROCEDURE PutReloc* (program: PROGRAM; opcode: INTEGER);
VAR
    cmd: RELOC;

BEGIN
    NEW(cmd);
    cmd.opcode := opcode;
    cmd.offset := program.ccount;
    program.rel_list.push(program.rel_list, cmd)
END PutReloc;


PROCEDURE PutData* (program: PROGRAM; b: BYTE);
BEGIN
    program.data[program.dcount] := b;
    INC(program.dcount)
END PutData;


PROCEDURE get32le* (array: ARRAY OF BYTE; idx: INTEGER): INTEGER;
VAR
    b: BYTE;
    i: INTEGER;
    x: INTEGER;

BEGIN
    x := 0;

    FOR i := 3 TO 0 BY -1 DO
        b := array[idx + i];
        x := LSL(x, 8) + b
    END;

    IF MACHINE.native.bit_depth = 64 THEN
        x := LSL(x, 16);
        x := LSL(x, 16);
        x := ASR(x, 16);
        x := ASR(x, 16)
    END

    RETURN x
END get32le;


PROCEDURE put32le* (VAR array: ARRAY OF BYTE; idx: INTEGER; x: INTEGER);
VAR
    i: INTEGER;

BEGIN
    FOR i := 0 TO 3 DO
        array[idx + i] := MACHINE.Byte(x, i)
    END
END put32le;


PROCEDURE PutData32LE* (program: PROGRAM; i: INTEGER);
BEGIN
    put32le(program.data, program.dcount, i);
    INC(program.dcount, 4)
END PutData32LE;


PROCEDURE PutDataStr* (program: PROGRAM; s: ARRAY OF CHAR);
VAR
    i: INTEGER;

BEGIN
    i := 0;
    WHILE s[i] # 0X DO
        program.data[program.dcount] := ORD(s[i]);
        INC(program.dcount);
        INC(i)
    END
END PutDataStr;


PROCEDURE PutCode* (program: PROGRAM; b: BYTE);
BEGIN
    program.code[program.ccount] := b;
    INC(program.ccount)
END PutCode;


PROCEDURE PutCode32LE* (program: PROGRAM; i: INTEGER);
BEGIN
    put32le(program.code, program.ccount, i);
    INC(program.ccount, 4)
END PutCode32LE;


PROCEDURE SetLabel* (program: PROGRAM; label: INTEGER);
BEGIN
    program.labels[label] := program.ccount
END SetLabel;


PROCEDURE Import* (program: PROGRAM; name: ARRAY OF CHAR; label: INTEGER);
VAR
    imp: IMPRT;

BEGIN
    PutData(program, 0);
    PutData(program, 0);
    IF ODD(program.dcount) THEN
        PutData(program, 0)
    END;

    NEW(imp);
    imp.nameoffs := program.dcount;
    imp.label := label;
    program.imp_list.push(program.imp_list, imp);

    PutDataStr(program, name);
    PutData(program, 0);
END Import;


PROCEDURE less (program: PROGRAM; a, b: EXPRT): BOOLEAN;
VAR
    i, j: INTEGER;

BEGIN
    i := a.nameoffs;
    j := b.nameoffs;

    WHILE (program.data[i] # 0) & (program.data[j] # 0) & (program.data[i] = program.data[j]) DO
        INC(i);
        INC(j)
    END

    RETURN program.data[i] < program.data[j]
END less;


PROCEDURE Export* (program: PROGRAM; name: ARRAY OF CHAR; label: INTEGER);
VAR
    exp, cur: EXPRT;

BEGIN
    NEW(exp);
    exp.nameoffs := program.dcount;
    exp.label := program.labels[label];
    PutDataStr(program, name);
    PutData(program, 0);

    cur := program.exp_list.first(EXPRT);
    WHILE (cur # NIL) & less(program, cur, exp) DO
        cur := cur.next(EXPRT)
    END;

    IF cur # NIL THEN
        cur := cur.prev(EXPRT);
        program.exp_list.insert(program.exp_list, cur, exp)
    ELSE
        program.exp_list.push(program.exp_list, exp)
    END

END Export;


PROCEDURE GetIProc* (program: PROGRAM; n: INTEGER): IMPRT;
VAR
    import: IMPRT;
    res:    IMPRT;

BEGIN
    import  := program.imp_list.first(IMPRT);

    res := NIL;
    WHILE (import # NIL) & (n >= 0) DO
        IF import.label # 0 THEN
            res := import;
            DEC(n)
        END;
        import := import.next(IMPRT)
    END;

    ASSERT(n = -1)
    RETURN res
END GetIProc;


PROCEDURE fixup* (program: PROGRAM);
VAR
    rel:    RELOC;
    imp:    IMPRT;
    nproc:  INTEGER;
    L:      INTEGER;

BEGIN

    nproc := 0;
    imp := program.imp_list.first(IMPRT);
    WHILE imp # NIL DO
        IF imp.label # 0 THEN
            program.labels[imp.label] := nproc;
            INC(nproc)
        END;
        imp := imp.next(IMPRT)
    END;

    rel := program.rel_list.first(RELOC);
    WHILE rel # NIL DO

        IF rel.opcode = 1 THEN
            L := get32le(program.code, rel.offset);
            put32le(program.code, rel.offset, program.labels[L] - rel.offset - 4)
        ELSIF rel.opcode IN {2, 10} THEN
            L := get32le(program.code, rel.offset);
            put32le(program.code, rel.offset, program.labels[L])
        END;

        rel := rel.next(RELOC)
    END

END fixup;


END BIN.