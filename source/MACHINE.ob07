MODULE MACHINE;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mConst := modConstante;

VAR
	target*,
	native*: RECORD
			bit_depth*,
			maxInt*,
			minInt*,
			maxSet*,
			maxHex*:    INTEGER;
			maxReal*:   REAL
		END;

	b64to32*, bInitialized: BOOLEAN;

PROCEDURE BitDepth_Set* (bBitDepth: INTEGER);
	VAR
		_i: INTEGER;
	BEGIN
		ASSERT((bBitDepth = 32) OR (bBitDepth = 64));

		native.bit_depth := 0;
		_i := 1;
		REPEAT
			_i := ROR(_i, 1);
			INC(native.bit_depth)
		UNTIL _i = 1;

		native.maxSet      := native.bit_depth - 1;
		native.maxHex      := native.bit_depth DIV 4;
		native.minInt      := 1;
		native.minInt      := ROR(native.minInt, 1);
		native.maxInt      := -2;
		native.maxInt      := ROR(native.maxInt, 1);
		native.maxReal     := 1.9;
		PACK(native.maxReal, 1023);

		target.bit_depth   := bBitDepth;
		bBitDepth := MIN(native.bit_depth, bBitDepth);

		target.maxSet      := bBitDepth - 1;
		target.maxHex      := bBitDepth DIV 4;
		target.minInt      := ASR(native.minInt, native.bit_depth - bBitDepth);
		target.maxInt      := ASR(native.maxInt, native.bit_depth - bBitDepth);
		target.maxReal     := 1.9;
		PACK(target.maxReal, 1023);

		b64to32 := (target.bit_depth = 32) & (native.bit_depth = 64);

		bInitialized := TRUE
	END BitDepth_Set;

PROCEDURE Byte_Get* (pNum: INTEGER; pIdx: INTEGER): BYTE;
	BEGIN
		WHILE pIdx > 0 DO
			pNum := ASR(pNum, 8);
			DEC(pIdx)
		END

		RETURN ORD(BITS(pNum) * {0..7})
	END Byte_Get;

PROCEDURE IsAlign* (VAR pBytes: INTEGER; pAlign: INTEGER): BOOLEAN;
	VAR
		_bRes: BOOLEAN;
	BEGIN
		ASSERT(bInitialized);
		IF pBytes MOD pAlign # 0 THEN
			_bRes  := native.maxInt - pBytes >= pAlign - (pBytes MOD pAlign);
			IF _bRes THEN
				pBytes := pBytes + pAlign - (pBytes MOD pAlign)
			END
		ELSE
			_bRes := TRUE
		END
		RETURN _bRes
	END IsAlign;

PROCEDURE Int32To64* (pValue: INTEGER): INTEGER;
	BEGIN
		IF native.bit_depth = 64 THEN
			pValue := LSL(pValue, 16);
			pValue := LSL(pValue, 16);
			pValue := ASR(pValue, 16);
			pValue := ASR(pValue, 16)
		END

		RETURN pValue
	END Int32To64;

PROCEDURE Int64To32* (pValue: INTEGER): INTEGER;
	BEGIN
		IF native.bit_depth = 64 THEN
			pValue := LSL(pValue, 16);
			pValue := LSL(pValue, 16);
			pValue := LSR(pValue, 16);
			pValue := LSR(pValue, 16)
		END

		RETURN pValue
	END Int64To32;

BEGIN
	bInitialized := FALSE
END MACHINE.
