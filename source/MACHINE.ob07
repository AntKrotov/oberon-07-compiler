(*
    BSD 2-Clause License

    Copyright (c) 2018, 2019, Anton Krotov
    All rights reserved.
*)

MODULE MACHINE;

IMPORT UTILS;


CONST

    min32* = -2147483647-1;
    max32* =  2147483647;


VAR

    target*:

      RECORD

          bit_depth*,
          maxInt*,
          minInt*,
          maxSet*,
          maxHex*:    INTEGER;

          maxReal*:   REAL

      END;

    bit_diff*: INTEGER;


PROCEDURE SetBitDepth* (BitDepth: INTEGER);
BEGIN
    ASSERT((BitDepth = 16) OR (BitDepth = 32) OR (BitDepth = 64));
    bit_diff := UTILS.bit_depth - BitDepth;
    ASSERT(bit_diff >= 0);

    target.bit_depth := BitDepth;
    target.maxSet    := BitDepth - 1;
    target.maxHex    := BitDepth DIV 4;
    target.minInt    := ASR(UTILS.minint, bit_diff);
    target.maxInt    := ASR(UTILS.maxint, bit_diff);
    target.maxReal   := 1.9;
    PACK(target.maxReal, 1023);
END SetBitDepth;


PROCEDURE Byte* (n: INTEGER; idx: INTEGER): BYTE;
    RETURN ASR(n, 8 * idx) MOD 256
END Byte;


PROCEDURE Align* (VAR bytes: INTEGER; align: INTEGER): BOOLEAN;
VAR
    res: BOOLEAN;

BEGIN
    IF bytes MOD align # 0 THEN
        res := UTILS.maxint - bytes >= align - (bytes MOD align);
        IF res THEN
            bytes := bytes + align - (bytes MOD align)
        END
    ELSE
        res := TRUE
    END

    RETURN res
END Align;


PROCEDURE Long* (value: INTEGER): INTEGER;
    RETURN ASR(LSL(value, bit_diff), bit_diff)
END Long;


PROCEDURE Short* (value: INTEGER): INTEGER;
    RETURN LSR(LSL(value, bit_diff), bit_diff)
END Short;


PROCEDURE Log2* (x: INTEGER): INTEGER;
VAR
    n: INTEGER;

BEGIN
    ASSERT(x > 0);

    n := 0;
    WHILE ~ODD(x) DO
        x := x DIV 2;
        INC(n)
    END;

    IF x # 1 THEN
        n := -1
    END

    RETURN n
END Log2;


END MACHINE.