(*
    BSD 2-Clause License

    Copyright (c) 2018, Anton Krotov
    All rights reserved.
*)

MODULE MACHINE;

IMPORT UTILS;


CONST

    min32* = -2147483647-1;
    max32* = 2147483647;


VAR

    target*,
    native*:

      RECORD

          bit_depth*,
          maxInt*,
          minInt*,
          maxSet*,
          maxHex*:    INTEGER;

          maxReal*:   REAL

      END;

    _64to32*: BOOLEAN;


PROCEDURE SetBitDepth* (pBitDepth: INTEGER);
BEGIN
    ASSERT(pBitDepth <= UTILS.bit_depth);
    ASSERT((pBitDepth = 32) OR (pBitDepth = 64));

    _64to32 := (UTILS.bit_depth = 64) & (pBitDepth = 32);

    native.bit_depth   := UTILS.bit_depth;
    native.maxSet      := UTILS.bit_depth - 1;
    native.maxHex      := UTILS.bit_depth DIV 4;
    native.minInt      := UTILS.minint;
    native.maxInt      := UTILS.maxint;
    native.maxReal     := 1.9;
    PACK(native.maxReal, 1023);

    target.bit_depth   := pBitDepth;
    target.maxSet      := pBitDepth - 1;
    target.maxHex      := pBitDepth DIV 4;
    target.minInt      := ASR(UTILS.minint, UTILS.bit_depth - pBitDepth);
    target.maxInt      := ASR(UTILS.maxint, UTILS.bit_depth - pBitDepth);
    target.maxReal     := 1.9;
    PACK(target.maxReal, 1023);
END SetBitDepth;


PROCEDURE Byte* (n: INTEGER; idx: INTEGER): BYTE;
BEGIN
    WHILE idx > 0 DO
        n := ASR(n, 8);
        DEC(idx)
    END

    RETURN ORD(BITS(n) * {0..7})
END Byte;


PROCEDURE Align* (VAR bytes: INTEGER; align: INTEGER): BOOLEAN;
VAR
    res: BOOLEAN;

BEGIN
    IF bytes MOD align # 0 THEN
        res  := UTILS.maxint - bytes >= align - (bytes MOD align);
        IF res THEN
            bytes := bytes + align - (bytes MOD align)
        END
    ELSE
        res := TRUE
    END

    RETURN res
END Align;


PROCEDURE Int32To64* (value: INTEGER): INTEGER;
BEGIN
    IF UTILS.bit_depth = 64 THEN
        value := LSL(value, 16);
        value := LSL(value, 16);
        value := ASR(value, 16);
        value := ASR(value, 16)
    END

    RETURN value
END Int32To64;


PROCEDURE Int64To32* (value: INTEGER): INTEGER;
BEGIN
    IF UTILS.bit_depth = 64 THEN
        value := LSL(value, 16);
        value := LSL(value, 16);
        value := LSR(value, 16);
        value := LSR(value, 16)
    END

    RETURN value
END Int64To32;


END MACHINE.