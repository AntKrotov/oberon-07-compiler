(*
    BSD 2-Clause License

    Copyright (c) 2019, Anton Krotov
    All rights reserved.
*)

MODULE THUMB;

IMPORT PROG, LISTS, CHL := CHUNKLISTS, BIN, REG, IL, C := CONSOLE, UTILS, WR := WRITER;


CONST

    R0 = 0; R1 = 1; R2 = 2; R3 = 3;

    SP = 13; LR = 14; PC = 15;

    ACC = R0;

    je = 0; jne = 1; jnb = 2; jb = 3; jge = 10; jl = 11; jg = 12; jle = 13;

    FileAlignment = 1000H;


TYPE

    COMMAND = IL.COMMAND;

    ANYCODE = POINTER TO RECORD (LISTS.ITEM)

        offset: INTEGER

    END;

    CODE = POINTER TO RECORD (ANYCODE)

        code: INTEGER

    END;

    LABEL = POINTER TO RECORD (ANYCODE)

        label: INTEGER

    END;

    JUMP = POINTER TO RECORD (ANYCODE)

        label, diff: INTEGER;
        short: BOOLEAN

    END;

    JMP = POINTER TO RECORD (JUMP)

    END;

    JCC = POINTER TO RECORD (JUMP)

        cond:   INTEGER;
        short2: BOOLEAN

    END;

    CALL = POINTER TO RECORD (JUMP)

    END;

    RELOC = POINTER TO RECORD (ANYCODE)

        reg, rel, value: INTEGER

    END;

    RELOCCODE = ARRAY 7 OF INTEGER;


VAR

    R: REG.REGS;

    tcount: INTEGER;

    CodeList: LISTS.LIST;

    program: BIN.PROGRAM;


PROCEDURE Emit (code: INTEGER);
VAR
    c: CODE;

BEGIN
    NEW(c);
    c.code := code;
    LISTS.push(CodeList, c)
END Emit;


PROCEDURE EmitLabel (label: INTEGER);
VAR
    L: LABEL;

BEGIN
    NEW(L);
    L.label := label;
    LISTS.push(CodeList, L)
END EmitLabel;


PROCEDURE jcc (cond, label: INTEGER);
VAR
    j: JCC;

BEGIN
    NEW(j);
    j.label  := label;
    j.cond   := cond;
    j.short  := FALSE;
    j.short2 := FALSE;
    LISTS.push(CodeList, j)
END jcc;


PROCEDURE jmp (label: INTEGER);
VAR
    j: JMP;

BEGIN
    NEW(j);
    j.label := label;
    j.short := FALSE;
    LISTS.push(CodeList, j)
END jmp;


PROCEDURE call (label: INTEGER);
VAR
    c: CALL;

BEGIN
    NEW(c);
    c.label := label;
    c.short := TRUE;
    LISTS.push(CodeList, c)
END call;


PROCEDURE reloc (reg, rel, value: INTEGER);
VAR
    r: RELOC;

BEGIN
    NEW(r);
    r.reg := reg;
    r.rel := rel;
    r.value := value;
    LISTS.push(CodeList, r)
END reloc;


PROCEDURE range (x, n: INTEGER): BOOLEAN;
    RETURN (0 <= x) & (x < LSL(1, n))
END range;


PROCEDURE srange (x, n: INTEGER): BOOLEAN;
    RETURN (-LSL(1, n - 1) <= x) & (x < LSL(1, n - 1))
END srange;


PROCEDURE gen1 (op, imm, rs, rd: INTEGER);
BEGIN
    ASSERT(op IN {0..2});
    ASSERT(range(imm, 5));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Emit(LSL(op, 11) + LSL(imm, 6) + LSL(rs, 3) + rd)
END gen1;


PROCEDURE gen2 (i, op: BOOLEAN; imm, rs, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 3));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Emit(1800H + LSL(ORD(i), 10) + LSL(ORD(op), 9) + LSL(imm, 6) + LSL(rs, 3) + rd)
END gen2;


PROCEDURE gen3 (op, rd, imm: INTEGER);
BEGIN
    ASSERT(range(op, 2));
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Emit(2000H + LSL(op, 11) + LSL(rd, 8) + imm)
END gen3;


PROCEDURE gen4 (op, rs, rd: INTEGER);
BEGIN
    ASSERT(range(op, 4));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Emit(4000H + LSL(op, 6) + LSL(rs, 3) + rd)
END gen4;


PROCEDURE gen5 (op: INTEGER; h1, h2: BOOLEAN; rs, rd: INTEGER);
BEGIN
    ASSERT(range(op, 2));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Emit(4400H + LSL(op, 8) + LSL(ORD(h1), 7) + LSL(ORD(h2), 6) + LSL(rs, 3) + rd)
END gen5;


PROCEDURE gen6 (rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Emit(4800H + LSL(rd, 8) + imm)
END gen6;


PROCEDURE gen7 (l, b: BOOLEAN; ro, rb, rd: INTEGER);
BEGIN
    ASSERT(range(ro, 3));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Emit(5000H + LSL(ORD(l), 11) + LSL(ORD(b), 10) + LSL(ro, 6) + LSL(rb, 3) + rd)
END gen7;


PROCEDURE gen8 (h, s: BOOLEAN; ro, rb, rd: INTEGER);
BEGIN
    ASSERT(range(ro, 3));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Emit(5200H + LSL(ORD(h), 11) + LSL(ORD(s), 10) + LSL(ro, 6) + LSL(rb, 3) + rd)
END gen8;


PROCEDURE gen9 (b, l: BOOLEAN; imm, rb, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 5));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Emit(6000H + LSL(ORD(b), 12) + LSL(ORD(l), 11) + LSL(imm, 6) + LSL(rb, 3) + rd)
END gen9;


PROCEDURE gen10 (l: BOOLEAN; imm, rb, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 5));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Emit(8000H + LSL(ORD(l), 11) + LSL(imm, 6) + LSL(rb, 3) + rd)
END gen10;


PROCEDURE gen11 (l: BOOLEAN; rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Emit(9000H + LSL(ORD(l), 11) + LSL(rd, 8) + imm)
END gen11;


PROCEDURE gen12 (sp: BOOLEAN; rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Emit(0A000H + LSL(ORD(sp), 11) + LSL(rd, 8) + imm)
END gen12;


PROCEDURE gen13 (imm: INTEGER);
BEGIN
    ASSERT(range(imm, 7));
    Emit(0B000H + imm)
END gen13;


PROCEDURE gen14 (l, r: BOOLEAN; rlist: SET);
BEGIN
    ASSERT(range(ORD(rlist), 8));
    Emit(0B400H + LSL(ORD(l), 11) + LSL(ORD(r), 8) + ORD(rlist))
END gen14;


PROCEDURE gen15 (l: BOOLEAN; rb: INTEGER; rlist: SET);
BEGIN
    ASSERT(range(rb, 3));
    ASSERT(range(ORD(rlist), 8));
    Emit(0C000H + LSL(ORD(l), 11) + LSL(rb, 8) + ORD(rlist))
END gen15;


PROCEDURE LslImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(0, imm5, rs, rd)
END LslImm;


PROCEDURE LsrImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(1, imm5, rs, rd)
END LsrImm;


PROCEDURE AsrImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(2, imm5, rs, rd)
END AsrImm;


PROCEDURE AddImm (rd, rs, imm3: INTEGER);
BEGIN
    gen2(TRUE, FALSE, imm3, rs, rd)
END AddImm;


PROCEDURE SubImm (rd, rs, imm3: INTEGER);
BEGIN
    gen2(TRUE, TRUE, imm3, rs, rd)
END SubImm;


PROCEDURE AddReg (rd, rs, rn: INTEGER);
BEGIN
    gen2(FALSE, FALSE, rn, rs, rd)
END AddReg;


PROCEDURE SubReg (rd, rs, rn: INTEGER);
BEGIN
    gen2(FALSE, TRUE, rn, rs, rd)
END SubReg;


PROCEDURE AddImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(2, rd, imm8)
END AddImm8;


PROCEDURE SubImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(3, rd, imm8)
END SubImm8;


PROCEDURE MovImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(0, rd, imm8)
END MovImm8;


PROCEDURE CmpImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(1, rd, imm8)
END CmpImm8;


PROCEDURE Neg (r: INTEGER);
BEGIN
    gen4(9, r, r)
END Neg;


PROCEDURE Mul (rd, rs: INTEGER);
BEGIN
    gen4(13, rs, rd)
END Mul;


PROCEDURE Str32 (rs, rb: INTEGER);
BEGIN
    gen9(FALSE, FALSE, 0, rb, rs)
END Str32;


PROCEDURE Ldr32 (rd, rb: INTEGER);
BEGIN
    gen9(FALSE, TRUE, 0, rb, rd)
END Ldr32;


PROCEDURE Str16 (rs, rb: INTEGER);
BEGIN
    gen10(FALSE, 0, rb, rs)
END Str16;


PROCEDURE Ldr16 (rd, rb: INTEGER);
BEGIN
    gen10(TRUE, 0, rb, rd)
END Ldr16;


PROCEDURE Str8 (rs, rb: INTEGER);
BEGIN
    gen9(TRUE, FALSE, 0, rb, rs)
END Str8;


PROCEDURE Ldr8 (rd, rb: INTEGER);
BEGIN
    gen9(TRUE, TRUE, 0, rb, rd)
END Ldr8;


PROCEDURE Cmp (r1, r2: INTEGER);
BEGIN
    gen4(10, r2, r1)
END Cmp;


PROCEDURE Tst (r: INTEGER);
BEGIN
    gen4(8, r, r)
END Tst;


PROCEDURE MovImm32 (rd, imm32: INTEGER);
BEGIN
    MovImm8(rd, LSR(imm32, 24) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, LSR(imm32, 16) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, LSR(imm32, 8) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, imm32 MOD 256)
END MovImm32;


PROCEDURE inv0 (cond: INTEGER): INTEGER;
    RETURN ORD(BITS(cond) / {0})
END inv0;


PROCEDURE fixup (DataSize, BssSize: INTEGER);
VAR
    code:    ANYCODE;
    count:   INTEGER;
    shorted: BOOLEAN;
    jump:    JUMP;

    first, second: INTEGER;

    CodeAdr, DataAdr, BssAdr: INTEGER;
    reloc, i: INTEGER;

    RelocCode: RELOCCODE;


    PROCEDURE genjcc (cond, offset: INTEGER): INTEGER;
    BEGIN
        ASSERT(range(cond, 4));
        ASSERT(srange(offset, 8))
        RETURN 0D000H + cond * 256 + offset MOD 256
    END genjcc;


    PROCEDURE genjmp (offset: INTEGER): INTEGER;
    BEGIN
        ASSERT(srange(offset, 11))
        RETURN 0E000H + offset MOD 2048
    END genjmp;


    PROCEDURE genlongjmp (offset: INTEGER; VAR first, second: INTEGER);
    BEGIN
        ASSERT(srange(offset, 22));
        first  := 0F000H + ASR(offset, 11) MOD 2048;
        second := 0F800H + offset MOD 2048
    END genlongjmp;


    PROCEDURE genmovimm32 (r, value: INTEGER; VAR code: RELOCCODE);
    BEGIN
        code[0] := 2000H + r * 256 + UTILS.Byte(value, 3);  (* mov r, #imm8 *)
        code[1] := 0200H + r * 9;                           (* lsl r, r, #8 *)
        code[2] := 3000H + r * 256 + UTILS.Byte(value, 2);  (* add r, #imm8 *)
        code[3] := code[1];                                 (* lsl r, r, #8 *)
        code[4] := 3000H + r * 256 + UTILS.Byte(value, 1);  (* add r, #imm8 *)
        code[5] := code[1];                                 (* lsl r, r, #8 *)
        code[6] := 3000H + r * 256 + UTILS.Byte(value, 0)   (* add r, #imm8 *)
    END genmovimm32;


BEGIN

    REPEAT

        shorted := FALSE;
        count := 0;

        code := CodeList.first(ANYCODE);
        WHILE code # NIL DO
            code.offset := count;

            CASE code OF
            |CODE:   INC(count)
            |LABEL:  BIN.SetLabel(program, code.label, count)
            |JMP:    INC(count, ORD(~code.short) + 1); code.offset := count + ORD(code.short)
            |JCC:    INC(count, ORD(~code.short) + ORD(~code.short2) + 1); code.offset := count + ORD(code.short OR code.short2)
            |CALL:   INC(count, 2); code.offset := count
            |RELOC:  INC(count, 7 + ORD(ODD(code.rel)))
            END;

            code := code.next(ANYCODE)
        END;

        code := CodeList.first(ANYCODE);
        WHILE code # NIL DO

            IF code IS JUMP THEN
                jump := code(JUMP);
                jump.diff := BIN.GetLabel(program, jump.label) - code.offset;
                CASE jump OF
                |JMP:
                    IF ~jump.short & srange(jump.diff, 11) THEN
                        jump.short := TRUE;
                        shorted := TRUE
                    END

                |JCC:
                    IF ~jump.short & srange(jump.diff, 11) THEN
                        jump.short := TRUE;
                        shorted := TRUE
                    END;
                    IF ~jump.short2 & srange(jump.diff, 8) THEN
                        jump.short2 := TRUE;
                        shorted := TRUE
                    END

                |CALL:

                END
            END;

            code := code.next(ANYCODE)
        END

    UNTIL ~shorted;

    CodeAdr := 0;
    DataAdr := CodeAdr + count * 2;
    ASSERT(UTILS.Align(DataAdr, FileAlignment));
    BssAdr := DataAdr + DataSize;
    ASSERT(UTILS.Align(BssAdr, FileAlignment));

    code := CodeList.first(ANYCODE);
    WHILE code # NIL DO

        CASE code OF

        |CODE:  BIN.PutCode16LE(program, code.code)

        |LABEL:

        |JMP:
                IF code.short THEN
                    BIN.PutCode16LE(program, genjmp(code.diff))
                ELSE
                    genlongjmp(code.diff, first, second);
                    BIN.PutCode16LE(program, first);
                    BIN.PutCode16LE(program, second)
                END

        |JCC:
                IF code.short2 THEN
                    BIN.PutCode16LE(program, genjcc(code.cond, code.diff))
                ELSIF code.short THEN
                    BIN.PutCode16LE(program, genjcc(inv0(code.cond), 0));
                    BIN.PutCode16LE(program, genjmp(code.diff))
                ELSE
                    BIN.PutCode16LE(program, genjcc(inv0(code.cond), 1));
                    genlongjmp(code.diff, first, second);
                    BIN.PutCode16LE(program, first);
                    BIN.PutCode16LE(program, second)
                END

        |CALL:
                genlongjmp(code.diff, first, second);
                BIN.PutCode16LE(program, first);
                BIN.PutCode16LE(program, second)

        |RELOC:
                CASE code.rel OF
                |BIN.RCODE: reloc := BIN.GetLabel(program, code.value) * 2 + CodeAdr
                |BIN.RDATA: reloc := code.value + DataAdr;
                |BIN.RBSS:  reloc := code.value + BssAdr
                END;
                genmovimm32(code.reg, reloc, RelocCode);
                FOR i := 0 TO LEN(RelocCode) - 1 DO
                    BIN.PutCode16LE(program, RelocCode[i])
                END
        END;

        code := code.next(ANYCODE)
    END

END fixup;


PROCEDURE push (r: INTEGER);
BEGIN
    gen14(FALSE, FALSE, {r})
END push;


PROCEDURE pop (r: INTEGER);
BEGIN
    gen14(TRUE, FALSE, {r})
END pop;


PROCEDURE mov (r1, r2: INTEGER);
BEGIN
    IF (r1 < 8) & (r2 < 8) THEN
        LslImm(r1, r2, 0)
    ELSE
        gen5(2, r1 >= 8, r2 >= 8, r2 MOD 8, r1 MOD 8)
    END
END mov;


PROCEDURE xchg (r1, r2: INTEGER);
BEGIN
    push(r1); push(r2);
    pop(r1); pop(r2)
END xchg;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE GetAnyReg (): INTEGER;
    RETURN REG.GetAnyReg(R)
END GetAnyReg;


PROCEDURE UnOp (VAR r: INTEGER);
BEGIN
    REG.UnOp(R, r)
END UnOp;


PROCEDURE BinOp (VAR r1, r2: INTEGER);
BEGIN
    REG.BinOp(R, r1, r2)
END BinOp;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    DEC(R.pushed, NumberOfParameters)
END PushAll;


PROCEDURE NewLabel (): INTEGER;
BEGIN
    BIN.NewLabel(program)
    RETURN IL.NewLabel()
END NewLabel;


PROCEDURE cond (op: INTEGER): INTEGER;
VAR
    res: INTEGER;

BEGIN
    CASE op OF
    |IL.opGT, IL.opGTC: res := jg
    |IL.opGE, IL.opGEC: res := jge
    |IL.opLT, IL.opLTC: res := jl
    |IL.opLE, IL.opLEC: res := jle
    |IL.opEQ, IL.opEQC: res := je
    |IL.opNE, IL.opNEC: res := jne
    END

    RETURN res
END cond;


PROCEDURE GetRegA;
BEGIN
    ASSERT(REG.GetReg(R, ACC))
END GetRegA;


PROCEDURE CallRTL (n: INTEGER);
BEGIN
    MovImm8(ACC, n);
    Emit(0DF00H)
END CallRTL;


PROCEDURE MovConst (r, c: INTEGER);
BEGIN
    MovImm32(r, c)
END MovConst;


PROCEDURE CmpConst (r, c: INTEGER);
VAR
    r2: INTEGER;

BEGIN
    r2 := GetAnyReg();
    ASSERT(r2 # r);
    MovConst(r2, c);
    Cmp(r, r2);
    drop
END CmpConst;


PROCEDURE SetCC (cc, r: INTEGER);
VAR
    L1, L2: INTEGER;

BEGIN
    L1 := NewLabel();
    L2 := NewLabel();
    jcc(cc, L1);
    MovImm8(r, 0);
    jmp(L2);
    EmitLabel(L1);
    MovImm8(r, 1);
    EmitLabel(L2);
END SetCC;


PROCEDURE translate (pic, stroffs: INTEGER);
VAR
    cmd: COMMAND;
    opcode, param1, param2: INTEGER;

    r1, r2, r3: INTEGER;

    a, n, cc, label: INTEGER;

BEGIN
    cmd := IL.codes.commands.first(COMMAND);

    WHILE cmd # NIL DO

        param1 := cmd.param1;
        param2 := cmd.param2;

        opcode := cmd.opcode;

        CASE opcode OF

        |IL.opJMP:
            jmp(param1)

        |IL.opLABEL:
            EmitLabel(param1)

        |IL.opPUSHC:
            r1 := GetAnyReg();
            MovConst(r1, param2);
            push(r1);
            drop

        |IL.opERR:
            CallRTL(1)

        |IL.opNOP:

        |IL.opSADR_PARAM:
            r1 := GetAnyReg();
            reloc(r1, BIN.RDATA + pic, stroffs + param2);
            push(r1);
            drop

        |IL.opGADR_SAVEC:
            r1 := GetAnyReg();
            r2 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param1);
            MovConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opGADR:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2)

        |IL.opGLOAD32:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr32(r1, r1)

        |IL.opGLOAD16:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr16(r1, r1)

        |IL.opGLOAD8:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr8(r1, r1)

        |IL.opLOAD32:
            UnOp(r1);
            Ldr32(r1, r1)

        |IL.opLOAD16:
            UnOp(r1);
            Ldr16(r1, r1)

        |IL.opLOAD8:
            UnOp(r1);
            Ldr8(r1, r1)

        |IL.opSBOOL:
            BinOp(r2, r1);
            Tst(r2);
            SetCC(jne, r2);
            Str8(r2, r1);
            drop;
            drop

        |IL.opSBOOLC:
            UnOp(r1);
            r2 := GetAnyReg();
            MovImm8(r2, ORD(param2 # 0));
            Str8(r2, r1);
            drop;
            drop

        |IL.opSAVEC:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opSAVE16C:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2 MOD 65536);
            Str16(r2, r1);
            drop;
            drop

        |IL.opSAVE8C:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2 MOD 256);
            Str8(r2, r1);
            drop;
            drop

        |IL.opSAVE, IL.opSAVE32:
            BinOp(r2, r1);
            Str32(r2, r1);
            drop;
            drop

        |IL.opSAVE16:
            BinOp(r2, r1);
            Str16(r2, r1);
            drop;
            drop

        |IL.opSAVE8:
            BinOp(r2, r1);
            Str8(r2, r1);
            drop;
            drop

        |IL.opACC:
            IF (R.top # 0) OR (R.stk[0] # ACC) THEN
                PushAll(0);
                GetRegA;
                pop(ACC);
                DEC(R.pushed)
            END

        |IL.opDROP:
            UnOp(r1);
            drop

        |IL.opJNZ:
            UnOp(r1);
            Tst(r1);
            jcc(jne, param1)

        |IL.opJZ:
            UnOp(r1);
            Tst(r1);
            jcc(je, param1)

        |IL.opJE:
            UnOp(r1);
            Tst(r1);
            jcc(jne, param1);
            drop

        |IL.opJNE:
            UnOp(r1);
            Tst(r1);
            jcc(je, param1);
            drop

        |IL.opSWITCH:
            UnOp(r1);
            IF param2 = 0 THEN
                r2 := ACC
            ELSE
                r2 := R1
            END;
            IF r1 # r2 THEN
                ASSERT(REG.GetReg(R, r2));
                ASSERT(REG.Exchange(R, r1, r2));
                drop
            END;
            drop

        |IL.opENDSW:

        |IL.opCASEL:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jl, param2);
            drop

        |IL.opCASER:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jg, param2);
            drop

        |IL.opCASELR:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jl, param2);
            jcc(jg, cmd.param3);
            drop

        |IL.opCODE:
            Emit(param2)

        |IL.opEQ..IL.opGE,
         IL.opEQC..IL.opGEC:
            IF (IL.opEQ <= opcode) & (opcode <= IL.opGE) THEN
                BinOp(r1, r2);
                Cmp(r1, r2);
                drop
            ELSE
                UnOp(r1);
                IF param2 = 0 THEN
                    Tst(r1)
                ELSE
                    CmpConst(r1, param2)
                END
            END;

            drop;
            cc := cond(opcode);

            IF cmd.next(COMMAND).opcode = IL.opJE THEN
                label := cmd.next(COMMAND).param1;
                jcc(cc, label);
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = IL.opJNE THEN
                label := cmd.next(COMMAND).param1;
                jcc(inv0(cc), label);
                cmd := cmd.next(COMMAND)

            ELSE
                r1 := GetAnyReg();
                SetCC(cc, r1)
            END

        |IL.opINCC:
            UnOp(r1);
            r2 := GetAnyReg();
            Ldr32(r2, r1);
            IF ABS(param2) <= 255 THEN
                IF param2 >= 0 THEN
                    AddImm8(r2, param2)
                ELSE
                    SubImm8(r2, -param2)
                END
            ELSE
                r3 := GetAnyReg();
                MovConst(r3, param2);
                AddReg(r2, r2, r3);
                drop
            END;
            Str32(r2, r1);
            drop;
            drop

        |IL.opUMINUS:
            UnOp(r1);
            Neg(r1)

        |IL.opADD:
            BinOp(r1, r2);
            AddReg(r1, r1, r2);
            drop

        |IL.opADDL, IL.opADDR:
            IF param2 # 0 THEN
                UnOp(r1);
                IF ABS(param2) <= 255 THEN
                    IF param2 > 0 THEN
                        AddImm8(r1, param2)
                    ELSE
                        SubImm8(r1, -param2)
                    END
                ELSE
                    r2 := GetAnyReg();
                    MovConst(r2, param2);
                    AddReg(r1, r1, r2);
                    drop
                END
            END

        |IL.opSUB:
            BinOp(r1, r2);
            SubReg(r1, r1, r2);
            drop

        |IL.opSUBL, IL.opSUBR:
            IF param2 # 0 THEN
                UnOp(r1);
                IF ABS(param2) <= 255 THEN
                    IF param2 > 0 THEN
                        SubImm8(r1, param2)
                    ELSE
                        AddImm8(r1, -param2)
                    END;
                    IF opcode = IL.opSUBL THEN
                        Neg(r1)
                    END
                ELSE
                    r2 := GetAnyReg();
                    MovConst(r2, param2);
                    IF opcode = IL.opSUBL THEN
                        SubReg(r1, r2, r1)
                    ELSE
                        SubReg(r1, r1, r2)
                    END;
                    drop
                END
            END

        |IL.opMUL:
            BinOp(r1, r2);
            Mul(r1, r2);
            drop

        |IL.opMULC:
            UnOp(r1);

            a := param2;
            IF a > 1 THEN
                n := UTILS.Log2(a)
            ELSIF a < -1 THEN
                n := UTILS.Log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                Neg(r1)
            ELSIF a = 0 THEN
                MovImm8(r1, 0)
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        Neg(r1)
                    END;
                    LslImm(r1, r1, n)
                ELSE
                    r2 := GetAnyReg();
                    MovConst(r2, a);
                    Mul(r1, r2);
                    drop
                END
            END

        |IL.opCHKIDX:
            UnOp(r1);
            CmpConst(r1, param2);
            jcc(jb, param1)

        |IL.opLOOP, IL.opENDLOOP:

        ELSE
            C.IntLn(opcode);
            ASSERT(FALSE)
        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)

END translate;


PROCEDURE CodeGen* (outname: ARRAY OF CHAR; target: INTEGER; options: PROG.OPTIONS);
VAR
    opt: PROG.OPTIONS;

    dcount, i: INTEGER;

    File: WR.FILE;

BEGIN
    tcount := CHL.Length(IL.codes.types);

    opt := options;
    CodeList := LISTS.create(NIL);

    program := BIN.create(IL.codes.lcount);

    opt.pic := FALSE;

    REG.Init(R, push, pop, mov, xchg, NIL, NIL, {R0, R1, R2, R3}, {});

    translate(ORD(opt.pic), tcount * 4);

    dcount := CHL.Length(IL.codes.data);

    FOR i := 0 TO tcount - 1 DO
        BIN.PutData32LE(program, CHL.GetInt(IL.codes.types, i))
    END;

    FOR i := 0 TO dcount - 1 DO
        BIN.PutData(program, CHL.GetByte(IL.codes.data, i))
    END;

    IL.set_bss(MAX(IL.codes.bss, MAX(IL.codes.dmin - CHL.Length(IL.codes.data), 4)));

    fixup(CHL.Length(program.data), IL.codes.bss);

    File := WR.Create(outname);

    CHL.WriteToFile(File, program.code);
    WR.Padding(File, FileAlignment);
    CHL.WriteToFile(File, program.data);

    WR.Close(File)
END CodeGen;


END THUMB.