(*
    BSD 2-Clause License

    Copyright (c) 2019, Anton Krotov
    All rights reserved.
*)

MODULE THUMB;

IMPORT PROG, LISTS, CHL := CHUNKLISTS, BIN, REG, IL, C := CONSOLE, UTILS, WR := WRITER;


CONST

    R0 = 0; R1 = 1; R2 = 2; R3 = 3;

    SP = 13; LR = 14; PC = 15;

    ACC = R0;

    je = 0; jne = 1; jnb = 2; jb = 3; jge = 10; jl = 11; jg = 12; jle = 13;

    FileAlignment = 1000H;


TYPE

    COMMAND = IL.COMMAND;

    ANYCODE = POINTER TO RECORD (LISTS.ITEM)

        offset: INTEGER

    END;

    CODE = POINTER TO RECORD (ANYCODE)

        code: INTEGER

    END;

    LABEL = POINTER TO RECORD (ANYCODE)

        label: INTEGER

    END;

    JUMP = POINTER TO RECORD (ANYCODE)

        label, diff: INTEGER;
        short: BOOLEAN

    END;

    JMP = POINTER TO RECORD (JUMP)

    END;

    JCC = POINTER TO RECORD (JUMP)

        cond:   INTEGER;
        short2: BOOLEAN

    END;

    CALL = POINTER TO RECORD (JUMP)

    END;

    RELOC = POINTER TO RECORD (ANYCODE)

        reg, rel, value: INTEGER

    END;

    RELOCCODE = ARRAY 7 OF INTEGER;


VAR

    R: REG.REGS;

    tcount: INTEGER;

    CodeList: LISTS.LIST;

    program: BIN.PROGRAM;

    StkCount: INTEGER;


PROCEDURE Code (code: INTEGER);
VAR
    c: CODE;

BEGIN
    NEW(c);
    c.code := code;
    LISTS.push(CodeList, c)
END Code;


PROCEDURE Label (label: INTEGER);
VAR
    L: LABEL;

BEGIN
    NEW(L);
    L.label := label;
    LISTS.push(CodeList, L)
END Label;


PROCEDURE jcc (cond, label: INTEGER);
VAR
    j: JCC;

BEGIN
    NEW(j);
    j.label  := label;
    j.cond   := cond;
    j.short  := FALSE;
    j.short2 := FALSE;
    LISTS.push(CodeList, j)
END jcc;


PROCEDURE jmp (label: INTEGER);
VAR
    j: JMP;

BEGIN
    NEW(j);
    j.label := label;
    j.short := FALSE;
    LISTS.push(CodeList, j)
END jmp;


PROCEDURE call (label: INTEGER);
VAR
    c: CALL;

BEGIN
    NEW(c);
    c.label := label;
    c.short := TRUE;
    LISTS.push(CodeList, c)
END call;


PROCEDURE reloc (reg, rel, value: INTEGER);
VAR
    r: RELOC;

BEGIN
    NEW(r);
    r.reg := reg;
    r.rel := rel;
    r.value := value;
    LISTS.push(CodeList, r)
END reloc;


PROCEDURE range (x, n: INTEGER): BOOLEAN;
    RETURN (0 <= x) & (x < LSL(1, n))
END range;


PROCEDURE srange (x, n: INTEGER): BOOLEAN;
    RETURN (-LSL(1, n - 1) <= x) & (x < LSL(1, n - 1))
END srange;


PROCEDURE gen1 (op, imm, rs, rd: INTEGER);
BEGIN
    ASSERT(op IN {0..2});
    ASSERT(range(imm, 5));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Code(LSL(op, 11) + LSL(imm, 6) + LSL(rs, 3) + rd)
END gen1;


PROCEDURE gen2 (i, op: BOOLEAN; imm, rs, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 3));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Code(1800H + LSL(ORD(i), 10) + LSL(ORD(op), 9) + LSL(imm, 6) + LSL(rs, 3) + rd)
END gen2;


PROCEDURE gen3 (op, rd, imm: INTEGER);
BEGIN
    ASSERT(range(op, 2));
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Code(2000H + LSL(op, 11) + LSL(rd, 8) + imm)
END gen3;


PROCEDURE gen4 (op, rs, rd: INTEGER);
BEGIN
    ASSERT(range(op, 4));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Code(4000H + LSL(op, 6) + LSL(rs, 3) + rd)
END gen4;


PROCEDURE gen5 (op: INTEGER; h1, h2: BOOLEAN; rs, rd: INTEGER);
BEGIN
    ASSERT(range(op, 2));
    ASSERT(range(rs, 3));
    ASSERT(range(rd, 3));
    Code(4400H + LSL(op, 8) + LSL(ORD(h1), 7) + LSL(ORD(h2), 6) + LSL(rs, 3) + rd)
END gen5;


PROCEDURE gen6 (rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Code(4800H + LSL(rd, 8) + imm)
END gen6;


PROCEDURE gen7 (l, b: BOOLEAN; ro, rb, rd: INTEGER);
BEGIN
    ASSERT(range(ro, 3));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Code(5000H + LSL(ORD(l), 11) + LSL(ORD(b), 10) + LSL(ro, 6) + LSL(rb, 3) + rd)
END gen7;


PROCEDURE gen8 (h, s: BOOLEAN; ro, rb, rd: INTEGER);
BEGIN
    ASSERT(range(ro, 3));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Code(5200H + LSL(ORD(h), 11) + LSL(ORD(s), 10) + LSL(ro, 6) + LSL(rb, 3) + rd)
END gen8;


PROCEDURE gen9 (b, l: BOOLEAN; imm, rb, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 5));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Code(6000H + LSL(ORD(b), 12) + LSL(ORD(l), 11) + LSL(imm, 6) + LSL(rb, 3) + rd)
END gen9;


PROCEDURE gen10 (l: BOOLEAN; imm, rb, rd: INTEGER);
BEGIN
    ASSERT(range(imm, 5));
    ASSERT(range(rb, 3));
    ASSERT(range(rd, 3));
    Code(8000H + LSL(ORD(l), 11) + LSL(imm, 6) + LSL(rb, 3) + rd)
END gen10;


PROCEDURE gen11 (l: BOOLEAN; rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Code(9000H + LSL(ORD(l), 11) + LSL(rd, 8) + imm)
END gen11;


PROCEDURE gen12 (sp: BOOLEAN; rd, imm: INTEGER);
BEGIN
    ASSERT(range(rd, 3));
    ASSERT(range(imm, 8));
    Code(0A000H + LSL(ORD(sp), 11) + LSL(rd, 8) + imm)
END gen12;


PROCEDURE gen13 (imm: INTEGER);
BEGIN
    ASSERT(range(imm, 7));
    Code(0B000H + imm)
END gen13;


PROCEDURE gen14 (l, r: BOOLEAN; rlist: SET);
VAR
    i, n: INTEGER;

BEGIN
    ASSERT(range(ORD(rlist), 8));

    n := ORD(r);
    FOR i := 0 TO 7 DO
        IF i IN rlist THEN
            INC(n)
        END
    END;

    IF l THEN
        n := -n
    END;

    INC(StkCount, n);

    Code(0B400H + LSL(ORD(l), 11) + LSL(ORD(r), 8) + ORD(rlist))
END gen14;


PROCEDURE gen15 (l: BOOLEAN; rb: INTEGER; rlist: SET);
BEGIN
    ASSERT(range(rb, 3));
    ASSERT(range(ORD(rlist), 8));
    Code(0C000H + LSL(ORD(l), 11) + LSL(rb, 8) + ORD(rlist))
END gen15;


PROCEDURE LslImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(0, imm5, rs, rd)
END LslImm;


PROCEDURE LsrImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(1, imm5, rs, rd)
END LsrImm;


PROCEDURE AsrImm (rd, rs, imm5: INTEGER);
BEGIN
    gen1(2, imm5, rs, rd)
END AsrImm;


PROCEDURE AddImm (rd, rs, imm3: INTEGER);
BEGIN
    gen2(TRUE, FALSE, imm3, rs, rd)
END AddImm;


PROCEDURE SubImm (rd, rs, imm3: INTEGER);
BEGIN
    gen2(TRUE, TRUE, imm3, rs, rd)
END SubImm;


PROCEDURE AddReg (rd, rs, rn: INTEGER);
BEGIN
    gen2(FALSE, FALSE, rn, rs, rd)
END AddReg;


PROCEDURE SubReg (rd, rs, rn: INTEGER);
BEGIN
    gen2(FALSE, TRUE, rn, rs, rd)
END SubReg;


PROCEDURE AddImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(2, rd, imm8)
END AddImm8;


PROCEDURE SubImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(3, rd, imm8)
END SubImm8;


PROCEDURE MovImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(0, rd, imm8)
END MovImm8;


PROCEDURE CmpImm8 (rd, imm8: INTEGER);
BEGIN
    gen3(1, rd, imm8)
END CmpImm8;


PROCEDURE Neg (r: INTEGER);
BEGIN
    gen4(9, r, r)
END Neg;


PROCEDURE Mul (rd, rs: INTEGER);
BEGIN
    gen4(13, rs, rd)
END Mul;


PROCEDURE Str32 (rs, rb: INTEGER);
BEGIN
    gen9(FALSE, FALSE, 0, rb, rs)
END Str32;


PROCEDURE Ldr32 (rd, rb: INTEGER);
BEGIN
    gen9(FALSE, TRUE, 0, rb, rd)
END Ldr32;


PROCEDURE Str16 (rs, rb: INTEGER);
BEGIN
    gen10(FALSE, 0, rb, rs)
END Str16;


PROCEDURE Ldr16 (rd, rb: INTEGER);
BEGIN
    gen10(TRUE, 0, rb, rd)
END Ldr16;


PROCEDURE Str8 (rs, rb: INTEGER);
BEGIN
    gen9(TRUE, FALSE, 0, rb, rs)
END Str8;


PROCEDURE Ldr8 (rd, rb: INTEGER);
BEGIN
    gen9(TRUE, TRUE, 0, rb, rd)
END Ldr8;


PROCEDURE Cmp (r1, r2: INTEGER);
BEGIN
    gen4(10, r2, r1)
END Cmp;


PROCEDURE Tst (r: INTEGER);
BEGIN
    gen4(8, r, r)
END Tst;


PROCEDURE MovImm32 (rd, imm32: INTEGER);
BEGIN
    MovImm8(rd, LSR(imm32, 24) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, LSR(imm32, 16) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, LSR(imm32, 8) MOD 256);
    LslImm(rd, rd, 8);
    AddImm8(rd, imm32 MOD 256)
END MovImm32;


PROCEDURE inv0 (cond: INTEGER): INTEGER;
    RETURN ORD(BITS(cond) / {0})
END inv0;


PROCEDURE fixup (DataSize, BssSize: INTEGER);
VAR
    code:    ANYCODE;
    count:   INTEGER;
    shorted: BOOLEAN;
    jump:    JUMP;

    first, second: INTEGER;

    CodeAdr, DataAdr, BssAdr: INTEGER;
    reloc, i: INTEGER;

    RelocCode: RELOCCODE;


    PROCEDURE genjcc (cond, offset: INTEGER): INTEGER;
    BEGIN
        ASSERT(range(cond, 4));
        ASSERT(srange(offset, 8))
        RETURN 0D000H + cond * 256 + offset MOD 256
    END genjcc;


    PROCEDURE genjmp (offset: INTEGER): INTEGER;
    BEGIN
        ASSERT(srange(offset, 11))
        RETURN 0E000H + offset MOD 2048
    END genjmp;


    PROCEDURE genlongjmp (offset: INTEGER; VAR first, second: INTEGER);
    BEGIN
        ASSERT(srange(offset, 22));
        first  := 0F000H + ASR(offset, 11) MOD 2048;
        second := 0F800H + offset MOD 2048
    END genlongjmp;


    PROCEDURE genmovimm32 (r, value: INTEGER; VAR code: RELOCCODE);
    BEGIN
        code[0] := 2000H + r * 256 + UTILS.Byte(value, 3);  (* mov r, #imm8 *)
        code[1] := 0200H + r * 9;                           (* lsl r, r, #8 *)
        code[2] := 3000H + r * 256 + UTILS.Byte(value, 2);  (* add r, #imm8 *)
        code[3] := code[1];                                 (* lsl r, r, #8 *)
        code[4] := 3000H + r * 256 + UTILS.Byte(value, 1);  (* add r, #imm8 *)
        code[5] := code[1];                                 (* lsl r, r, #8 *)
        code[6] := 3000H + r * 256 + UTILS.Byte(value, 0)   (* add r, #imm8 *)
    END genmovimm32;


    PROCEDURE PutCode (code: INTEGER);
    BEGIN
        BIN.PutCode16LE(program, code)
    END PutCode;


BEGIN

    REPEAT

        shorted := FALSE;
        count := 0;

        code := CodeList.first(ANYCODE);
        WHILE code # NIL DO
            code.offset := count;

            CASE code OF
            |CODE:   INC(count)
            |LABEL:  BIN.SetLabel(program, code.label, count)
            |JMP:    INC(count, ORD(~code.short) + 1); code.offset := count + ORD(code.short)
            |JCC:    INC(count, ORD(~code.short) + ORD(~code.short2) + 1); code.offset := count + ORD(code.short OR code.short2)
            |CALL:   INC(count, 2); code.offset := count
            |RELOC:  INC(count, 7 + ORD(ODD(code.rel)))
            END;

            code := code.next(ANYCODE)
        END;

        code := CodeList.first(ANYCODE);
        WHILE code # NIL DO

            IF code IS JUMP THEN
                jump := code(JUMP);
                jump.diff := BIN.GetLabel(program, jump.label) - code.offset;
                CASE jump OF
                |JMP:
                    IF ~jump.short & srange(jump.diff, 11) THEN
                        jump.short := TRUE;
                        shorted := TRUE
                    END

                |JCC:
                    IF ~jump.short & srange(jump.diff, 11) THEN
                        jump.short := TRUE;
                        shorted := TRUE
                    END;
                    IF ~jump.short2 & srange(jump.diff, 8) THEN
                        jump.short2 := TRUE;
                        shorted := TRUE
                    END

                |CALL:

                END
            END;

            code := code.next(ANYCODE)
        END

    UNTIL ~shorted;

    CodeAdr := 0;
    DataAdr := CodeAdr + count * 2;
    ASSERT(UTILS.Align(DataAdr, FileAlignment));
    BssAdr := DataAdr + DataSize;
    ASSERT(UTILS.Align(BssAdr, FileAlignment));

    code := CodeList.first(ANYCODE);
    WHILE code # NIL DO

        CASE code OF

        |CODE:  BIN.PutCode16LE(program, code.code)

        |LABEL:

        |JMP:
                IF code.short THEN
                    PutCode(genjmp(code.diff))
                ELSE
                    genlongjmp(code.diff, first, second);
                    PutCode(first);
                    PutCode(second)
                END

        |JCC:
                IF code.short2 THEN
                    PutCode(genjcc(code.cond, code.diff))
                ELSIF code.short THEN
                    PutCode(genjcc(inv0(code.cond), 0));
                    PutCode(genjmp(code.diff))
                ELSE
                    PutCode(genjcc(inv0(code.cond), 1));
                    genlongjmp(code.diff, first, second);
                    PutCode(first);
                    PutCode(second)
                END

        |CALL:
                genlongjmp(code.diff, first, second);
                PutCode(first);
                PutCode(second)

        |RELOC:
                CASE code.rel OF
                |BIN.RCODE: reloc := BIN.GetLabel(program, code.value) * 2 + CodeAdr
                |BIN.RDATA: reloc := code.value + DataAdr;
                |BIN.RBSS:  reloc := code.value + BssAdr
                END;
                genmovimm32(code.reg, reloc, RelocCode);
                FOR i := 0 TO LEN(RelocCode) - 1 DO
                    PutCode(RelocCode[i])
                END
        END;

        code := code.next(ANYCODE)
    END

END fixup;


PROCEDURE push (r: INTEGER);
BEGIN
    gen14(FALSE, FALSE, {r})
END push;


PROCEDURE pop (r: INTEGER);
BEGIN
    gen14(TRUE, FALSE, {r})
END pop;


PROCEDURE mov (r1, r2: INTEGER);
BEGIN
    IF (r1 < 8) & (r2 < 8) THEN
        LslImm(r1, r2, 0)
    ELSE
        gen5(2, r1 >= 8, r2 >= 8, r2 MOD 8, r1 MOD 8)
    END
END mov;


PROCEDURE xchg (r1, r2: INTEGER);
BEGIN
    push(r1); push(r2);
    pop(r1); pop(r2)
END xchg;


PROCEDURE drop;
BEGIN
    REG.Drop(R)
END drop;


PROCEDURE GetAnyReg (): INTEGER;
    RETURN REG.GetAnyReg(R)
END GetAnyReg;


PROCEDURE UnOp (VAR r: INTEGER);
BEGIN
    REG.UnOp(R, r)
END UnOp;


PROCEDURE BinOp (VAR r1, r2: INTEGER);
BEGIN
    REG.BinOp(R, r1, r2)
END BinOp;


PROCEDURE PushAll (NumberOfParameters: INTEGER);
BEGIN
    REG.PushAll(R);
    DEC(R.pushed, NumberOfParameters)
END PushAll;


PROCEDURE NewLabel (): INTEGER;
BEGIN
    BIN.NewLabel(program)
    RETURN IL.NewLabel()
END NewLabel;


PROCEDURE cond (op: INTEGER): INTEGER;
VAR
    res: INTEGER;

BEGIN
    CASE op OF
    |IL.opGT, IL.opGTC: res := jg
    |IL.opGE, IL.opGEC: res := jge
    |IL.opLT, IL.opLTC: res := jl
    |IL.opLE, IL.opLEC: res := jle
    |IL.opEQ, IL.opEQC: res := je
    |IL.opNE, IL.opNEC: res := jne
    END

    RETURN res
END cond;


PROCEDURE GetRegA;
BEGIN
    ASSERT(REG.GetReg(R, ACC))
END GetRegA;


PROCEDURE CallRTL (n: INTEGER);
BEGIN
    MovImm8(ACC, n);
    Code(0DF00H)
END CallRTL;


PROCEDURE MovConst (r, c: INTEGER);
BEGIN
    IF range(c, 8) THEN
        MovImm8(r, c)
    ELSE
        MovImm32(r, c)
    END
END MovConst;


PROCEDURE CmpConst (r, c: INTEGER);
VAR
    r2: INTEGER;

BEGIN
    IF c = 0 THEN
        Tst(r)
    ELSE
        r2 := GetAnyReg();
        ASSERT(r2 # r);
        MovConst(r2, c);
        Cmp(r, r2);
        drop
    END
END CmpConst;


PROCEDURE LocalOffset (offset: INTEGER): INTEGER;
    RETURN (offset + StkCount - ORD(offset > 0)) * 4
END LocalOffset;


PROCEDURE SetCC (cc, r: INTEGER);
VAR
    L1, L2: INTEGER;

BEGIN
    L1 := NewLabel();
    L2 := NewLabel();
    jcc(cc, L1);
    MovConst(r, 0);
    jmp(L2);
    Label(L1);
    MovConst(r, 1);
    Label(L2);
END SetCC;


PROCEDURE PushConst (n: INTEGER);
VAR
    r: INTEGER;

BEGIN
    r := GetAnyReg();
    MovConst(r, n);
    push(r);
    drop
END PushConst;


PROCEDURE AddConst (r, n: INTEGER);
VAR
    r2: INTEGER;

BEGIN
    IF n # 0 THEN
        IF ABS(n) <= 255 THEN
            IF n >= 0 THEN
                AddImm8(r, n)
            ELSE
                SubImm8(r, -n)
            END
        ELSE
            r2 := GetAnyReg();
            ASSERT(r2 # r);
            MovConst(r2, n);
            AddReg(r, r, r2);
            drop
        END
    END
END AddConst;


PROCEDURE AddHH (r1, r2: INTEGER);
BEGIN
    ASSERT((r1 >= 8) OR (r2 >= 8));
    gen5(0, r1 >= 8, r2 >= 8, r2 MOD 8, r1 MOD 8)
END AddHH;


PROCEDURE AddSP (n: INTEGER);
BEGIN
    IF n > 0 THEN
        ASSERT(R1 IN R.regs);
        MovConst(R1, n * 4);
        AddHH(SP, R1);
        DEC(StkCount, n)
    END
END AddSP;


PROCEDURE Shift (op, r1, r2: INTEGER);
VAR
    L: INTEGER;

BEGIN
    LslImm(r2, r2, 27);
    LsrImm(r2, r2, 27);
    Tst(r2);
    L := NewLabel();
    jcc(je, L);
    CASE op OF
    |IL.opLSL, IL.opLSL1: gen4(2, r2, r1)
    |IL.opLSR, IL.opLSR1: gen4(3, r2, r1)
    |IL.opASR, IL.opASR1: gen4(4, r2, r1)
    |IL.opROR, IL.opROR1: gen4(7, r2, r1)
    END;
    Label(L)
END Shift;


PROCEDURE LocAdr (offs: INTEGER);
VAR
    r1: INTEGER;

BEGIN
    r1 := GetAnyReg();
    MovConst(r1, LocalOffset(offs));
    AddHH(r1, SP)
END LocAdr;


PROCEDURE translate (pic, stroffs: INTEGER);
VAR
    cmd: COMMAND;
    opcode, param1, param2: INTEGER;

    r1, r2: INTEGER;

    a, n, cc, L: INTEGER;

BEGIN
    cmd := IL.codes.commands.first(COMMAND);

    WHILE cmd # NIL DO

        param1 := cmd.param1;
        param2 := cmd.param2;
        opcode := cmd.opcode;

        CASE opcode OF

        |IL.opJMP:
            jmp(param1)

        |IL.opLABEL:
            Label(param1)

        |IL.opCALL:
            call(param1)

        |IL.opCALLP:
            UnOp(r1);
            mov(LR, PC);
            mov(PC, r1);
            drop;
            ASSERT(R.top = -1)

        |IL.opENTER:
            ASSERT(R.top = -1);

            Label(param1);

            gen14(FALSE, TRUE, {}); (* push LR *)

            n := param2;
            IF n >= 5 THEN
                MovConst(ACC, 0);
                MovConst(R1, n);
                L := NewLabel();
                Label(L);
                push(ACC);
                SubImm8(R1, 1);
                Tst(R1);
                jcc(jne, L)
            ELSIF n > 0 THEN
                MovConst(ACC, 0);
                WHILE n > 0 DO
                    push(ACC);
                    DEC(n)
                END
            END;
            StkCount := param2

        |IL.opLEAVE, IL.opLEAVER, IL.opLEAVEF:
            IF opcode # IL.opLEAVE THEN
                UnOp(r1);
                IF r1 # ACC THEN
                    GetRegA;
                    ASSERT(REG.Exchange(R, r1, ACC));
                    drop
                END;
                drop
            END;

            ASSERT(R.top = -1);

            AddSP(StkCount);
            pop(R1);
            mov(PC, R1)

        |IL.opLEAVEC:
            mov(PC, LR)

        |IL.opPRECALL:
            PushAll(0)

        |IL.opPARAM:
            n := param2;
            IF n = 1 THEN
                UnOp(r1);
                push(r1);
                drop
            ELSE
                ASSERT(R.top + 1 <= n);
                PushAll(n)
            END

        |IL.opCLEANUP:
            AddSP(param2)

        |IL.opRES:
            ASSERT(R.top = -1);
            GetRegA

        |IL.opPUSHC, IL.opCONST_PARAM:
            PushConst(param2)

        |IL.opONERR:
            PushConst(param2);
            DEC(StkCount);
            jmp(param1)

        |IL.opERR:
            CallRTL(1)

        |IL.opNOP:

        |IL.opSADR_PARAM:
            r1 := GetAnyReg();
            reloc(r1, BIN.RDATA + pic, stroffs + param2);
            push(r1);
            drop

        |IL.opGADR_SAVEC:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param1);
            r2 := GetAnyReg();
            MovConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opGADR:
            reloc(GetAnyReg(), BIN.RBSS + pic, param2)

        |IL.opLADR:
            LocAdr(param2)

        |IL.opGLOAD32:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr32(r1, r1)

        |IL.opGLOAD16:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr16(r1, r1)

        |IL.opGLOAD8:
            r1 := GetAnyReg();
            reloc(r1, BIN.RBSS + pic, param2);
            Ldr8(r1, r1)

        |IL.opLLOAD32, IL.opVADR:
            LocAdr(param2);
            UnOp(r1);
            Ldr32(r1, r1)

        |IL.opLLOAD16:
            LocAdr(param2);
            UnOp(r1);
            Ldr16(r1, r1)

        |IL.opLLOAD8:
            LocAdr(param2);
            UnOp(r1);
            Ldr8(r1, r1)

        |IL.opLLOAD32_PARAM:
            LocAdr(param2);
            UnOp(r1);
            Ldr32(r1, r1);
            push(r1);
            drop

        |IL.opLOAD32:
            UnOp(r1);
            Ldr32(r1, r1)

        |IL.opLOAD16:
            UnOp(r1);
            Ldr16(r1, r1)

        |IL.opLOAD8:
            UnOp(r1);
            Ldr8(r1, r1)

        |IL.opSBOOL:
            BinOp(r2, r1);
            Tst(r2);
            SetCC(jne, r2);
            Str8(r2, r1);
            drop;
            drop

        |IL.opSBOOLC:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, ORD(param2 # 0));
            Str8(r2, r1);
            drop;
            drop

        |IL.opSAVEC:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opSAVE16C:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2 MOD 65536);
            Str16(r2, r1);
            drop;
            drop

        |IL.opSAVE8C:
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2 MOD 256);
            Str8(r2, r1);
            drop;
            drop

        |IL.opSAVE, IL.opSAVE32:
            BinOp(r2, r1);
            Str32(r2, r1);
            drop;
            drop

        |IL.opSAVE16:
            BinOp(r2, r1);
            Str16(r2, r1);
            drop;
            drop

        |IL.opSAVE8:
            BinOp(r2, r1);
            Str8(r2, r1);
            drop;
            drop

        |IL.opSAVEP:
            UnOp(r1);
            r2 := GetAnyReg();
            reloc(r2, BIN.RCODE + pic, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opPUSHP:
            reloc(GetAnyReg(), BIN.RCODE + pic, param2)

        |IL.opEQB, IL.opNEB:
            BinOp(r1, r2);
            drop;

            Tst(r1);
            L := NewLabel();
            jcc(je, L);
            MovConst(r1, 1);
            Label(L);

            Tst(r2);
            L := NewLabel();
            jcc(je, L);
            MovConst(r2, 1);
            Label(L);

            Cmp(r1, r2);
            IF opcode = IL.opEQB THEN
                SetCC(je, r1)
            ELSE
                SetCC(jne, r1)
            END

        |IL.opACC:
            IF (R.top # 0) OR (R.stk[0] # ACC) THEN
                PushAll(0);
                GetRegA;
                pop(ACC);
                DEC(R.pushed)
            END

        |IL.opDROP:
            UnOp(r1);
            drop

        |IL.opJNZ:
            UnOp(r1);
            Tst(r1);
            jcc(jne, param1)

        |IL.opJZ:
            UnOp(r1);
            Tst(r1);
            jcc(je, param1)

        |IL.opJE:
            UnOp(r1);
            Tst(r1);
            jcc(jne, param1);
            drop

        |IL.opJNE:
            UnOp(r1);
            Tst(r1);
            jcc(je, param1);
            drop

        |IL.opSWITCH:
            UnOp(r1);
            IF param2 = 0 THEN
                r2 := ACC
            ELSE
                r2 := R1
            END;
            IF r1 # r2 THEN
                ASSERT(REG.GetReg(R, r2));
                ASSERT(REG.Exchange(R, r1, r2));
                drop
            END;
            drop

        |IL.opENDSW:

        |IL.opCASEL:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jl, param2);
            drop

        |IL.opCASER:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jg, param2);
            drop

        |IL.opCASELR:
            GetRegA;
            CmpConst(ACC, param1);
            jcc(jl, param2);
            jcc(jg, cmd.param3);
            drop

        |IL.opCODE:
            Code(param2)

        |IL.opEQ..IL.opGE,
         IL.opEQC..IL.opGEC:
            IF (IL.opEQ <= opcode) & (opcode <= IL.opGE) THEN
                BinOp(r1, r2);
                Cmp(r1, r2);
                drop
            ELSE
                UnOp(r1);
                CmpConst(r1, param2)
            END;

            drop;
            cc := cond(opcode);

            IF cmd.next(COMMAND).opcode = IL.opJE THEN
                jcc(cc, cmd.next(COMMAND).param1);
                cmd := cmd.next(COMMAND)

            ELSIF cmd.next(COMMAND).opcode = IL.opJNE THEN
                jcc(inv0(cc), cmd.next(COMMAND).param1);
                cmd := cmd.next(COMMAND)

            ELSE
                r1 := GetAnyReg();
                SetCC(cc, r1)
            END

        |IL.opINCC:
            UnOp(r1);
            r2 := GetAnyReg();
            Ldr32(r2, r1);
            AddConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opUMINUS:
            UnOp(r1);
            Neg(r1)

        |IL.opADD:
            BinOp(r1, r2);
            AddReg(r1, r1, r2);
            drop

        |IL.opADDL, IL.opADDR:
            UnOp(r1);
            AddConst(r1, param2)

        |IL.opSUB:
            BinOp(r1, r2);
            SubReg(r1, r1, r2);
            drop

        |IL.opSUBL, IL.opSUBR:
            IF param2 # 0 THEN
                UnOp(r1);
                IF ABS(param2) <= 255 THEN
                    IF param2 > 0 THEN
                        SubImm8(r1, param2)
                    ELSE
                        AddImm8(r1, -param2)
                    END;
                    IF opcode = IL.opSUBL THEN
                        Neg(r1)
                    END
                ELSE
                    r2 := GetAnyReg();
                    MovConst(r2, param2);
                    IF opcode = IL.opSUBL THEN
                        SubReg(r1, r2, r1)
                    ELSE
                        SubReg(r1, r1, r2)
                    END;
                    drop
                END
            END

        |IL.opMUL:
            BinOp(r1, r2);
            Mul(r1, r2);
            drop

        |IL.opMULC:
            UnOp(r1);

            a := param2;
            IF a > 1 THEN
                n := UTILS.Log2(a)
            ELSIF a < -1 THEN
                n := UTILS.Log2(-a)
            ELSE
                n := -1
            END;

            IF a = 1 THEN

            ELSIF a = -1 THEN
                Neg(r1)
            ELSIF a = 0 THEN
                MovConst(r1, 0)
            ELSE
                IF n > 0 THEN
                    IF a < 0 THEN
                        Neg(r1)
                    END;
                    LslImm(r1, r1, n)
                ELSE
                    r2 := GetAnyReg();
                    MovConst(r2, a);
                    Mul(r1, r2);
                    drop
                END
            END

        |IL.opABS:
            UnOp(r1);
            Tst(r1);
            L := NewLabel();
            jcc(jge, L);
            Neg(r1);
            Label(L)

        |IL.opNOT:
            UnOp(r1);
            Tst(r1);
            SetCC(je, r1)

        |IL.opORD:
            UnOp(r1);
            Tst(r1);
            SetCC(jne, r1)

        |IL.opODD:
            UnOp(r1);
            LslImm(r1, r1, 31);
            LsrImm(r1, r1, 31)

        |IL.opCHR:
            UnOp(r1);
            LslImm(r1, r1, 24);
            LsrImm(r1, r1, 24)

        |IL.opWCHR:
            UnOp(r1);
            LslImm(r1, r1, 16);
            LsrImm(r1, r1, 16)

        |IL.opASR, IL.opROR, IL.opLSL, IL.opLSR:
            BinOp(r1, r2);
            Shift(opcode, r1, r2);
            drop

        |IL.opASR1, IL.opROR1, IL.opLSL1, IL.opLSR1:
            MovConst(GetAnyReg(), param2);
            BinOp(r2, r1);
            Shift(opcode, r1, r2);
            INCL(R.regs, r2);
            DEC(R.top);
            R.stk[R.top] := r1

        |IL.opASR2, IL.opROR2, IL.opLSL2, IL.opLSR2:
            n := param2 MOD 32;
            IF n # 0 THEN
                UnOp(r1);
                CASE opcode OF
                |IL.opASR2: AsrImm(r1, r1, n)
                |IL.opROR2: r2 := GetAnyReg(); MovConst(r2, n); Shift(IL.opROR, r1, r2); drop
                |IL.opLSL2: LslImm(r1, r1, n)
                |IL.opLSR2: LsrImm(r1, r1, n)
                END
            END

        |IL.opCHKBYTE:
            BinOp(r1, r2);
            CmpConst(r1, 256);
            jcc(jb, param1)

        |IL.opCHKIDX:
            UnOp(r1);
            CmpConst(r1, param2);
            jcc(jb, param1)

        |IL.opCHKIDX2:
            BinOp(r1, r2);
            IF param2 # -1 THEN
                Cmp(r2, r1);
                jcc(jb, param1)
            END;
            INCL(R.regs, r1);
            DEC(R.top);
            R.stk[R.top] := r2

        |IL.opLEN:
            n := param2;
            UnOp(r1);
            drop;
            EXCL(R.regs, r1);

            WHILE n > 0 DO
                UnOp(r2);
                drop;
                DEC(n)
            END;

            INCL(R.regs, r1);
            ASSERT(REG.GetReg(R, r1))

        |IL.opLADR_SAVEC:
            LocAdr(param1);
            UnOp(r1);
            r2 := GetAnyReg();
            MovConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opLADR_SAVE:
            LocAdr(param2);
            BinOp(r2, r1);
            Str32(r2, r1);
            drop;
            drop

        |IL.opLADR_INCC:
            LocAdr(param1);
            UnOp(r1);
            r2 := GetAnyReg();
            Ldr32(r2, r1);
            AddConst(r2, param2);
            Str32(r2, r1);
            drop;
            drop

        |IL.opLOOP, IL.opENDLOOP:

        ELSE
            C.IntLn(opcode);
            ASSERT(FALSE)
        END;

        cmd := cmd.next(COMMAND)
    END;

    ASSERT(R.pushed = 0);
    ASSERT(R.top = -1)
END translate;


PROCEDURE CodeGen* (outname: ARRAY OF CHAR; target: INTEGER; options: PROG.OPTIONS);
VAR
    opt: PROG.OPTIONS;

    dcount, i: INTEGER;

    File: WR.FILE;

BEGIN
    tcount := CHL.Length(IL.codes.types);

    opt := options;
    CodeList := LISTS.create(NIL);

    program := BIN.create(IL.codes.lcount);

    opt.pic := FALSE;

    REG.Init(R, push, pop, mov, xchg, NIL, NIL, {R0, R1, R2, R3}, {});

    StkCount := 0;

    translate(ORD(opt.pic), tcount * 4);

    dcount := CHL.Length(IL.codes.data);

    FOR i := 0 TO tcount - 1 DO
        BIN.PutData32LE(program, CHL.GetInt(IL.codes.types, i))
    END;

    FOR i := 0 TO dcount - 1 DO
        BIN.PutData(program, CHL.GetByte(IL.codes.data, i))
    END;

    IL.set_bss(MAX(IL.codes.bss, MAX(IL.codes.dmin - CHL.Length(IL.codes.data), 4)));

    fixup(CHL.Length(program.data), IL.codes.bss);

    File := WR.Create(outname);

    CHL.WriteToFile(File, program.code);
    WR.Padding(File, FileAlignment);
    CHL.WriteToFile(File, program.data);

    WR.Close(File)
END CodeGen;


END THUMB.