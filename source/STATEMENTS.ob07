MODULE STATEMENTS;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT

	PARS, PROG, SCAN, ARITH, STRINGS, LISTS, CODE, X86, AMD64,
	ERRORS, MACHINE, AVL := AVLTREES, CONSOLE, C := COLLECTIONS,
	mConst := modConstante;

CONST

	eCONST   =  PARS.eCONST;   eTYPE     =  PARS.eTYPE;     eVAR      =  PARS.eVAR;
	eEXPR    =  PARS.eEXPR;    eVREC     =  PARS.eVREC;     ePROC     =  PARS.ePROC;
	eVPAR    =  PARS.eVPAR;    ePARAM    =  PARS.ePARAM;    eSTPROC   =  PARS.eSTPROC;
	eSTFUNC  =  PARS.eSTFUNC;  eSYSFUNC  =  PARS.eSYSFUNC;  eSYSPROC  =  PARS.eSYSPROC;
	eIMP     =  PARS.eIMP;

	errASSERT = 1;  errPTR  =  2;  errDIV  =  3;  errPROC = 4;
	errGUARD  = 5;  errIDX  =  6;  errCASE =  7;  errCOPY = 8;
	errCHR    = 9;  errWCHR = 10;  errBYTE = 11;

	chkIDX* = 0; chkGUARD* = 1; chkPTR* = 2; chkCHR* = 3; chkWCHR* = 4; chkBYTE* = 5;

	chkALL* = {chkIDX, chkGUARD, chkPTR, chkCHR, chkWCHR, chkBYTE};

TYPE

	isXXX = PROCEDURE (e: PARS.EXPR): BOOLEAN;

	RANGE = RECORD

		a, b: INTEGER

	END;

	CASE_LABEL = POINTER TO rCASE_LABEL;

	rCASE_LABEL = RECORD (AVL.tpData)

		range: RANGE;

		variant, self: INTEGER;

		type: PROG.TYPE_;

		prev: CASE_LABEL

	END;

	CASE_VARIANT = POINTER TO RECORD (LISTS.tpItem)

		label:      INTEGER;
		cmd:        CODE.tpCommand;
		processed:  BOOLEAN

	END;

VAR
	begcall, endcall: CODE.tpCommand;
	checking: SET;
	CaseLabels, CaseVar: C.tpCollection;
	CaseVariants: LISTS.tpList;

PROCEDURE isExpr (e: PARS.EXPR): BOOLEAN;
		RETURN e.obj IN {eCONST, eVAR, eEXPR, eVPAR, ePARAM, eVREC}
	END isExpr;

PROCEDURE isVar (e: PARS.EXPR): BOOLEAN;
		RETURN e.obj IN {eVAR, eVPAR, ePARAM, eVREC}
	END isVar;

PROCEDURE isBoolean (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.typeBoolean)
	END isBoolean;

PROCEDURE isInteger (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tINTEGER)
	END isInteger;

PROCEDURE isByte (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tBYTE)
	END isByte;

PROCEDURE isInt (e: PARS.EXPR): BOOLEAN;
		RETURN isByte(e) OR isInteger(e)
	END isInt;

PROCEDURE isReal (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.typeReal)
	END isReal;

PROCEDURE isSet (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.typeSet)
	END isSet;

PROCEDURE isString (e: PARS.EXPR): BOOLEAN;
		RETURN (e.obj = eCONST) & (e.type.typ IN {PROG.typeString, PROG.typeChar})
	END isString;

PROCEDURE isStringW (e: PARS.EXPR): BOOLEAN;
		RETURN (e.obj = eCONST) & (e.type.typ IN {PROG.typeString, PROG.typeChar, PROG.typeWChar})
	END isStringW;

PROCEDURE isChar (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.typeChar)
	END isChar;

PROCEDURE isCharArray (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tARRAY) & (e.type.base.typ = PROG.typeChar)
	END isCharArray;

PROCEDURE isCharW (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.typeWChar)
	END isCharW;

PROCEDURE isCharArrayW (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tARRAY) & (e.type.base.typ = PROG.typeWChar)
	END isCharArrayW;

PROCEDURE isCharArrayX (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tARRAY) & (e.type.base.typ IN {PROG.typeChar, PROG.typeWChar})
	END isCharArrayX;

PROCEDURE isPtr (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tPOINTER)
	END isPtr;

PROCEDURE isRec (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tRECORD)
	END isRec;

PROCEDURE isArr (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tARRAY)
	END isArr;

PROCEDURE isProc (e: PARS.EXPR): BOOLEAN;
		RETURN isExpr(e) & (e.type.typ = PROG.tPROCEDURE) OR (e.obj IN {ePROC, eIMP})
	END isProc;

PROCEDURE isNil (e: PARS.EXPR): BOOLEAN;
		RETURN e.type.typ = PROG.tNIL
	END isNil;

PROCEDURE getpos (parser: PARS.PARSER; VAR pos: SCAN.POSITION);
	BEGIN
		pos := parser.lex.pos
	END getpos;

PROCEDURE NextPos (parser: PARS.PARSER; VAR pos: SCAN.POSITION);
	BEGIN
		PARS.NextPos(parser, pos)
	END NextPos;

PROCEDURE strlen (e: PARS.EXPR): INTEGER;
	VAR
		res: INTEGER;

	BEGIN
		ASSERT(isString(e));
		IF e.type.typ = PROG.typeChar THEN
			res := 1
		ELSE
			res := LENGTH(e.value.string(SCAN.IDENT).s)
		END
		RETURN res
	END strlen;

PROCEDURE _length (s: ARRAY OF CHAR): INTEGER;
	VAR
		i, res: INTEGER;

	BEGIN
		i := 0;
		res := 0;
		WHILE (i < LEN(s)) & (s[i] # 0X) DO
			IF (s[i] <= CHR(127)) OR (s[i] >= CHR(192)) THEN
				INC(res)
			END;
			INC(i)
		END

		RETURN res
	END _length;

PROCEDURE utf8strlen (e: PARS.EXPR): INTEGER;
	VAR
		res: INTEGER;

	BEGIN
		ASSERT(isStringW(e));
		IF e.type.typ IN {PROG.typeChar, PROG.typeWChar} THEN
			res := 1
		ELSE
			res := _length(e.value.string(SCAN.IDENT).s)
		END
		RETURN res
	END utf8strlen;

PROCEDURE StrToWChar (s: ARRAY OF CHAR): INTEGER;
	VAR
		res: ARRAY 2 OF WCHAR;

	BEGIN
		ASSERT(STRINGS.Utf8To16(s, res) = 1)
		RETURN ORD(res[0])
	END StrToWChar;

PROCEDURE isStringW1 (e: PARS.EXPR): BOOLEAN;
		RETURN (e.obj = eCONST) & isString(e) & (utf8strlen(e) = 1) & (strlen(e) > 1)
	END isStringW1;

PROCEDURE assigncomp (e: PARS.EXPR; t: PROG.TYPE_): BOOLEAN;
	VAR
		res: BOOLEAN;

		PROCEDURE arrcomp (src, dst: PROG.TYPE_): BOOLEAN;
			RETURN (dst.typ = PROG.tARRAY) & PROG.isOpenArray(src) &
					~PROG.isOpenArray(src.base) & ~PROG.isOpenArray(dst.base) &
					PROG.isTypeEq(src.base, dst.base)
		END arrcomp;


	BEGIN
		IF isExpr(e) OR (e.obj IN {ePROC, eIMP}) THEN
			IF arrcomp(e.type, t) THEN
				res := TRUE
			ELSIF isInt(e) & (t.typ IN {PROG.tBYTE, PROG.tINTEGER}) THEN
				IF (e.obj = eCONST) & (t.typ = PROG.tBYTE) THEN
					res := ARITH.IsRange(e.value, 0, 255)
				ELSE
					res := TRUE
				END
			ELSIF isSet(e) & (t.typ = PROG.typeSet) THEN
				res := TRUE
			ELSIF isBoolean(e) & (t.typ = PROG.typeBoolean) THEN
				res := TRUE
			ELSIF isReal(e) & (t.typ = PROG.typeReal) THEN
				res := TRUE
			ELSIF isChar(e) & (t.typ = PROG.typeChar) THEN
				res := TRUE
			ELSIF (e.obj = eCONST) & isChar(e) & (t.typ = PROG.typeWChar) THEN
				res := TRUE
			ELSIF isStringW1(e) & (t.typ = PROG.typeWChar) THEN
				res := TRUE
			ELSIF isCharW(e) & (t.typ = PROG.typeWChar) THEN
				res := TRUE
			ELSIF PROG.isBaseOf(t, e.type) THEN
				res := TRUE
			ELSIF ~PROG.isOpenArray(t) & ~PROG.isOpenArray(e.type) & PROG.isTypeEq(t, e.type) THEN
				res := TRUE
			ELSIF isNil(e) & (t.typ IN {PROG.tPOINTER, PROG.tPROCEDURE}) THEN
				res := TRUE
			ELSIF isString(e) & ((t.typ = PROG.tARRAY) & (t.base.typ = PROG.typeChar) & (t.length > strlen(e))) THEN
				res := TRUE
			ELSIF isStringW(e) & ((t.typ = PROG.tARRAY) & (t.base.typ = PROG.typeWChar) & (t.length > utf8strlen(e))) THEN
				res := TRUE
			ELSE
				res := FALSE
			END
		ELSE
			res := FALSE
		END
		RETURN res
	END assigncomp;

PROCEDURE String (e: PARS.EXPR): INTEGER;
	VAR
		offset: INTEGER;
		string: SCAN.IDENT;

	BEGIN
		IF strlen(e) # 1 THEN
			string := e.value.string(SCAN.IDENT);
			IF string.offset = -1 THEN
				string.offset := CODE.Str_Put(string.s);
			END;
			offset := string.offset
		ELSE
			offset := CODE.Str_Put1(ARITH.Int(e.value))
		END

		RETURN offset
	END String;

PROCEDURE StringW (e: PARS.EXPR): INTEGER;
	VAR
		offset: INTEGER;
		string: SCAN.IDENT;

	BEGIN
		IF utf8strlen(e) # 1 THEN
			string := e.value.string(SCAN.IDENT);
			IF string.offsetW = -1 THEN
				string.offsetW := CODE.Str_PutW(string.s);
			END;
			offset := string.offsetW
		ELSE
			IF e.type.typ IN {PROG.typeWChar, PROG.typeChar} THEN
				offset := CODE.Str_PutW1(ARITH.Int(e.value))
			ELSE (* e.type.typ = PROG.typeString *)
				string := e.value.string(SCAN.IDENT);
				IF string.offsetW = -1 THEN
					string.offsetW := CODE.Str_PutW(string.s);
				END;
				offset := string.offsetW
			END
		END

		RETURN offset
	END StringW;

PROCEDURE CheckRange (range, line, errno: INTEGER);
	VAR
		label: INTEGER;

	BEGIN
		label := CODE.Label_New();
		CODE.Cmd2_Add(CODE.opCHKIDX, label, range);
		CODE.OnError(line, errno);
		CODE.Label_Set(label)
	END CheckRange;

PROCEDURE assign (e: PARS.EXPR; t: PROG.TYPE_; line: INTEGER): BOOLEAN;
	VAR
		res:    BOOLEAN;
		label:  INTEGER;


		PROCEDURE arrcomp (src, dst: PROG.TYPE_): BOOLEAN;
			RETURN (dst.typ = PROG.tARRAY) & PROG.isOpenArray(src) &
					~PROG.isOpenArray(src.base) & ~PROG.isOpenArray(dst.base) &
					PROG.isTypeEq(src.base, dst.base)
		END arrcomp;


	BEGIN
		IF isExpr(e) OR (e.obj IN {ePROC, eIMP}) THEN
			res := TRUE;
			IF arrcomp(e.type, t) THEN
				IF ~PROG.isOpenArray(t) THEN
					CODE.Cmd_Add(mConst.codeCONST, t.length);
					CODE.Cmd_Add(CODE.opROT, 3)
				END;
				CODE.Cmd_Add(mConst.codeCOPYA, t.base.size);
				label := CODE.Label_New();
				CODE.CmdJmp_Add(CODE.opJE, label);
				CODE.OnError(line, errCOPY);
				CODE.Label_Set(label)
			ELSIF isInt(e) & (t.typ IN {PROG.tBYTE, PROG.tINTEGER}) THEN
				IF t.typ = PROG.tINTEGER THEN
					IF e.obj = eCONST THEN
						CODE.Cmd_Add(CODE.opSAVEC, ARITH.Int(e.value))
					ELSE
						CODE.Cmd0_Add(CODE.opSAVE)
					END
				ELSE
					IF e.obj = eCONST THEN
						res := ARITH.IsRange(e.value, 0, 255);
						IF res THEN
							CODE.Cmd_Add(CODE.opSAVE8C, ARITH.Int(e.value))
						END
					ELSE
						IF chkBYTE IN checking THEN
							CheckRange(256, line, errBYTE)
						END;
						CODE.Cmd0_Add(CODE.opSAVE8)
					END
				END
			ELSIF isSet(e) & (t.typ = PROG.typeSet) THEN
				IF e.obj = eCONST THEN
					CODE.Cmd_Add(CODE.opSAVEC, ARITH.Int(e.value))
				ELSE
					CODE.Cmd0_Add(CODE.opSAVE)
				END
			ELSIF isBoolean(e) & (t.typ = PROG.typeBoolean) THEN
				IF e.obj = eCONST THEN
					CODE.Cmd_Add(CODE.opSBOOLC, ARITH.Int(e.value))
				ELSE
					CODE.Cmd0_Add(CODE.opSBOOL)
				END
			ELSIF isReal(e) & (t.typ = PROG.typeReal) THEN
				IF e.obj = eCONST THEN
					CODE.Float(ARITH.Float_Get(e.value))
				END;
				CODE.Float_Save
			ELSIF isChar(e) & (t.typ = PROG.typeChar) THEN
				IF e.obj = eCONST THEN
					CODE.Cmd_Add(CODE.opSAVE8C, ARITH.Int(e.value))
				ELSE
					CODE.Cmd0_Add(CODE.opSAVE8)
				END
			ELSIF (e.obj = eCONST) & isChar(e) & (t.typ = PROG.typeWChar) THEN
				CODE.Cmd_Add(CODE.opSAVE16C, ARITH.Int(e.value))
			ELSIF isStringW1(e) & (t.typ = PROG.typeWChar) THEN
				CODE.Cmd_Add(CODE.opSAVE16C, StrToWChar(e.value.string(SCAN.IDENT).s))
			ELSIF isCharW(e) & (t.typ = PROG.typeWChar) THEN
				IF e.obj = eCONST THEN
					CODE.Cmd_Add(CODE.opSAVE16C, ARITH.Int(e.value))
				ELSE
					CODE.Cmd0_Add(CODE.opSAVE16)
				END
			ELSIF PROG.isBaseOf(t, e.type) THEN
				IF t.typ = PROG.tPOINTER THEN
					CODE.Cmd0_Add(CODE.opSAVE)
				ELSE
					CODE.Cmd_Add(CODE.opCOPY, t.size)
				END
			ELSIF (e.type.typ = PROG.tCARD32) & (t.typ = PROG.tCARD32) THEN
				CODE.Cmd0_Add(CODE.opSAVE32)
			ELSIF (e.type.typ = PROG.tCARD16) & (t.typ = PROG.tCARD16) THEN
				CODE.Cmd0_Add(CODE.opSAVE16)
			ELSIF (e.type.typ = PROG.tCARD8) & (t.typ = PROG.tCARD8) THEN
				CODE.Cmd0_Add(CODE.opSAVE8)
			ELSIF ~PROG.isOpenArray(t) & ~PROG.isOpenArray(e.type) & PROG.isTypeEq(t, e.type) THEN
				IF e.obj = ePROC THEN
					CODE.Proc_Assign(e.ident.proc.label)
				ELSIF e.obj = eIMP THEN
					CODE.ProcImp_Assign(e.ident.import)
				ELSE
					IF t.typ = PROG.tPROCEDURE THEN
						CODE.Cmd0_Add(CODE.opSAVE)
					ELSE
						CODE.Cmd_Add(CODE.opCOPY, t.size)
					END
				END
			ELSIF isNil(e) & (t.typ IN {PROG.tPOINTER, PROG.tPROCEDURE}) THEN
				CODE.Cmd_Add(CODE.opSAVEC, 0)
			ELSIF isString(e) & ((t.typ = PROG.tARRAY) & (t.base.typ = PROG.typeChar) & (t.length > strlen(e))) THEN
				CODE.Str_Save(String(e), strlen(e) + 1)
			ELSIF isStringW(e) & ((t.typ = PROG.tARRAY) & (t.base.typ = PROG.typeWChar) & (t.length > utf8strlen(e))) THEN
				CODE.Str_Save(StringW(e), (utf8strlen(e) + 1) * 2)
			ELSE
				res := FALSE
			END
		ELSE
			res := FALSE
		END
		RETURN res
	END assign;

PROCEDURE LoadConst (e: PARS.EXPR);
	BEGIN
		CODE.Cmd_Add(mConst.codeCONST, ARITH.Int(e.value))
	END LoadConst;

PROCEDURE paramcomp (parser: PARS.PARSER; pos: SCAN.POSITION; e: PARS.EXPR; p: PROG.PARAM);

		PROCEDURE arrcomp (e: PARS.EXPR; p: PROG.PARAM): BOOLEAN;
		VAR
			t1, t2: PROG.TYPE_;

		BEGIN
			t1 := p.type;
			t2 := e.type;
			WHILE (t2.typ = PROG.tARRAY) & PROG.isOpenArray(t1) DO
				t1 := t1.base;
				t2 := t2.base
			END

			RETURN PROG.isTypeEq(t1, t2)
		END arrcomp;


		PROCEDURE ArrLen (t: PROG.TYPE_; n: INTEGER): INTEGER;
		VAR
			res: INTEGER;
		BEGIN
			REPEAT
				res := t.length;
				t := t.base;
				DEC(n)
			UNTIL (n < 0) OR (t.typ # PROG.tARRAY);
			ASSERT(n < 0)
			RETURN res
		END ArrLen;


		PROCEDURE OpenArray (t, t2: PROG.TYPE_);
		VAR
			n: INTEGER;
			d1, d2: INTEGER;
		BEGIN
			IF t.length # 0 THEN
				CODE.Cmd_Add(CODE.opPARAM, 1);
				n := PROG.Dim(t2) - 1;
				WHILE n >= 0 DO
					CODE.Cmd_Add(mConst.codeCONST, ArrLen(t, n));
					CODE.Cmd_Add(CODE.opPARAM, 1);
					DEC(n)
				END
			ELSE
				d1 := PROG.Dim(t);
				d2 := PROG.Dim(t2);
				IF d1 # d2 THEN
					n := d2 - d1;
					WHILE d2 > d1 DO
						CODE.Cmd_Add(mConst.codeCONST, ArrLen(t, d2 - 1));
						DEC(d2)
					END;
					d2 := PROG.Dim(t2);
					WHILE n > 0 DO
						CODE.Cmd_Add(CODE.opROT, d2);
						DEC(n)
					END
				END;
				CODE.Cmd_Add(CODE.opPARAM, PROG.Dim(t2) + 1)
			END
		END OpenArray;


	BEGIN
		IF p.vPar THEN

			PARS.check(isVar(e), parser, pos, 93);
			IF p.type.typ = PROG.tRECORD THEN
				PARS.check(PROG.isBaseOf(p.type, e.type), parser, pos, 66);
				IF e.obj = eVREC THEN
					IF e.ident # NIL THEN
						CODE.Cmd_Add(CODE.opVADR, e.ident.offset - 1)
					ELSE
						CODE.Cmd0_Add(CODE.opPUSHT)
					END
				ELSE
					CODE.Cmd_Add(mConst.codeCONST, e.type.num)
				END;
				CODE.Cmd_Add(CODE.opPARAM, 2)
			ELSIF PROG.isOpenArray(p.type) THEN
				PARS.check(arrcomp(e, p), parser, pos, 66);
				OpenArray(e.type, p.type)
			ELSE
				PARS.check(PROG.isTypeEq(e.type, p.type), parser, pos, 66);
				CODE.Cmd_Add(CODE.opPARAM, 1)
			END;
			PARS.check(~e.readOnly, parser, pos, 94)

		ELSE
			PARS.check(isExpr(e) OR isProc(e), parser, pos, 66);
			IF PROG.isOpenArray(p.type) THEN
				IF e.type.typ = PROG.tARRAY THEN
					PARS.check(arrcomp(e, p), parser, pos, 66);
					OpenArray(e.type, p.type)
				ELSIF isString(e) & (p.type.typ = PROG.tARRAY) & (p.type.base.typ = PROG.typeChar) THEN
					CODE.Cmd_Add(CODE.opSADR, String(e));
					CODE.Cmd_Add(CODE.opPARAM, 1);
					CODE.Cmd_Add(mConst.codeCONST, strlen(e) + 1);
					CODE.Cmd_Add(CODE.opPARAM, 1)
				ELSIF isStringW(e) & (p.type.typ = PROG.tARRAY) & (p.type.base.typ = PROG.typeWChar) THEN
					CODE.Cmd_Add(CODE.opSADR, StringW(e));
					CODE.Cmd_Add(CODE.opPARAM, 1);
					CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e) + 1);
					CODE.Cmd_Add(CODE.opPARAM, 1)
				ELSE
					PARS.error(parser, pos, 66)
				END
			ELSE
				PARS.check(~PROG.isOpenArray(e.type), parser, pos, 66);
				PARS.check(assigncomp(e, p.type), parser, pos, 66);
				IF e.obj = eCONST THEN
					IF e.type.typ = PROG.typeReal THEN
						CODE.Float(ARITH.Float_Get(e.value));
						CODE.Float_Push
					ELSIF e.type.typ = PROG.tNIL THEN
						CODE.Cmd_Add(mConst.codeCONST, 0);
						CODE.Cmd_Add(CODE.opPARAM, 1)
					ELSIF isStringW1(e) & (p.type.typ = PROG.typeWChar) THEN
						CODE.Cmd_Add(mConst.codeCONST, StrToWChar(e.value.string(SCAN.IDENT).s));
						CODE.Cmd_Add(CODE.opPARAM, 1)
					ELSIF (e.type.typ = PROG.typeString) OR
						  (e.type.typ IN {PROG.typeChar, PROG.typeWChar}) & (p.type.typ = PROG.tARRAY) & (p.type.base.typ IN {PROG.typeChar, PROG.typeWChar}) THEN
						CODE.MinDataSize_Set(p.type.size);
						IF p.type.base.typ = PROG.typeChar THEN
							CODE.Cmd_Add(CODE.opSADR, String(e))
						ELSE (* WCHAR *)
							CODE.Cmd_Add(CODE.opSADR, StringW(e))
						END;
						CODE.Cmd_Add(CODE.opPARAM, 1)
					ELSE
						LoadConst(e);
						CODE.Cmd_Add(CODE.opPARAM, 1)
					END
				ELSIF e.obj = ePROC THEN
					PARS.check(e.ident.global, parser, pos, 85);
					CODE.Proc_Push(e.ident.proc.label);
					CODE.Cmd_Add(CODE.opPARAM, 1)
				ELSIF e.obj = eIMP THEN
					CODE.ProcImp_Push(e.ident.import);
					CODE.Cmd_Add(CODE.opPARAM, 1)
				ELSIF isExpr(e) & (e.type.typ = PROG.typeReal) THEN
					CODE.Float_Push
				ELSE
					IF (p.type.typ = PROG.tBYTE) & (e.type.typ = PROG.tINTEGER) & (chkBYTE IN checking) THEN
						CheckRange(256, pos.line, errBYTE)
					END;
					CODE.Cmd_Add(CODE.opPARAM, 1)
				END
			END

		END
	END paramcomp;

PROCEDURE stProc (parser: PARS.PARSER; VAR e: PARS.EXPR);
	VAR
		e2:    PARS.EXPR;
		pos:   SCAN.POSITION;
		proc:  INTEGER;
		label: INTEGER;
		n, i:  INTEGER;
		code:  ARITH.tValue;
		e1:    PARS.EXPR;
		wchar: BOOLEAN;


		PROCEDURE varparam (parser: PARS.PARSER; pos: SCAN.POSITION; isfunc: isXXX; readOnly: BOOLEAN; VAR e: PARS.EXPR);
		BEGIN
			parser.designator(parser, e);
			PARS.check(isVar(e), parser, pos, 93);
			PARS.check(isfunc(e), parser, pos, 66);
			IF readOnly THEN
				PARS.check(~e.readOnly, parser, pos, 94)
			END
		END varparam;


		PROCEDURE shift_minmax (proc: INTEGER): CHAR;
		VAR
			res: CHAR;
		BEGIN
			CASE proc OF
			|PROG.stASR: res := "A"
			|PROG.stLSL: res := "L"
			|PROG.stROR: res := "O"
			|PROG.stLSR: res := "R"
			|PROG.stMIN: res := "m"
			|PROG.stMAX: res := "x"
			END
			RETURN res
		END shift_minmax;
	BEGIN
		ASSERT(e.obj IN {eSTPROC, eSTFUNC, eSYSPROC, eSYSFUNC});

		getpos(parser, pos);
		proc := e.stproc;

		IF e.obj IN {eSTPROC, eSYSPROC} THEN

			CASE proc OF
			|PROG.stASSERT:
				parser.expression(parser, e);
				PARS.check(isBoolean(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					IF ~ARITH.Bool_Get(e.value) THEN
						CODE.OnError(pos.line, errASSERT)
					END
				ELSE
					label := CODE.Label_New();
					CODE.CmdJmp_Add(CODE.opJE, label);
					CODE.OnError(pos.line, errASSERT);
					CODE.Label_Set(label)
				END

			|PROG.stINC, PROG.stDEC:
				varparam(parser, pos, isInt, TRUE, e);
				IF e.type.typ = PROG.tINTEGER THEN
					IF parser.sym = SCAN.lxCOMMA THEN
						NextPos(parser, pos);
						parser.expression(parser, e2);
						PARS.check(isInt(e2), parser, pos, 66);
						IF e2.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opINCC + ORD(proc = PROG.stDEC), ARITH.Int(e2.value))
						ELSE
							CODE.Cmd0_Add(CODE.opINC + ORD(proc = PROG.stDEC))
						END
					ELSE
						CODE.Cmd0_Add(CODE.opINC1 + ORD(proc = PROG.stDEC))
					END
				ELSE  (* e.type.typ = PROG.tBYTE *)
					IF parser.sym = SCAN.lxCOMMA THEN
						NextPos(parser, pos);
						parser.expression(parser, e2);
						PARS.check(isInt(e2), parser, pos, 66);
						IF e2.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opINCCB + ORD(proc = PROG.stDEC), ARITH.Int(e2.value))
						ELSE
							CODE.Cmd0_Add(CODE.opINCB + ORD(proc = PROG.stDEC))
						END
					ELSE
						CODE.Cmd0_Add(CODE.opINC1B + ORD(proc = PROG.stDEC))
					END
				END

			|PROG.stINCL, PROG.stEXCL:
				varparam(parser, pos, isSet, TRUE, e);
				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);
				parser.expression(parser, e2);
				PARS.check(isInt(e2), parser, pos, 66);

				IF e2.obj = eCONST THEN
					PARS.check(ARITH.IsRange(e2.value, 0, MACHINE.target.maxSet), parser, pos, 56);
					CODE.Cmd_Add(CODE.opINCLC + ORD(proc = PROG.stEXCL), ARITH.Int(e2.value))
				ELSE
					CODE.Cmd0_Add(CODE.opINCL + ORD(proc = PROG.stEXCL))
				END

			|PROG.stNEW:
				varparam(parser, pos, isPtr, TRUE, e);
				CODE.New(e.type.base.size, e.type.base.num)

			|PROG.stDISPOSE:
				varparam(parser, pos, isPtr, TRUE, e);
				CODE.Cmd0_Add(CODE.opDISP)

			|PROG.stPACK:
				varparam(parser, pos, isReal, TRUE, e);
				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);
				parser.expression(parser, e2);
				PARS.check(isInt(e2), parser, pos, 66);
				IF e2.obj = eCONST THEN
					CODE.Cmd_Add(CODE.opPACKC, ARITH.Int(e2.value))
				ELSE
					CODE.Cmd0_Add(CODE.opPACK)
				END

			|PROG.stUNPK:
				varparam(parser, pos, isReal, TRUE, e);
				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);
				varparam(parser, pos, isInteger, TRUE, e2);
				CODE.Cmd0_Add(CODE.opUNPK)

			|PROG.stCOPY:
				parser.expression(parser, e);
				IF isString(e) OR isCharArray(e) THEN
					wchar := FALSE
				ELSIF isStringW(e) OR isCharArrayW(e) THEN
					wchar := TRUE
				ELSE
					PARS.check(FALSE, parser, pos, 66)
				END;

				IF isCharArrayX(e) & ~PROG.isOpenArray(e.type) THEN
					CODE.Cmd_Add(mConst.codeCONST, e.type.length)
				END;

				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);

				IF wchar THEN
					varparam(parser, pos, isCharArrayW, TRUE, e1)
				ELSE
					IF e.obj = eCONST THEN
						varparam(parser, pos, isCharArrayX, TRUE, e1)
					ELSE
						varparam(parser, pos, isCharArray, TRUE, e1)
					END;

					wchar := e1.type.base.typ = PROG.typeWChar
				END;

				IF ~PROG.isOpenArray(e1.type) THEN
					CODE.Cmd_Add(mConst.codeCONST, e1.type.length)
				END;

				IF e.obj = eCONST THEN
					IF wchar THEN
						CODE.Cmd_Add(CODE.opSADR, StringW(e));
						CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e) + 1)
					ELSE
						CODE.Cmd_Add(CODE.opSADR, String(e));
						CODE.Cmd_Add(mConst.codeCONST, strlen(e) + 1)
					END;
					CODE.Cmd_Add(CODE.opCOPYS2, e1.type.base.size)
				ELSE
					CODE.Cmd_Add(mConst.codeCOPYS, e1.type.base.size)
				END

			|PROG.sysGET, PROG.sysPUT, PROG.sysPUT8, PROG.sysPUT16:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					LoadConst(e)
				END;
				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);
				IF proc = PROG.sysGET THEN
					parser.designator(parser, e2);
					PARS.check(isVar(e2), parser, pos, 93);
					PARS.check((e2.type.typ IN PROG.BASICTYPES) OR (e2.type.typ = PROG.tPOINTER) OR (e2.type.typ = PROG.tPROCEDURE), parser, pos, 66);
					CODE.Sys_Get(e2.type.size)
				ELSIF proc = PROG.sysPUT THEN
					parser.expression(parser, e2);
					PARS.check(isExpr(e2), parser, pos, 66);
					PARS.check((e2.type.typ IN PROG.BASICTYPES) OR (e2.type.typ = PROG.tPOINTER) OR (e2.type.typ = PROG.tPROCEDURE), parser, pos, 66);
					IF e2.obj = eCONST THEN
						IF e2.type.typ = PROG.typeReal THEN
							CODE.Float(ARITH.Float_Get(e2.value));
							CODE.Float_Save
						ELSE
							LoadConst(e2);
							CODE.Sys_Put(e2.type.size)
						END
					ELSE
						IF e2.type.typ = PROG.typeReal THEN
							CODE.Float_Save
						ELSIF e2.type.typ = PROG.tBYTE THEN
							CODE.Sys_Put(PARS.program.stTypes.tINTEGER.size)
						ELSE
							CODE.Sys_Put(e2.type.size)
						END
					END

				ELSIF (proc = PROG.sysPUT8) OR (proc = PROG.sysPUT16) THEN
					parser.expression(parser, e2);
					PARS.check(isExpr(e2), parser, pos, 66);
					PARS.check(e2.type.typ IN {PROG.tINTEGER, PROG.tBYTE, PROG.typeChar, PROG.typeWChar,
												PROG.tCARD8, PROG.tCARD16, PROG.tCARD32}, parser, pos, 66);
					IF e2.obj = eCONST THEN
						LoadConst(e2)
					END;
					IF proc = PROG.sysPUT8 THEN
						CODE.Sys_Put(1)
					ELSE
						CODE.Sys_Put(2)
					END

				END

			|PROG.sysMOVE:
				FOR i := 1 TO 2 DO
					parser.expression(parser, e);
					PARS.check(isInt(e), parser, pos, 66);
					IF e.obj = eCONST THEN
						LoadConst(e)
					END;
					PARS.checklex(parser, SCAN.lxCOMMA);
					NextPos(parser, pos)
				END;

				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					LoadConst(e)
				END;
				CODE.Cmd0_Add(CODE.opMOVE)

			|PROG.sysCOPY:
				FOR i := 1 TO 2 DO
					parser.designator(parser, e);
					PARS.check(isVar(e), parser, pos, 93);
					n := PROG.Dim(e.type);
					WHILE n > 0 DO
						CODE.Drop;
						DEC(n)
					END;
					PARS.checklex(parser, SCAN.lxCOMMA);
					NextPos(parser, pos)
				END;

				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					LoadConst(e)
				END;
				CODE.Cmd0_Add(CODE.opMOVE)

			|PROG.sysCODE:
				REPEAT
					getpos(parser, pos);
					PARS.ConstExpression(parser, code);
					PARS.check(code.typ = mConst.typeInteger, parser, pos, 43);
					PARS.check(ARITH.IsRange(code, 0, 255), parser, pos, 42);
					IF parser.sym = SCAN.lxCOMMA THEN
						PARS.Next(parser)
					ELSE
						PARS.checklex(parser, SCAN.lxRROUND)
					END;
					CODE.Cmd_Add(CODE.opCODE, ARITH.Int_Get(code))
				UNTIL parser.sym = SCAN.lxRROUND

			END;

			e.obj := eEXPR;
			e.type := NIL

		ELSIF e.obj IN {eSTFUNC, eSYSFUNC} THEN

			CASE e.stproc OF
			|PROG.stABS:
				parser.expression(parser, e);
				PARS.check(isInt(e) OR isReal(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					ARITH.Abs_Set(e.value)
				ELSE
					CODE.Abs_Set(isReal(e))
				END

			|PROG.stASR, PROG.stLSL, PROG.stROR, PROG.stLSR, PROG.stMIN, PROG.stMAX:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				PARS.checklex(parser, SCAN.lxCOMMA);
				NextPos(parser, pos);
				parser.expression(parser, e2);
				PARS.check(isInt(e2), parser, pos, 66);
				e.type := PARS.program.stTypes.tINTEGER;
				IF (e.obj = eCONST) & (e2.obj = eCONST) THEN
					ASSERT(ARITH.IsOpInt(e.value, e2.value, shift_minmax(proc)))
				ELSE
					IF e.obj = eCONST THEN
						CODE.ShiftMinMax1_Set(shift_minmax(proc), ARITH.Int(e.value))
					ELSIF e2.obj = eCONST THEN
						CODE.ShiftMinMax2_Set(shift_minmax(proc), ARITH.Int(e2.value))
					ELSE
						CODE.ShiftMinMax_Set(shift_minmax(proc))
					END;
					e.obj := eEXPR
				END

			|PROG.stCHR:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				e.type := PARS.program.stTypes.typeChar;
				IF e.obj = eCONST THEN
					ARITH.Char_Set(e.value, ARITH.Int_Get(e.value));
					PARS.check(ARITH.Check(e.value), parser, pos, 107)
				ELSE
					IF chkCHR IN checking THEN
						CheckRange(256, pos.line, errCHR)
					ELSE
						CODE.Cmd0_Add(CODE.opCHR)
					END
				END

			|PROG.stWCHR:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				e.type := PARS.program.stTypes.typeWChar;
				IF e.obj = eCONST THEN
					ARITH.WChar_Set(e.value, ARITH.Int_Get(e.value));
					PARS.check(ARITH.Check(e.value), parser, pos, 101)
				ELSE
					IF chkWCHR IN checking THEN
						CheckRange(65536, pos.line, errWCHR)
					ELSE
						CODE.Cmd0_Add(CODE.opWCHR)
					END
				END

			|PROG.stFLOOR:
				parser.expression(parser, e);
				PARS.check(isReal(e), parser, pos, 66);
				e.type := PARS.program.stTypes.tINTEGER;
				IF e.obj = eCONST THEN
					PARS.check(ARITH.IsFloor(e.value), parser, pos, 39)
				ELSE
					CODE.Floor_Set
				END

			|PROG.stFLT:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				e.type := PARS.program.stTypes.typeReal;
				IF e.obj = eCONST THEN
					ARITH.Float_Set(e.value)
				ELSE
					PARS.check(CODE.IsFloat(), parser, pos, 41)
				END

			|PROG.stLEN:
				varparam(parser, pos, isArr, FALSE, e);
				IF e.type.length > 0 THEN
					CODE.Drop;
					ASSERT(ARITH.Int_Set(e.value, e.type.length));
					e.obj := eCONST
				ELSE
					CODE.Len(PROG.Dim(e.type))
				END;
				e.type := PARS.program.stTypes.tINTEGER

			|PROG.stLENGTH:
				parser.expression(parser, e);
				IF isCharArray(e) THEN
					IF e.type.length > 0 THEN
						CODE.Cmd_Add(mConst.codeCONST, e.type.length)
					END;
					CODE.Cmd0_Add(CODE.opLENGTH)
				ELSIF isCharArrayW(e) THEN
					IF e.type.length > 0 THEN
						CODE.Cmd_Add(mConst.codeCONST, e.type.length)
					END;
					CODE.Cmd0_Add(CODE.opLENGTHW)
				ELSE
					PARS.check(FALSE, parser, pos, 66);
				END;
				e.type := PARS.program.stTypes.tINTEGER

			|PROG.stODD:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				e.type := PARS.program.stTypes.typeBoolean;
				IF e.obj = eCONST THEN
					ARITH.Odd_Set(e.value)
				ELSE
					CODE.Odd_Set
				END

			|PROG.stORD:
				parser.expression(parser, e);
				PARS.check(isChar(e) OR isBoolean(e) OR isSet(e) OR isCharW(e) OR isStringW1(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					IF isStringW1(e) THEN
						ASSERT(ARITH.Int_Set(e.value, StrToWChar(e.value.string(SCAN.IDENT).s)))
					ELSE
						ARITH.Ord_Set(e.value)
					END
				ELSE
					IF isBoolean(e) THEN
						CODE.Ord_Set
					END
				END;
				e.type := PARS.program.stTypes.tINTEGER

			|PROG.stBITS:
				parser.expression(parser, e);
				PARS.check(isInt(e), parser, pos, 66);
				IF e.obj = eCONST THEN
					ARITH.Bits_Set(e.value)
				END;
				e.type := PARS.program.stTypes.typeSet

			|PROG.sysADR:
				parser.designator(parser, e);
				IF isVar(e) THEN
					n := PROG.Dim(e.type);
					WHILE n > 0 DO
						CODE.Drop;
						DEC(n)
					END
				ELSIF e.obj = ePROC THEN
					CODE.Proc_Push(e.ident.proc.label)
				ELSIF e.obj = eIMP THEN
					CODE.ProcImp_Push(e.ident.import)
				ELSE
					PARS.check(FALSE, parser, pos, 108)
				END;
				e.type := PARS.program.stTypes.tINTEGER

			|PROG.sysSADR:
				parser.expression(parser, e);
				PARS.check(isString(e), parser, pos, 66);
				CODE.Cmd_Add(CODE.opSADR, String(e));
				e.type := PARS.program.stTypes.tINTEGER;
				e.obj := eEXPR

			|PROG.sysWSADR:
				parser.expression(parser, e);
				PARS.check(isStringW(e), parser, pos, 66);
				CODE.Cmd_Add(CODE.opSADR, StringW(e));
				e.type := PARS.program.stTypes.tINTEGER;
				e.obj := eEXPR

			|PROG.sysTYPEID:
				parser.expression(parser, e);
				PARS.check(e.obj = eTYPE, parser, pos, 68);
				IF e.type.typ = PROG.tRECORD THEN
					ASSERT(ARITH.Int_Set(e.value, e.type.num))
				ELSIF e.type.typ = PROG.tPOINTER THEN
					ASSERT(ARITH.Int_Set(e.value, e.type.base.num))
				ELSE
					PARS.check(FALSE, parser, pos, 52)
				END;
				e.obj := eCONST;
				e.type := PARS.program.stTypes.tINTEGER

			|PROG.sysINF:
				PARS.check(CODE.IsInf(), parser, pos, 41);
				e.obj := eEXPR;
				e.type := PARS.program.stTypes.typeReal

			|PROG.sysSIZE:
				parser.expression(parser, e);
				PARS.check(e.obj = eTYPE, parser, pos, 68);
				ASSERT(ARITH.Int_Set(e.value, e.type.size));
				e.obj := eCONST;
				e.type := PARS.program.stTypes.tINTEGER

			END

		END;

		PARS.checklex(parser, SCAN.lxRROUND);
		PARS.Next(parser);

		IF e.obj # eCONST THEN
			e.obj := eEXPR
		END

	END stProc;

PROCEDURE ActualParameters (parser: PARS.PARSER; VAR e: PARS.EXPR);
	VAR
		proc:  PROG.TYPE_;
		param: LISTS.tpItem;
		e1:    PARS.EXPR;
		pos:   SCAN.POSITION;

	BEGIN
		ASSERT(parser.sym = SCAN.lxLROUND);

		IF (e.obj IN {ePROC, eIMP}) OR isExpr(e) THEN
			proc := e.type;
			PARS.check1(proc.typ = PROG.tPROCEDURE, parser, 86);
			PARS.Next(parser);

			param := proc.params.first;
			WHILE param # NIL DO
				getpos(parser, pos);

				CODE.Last_Set(begcall);

				IF param(PROG.PARAM).vPar THEN
					parser.designator(parser, e1)
				ELSE
					parser.expression(parser, e1)
				END;
				paramcomp(parser, pos, e1, param(PROG.PARAM));
				param := param.next;
				IF param # NIL THEN
					PARS.checklex(parser, SCAN.lxCOMMA);
					PARS.Next(parser)
				END
			END;

			PARS.checklex(parser, SCAN.lxRROUND);
			PARS.Next(parser);

			e.obj := eEXPR;
			e.type := proc.base

		ELSIF e.obj IN {eSTPROC, eSTFUNC, eSYSPROC, eSYSFUNC} THEN
			PARS.Next(parser);
			stProc(parser, e)
		ELSE
			PARS.check1(FALSE, parser, 86)
		END

	END ActualParameters;

PROCEDURE qualident (parser: PARS.PARSER; VAR e: PARS.EXPR);
	VAR
		ident:  PROG.IDENT;
		import: BOOLEAN;
		pos:    SCAN.POSITION;

	BEGIN
		PARS.checklex(parser, SCAN.lxIDENT);
		getpos(parser, pos);
		import := FALSE;
		ident := parser.unit.idents.get(parser.unit, parser.lex.ident, FALSE);
		PARS.check1(ident # NIL, parser, 48);
		IF ident.typ = PROG.idMODULE THEN
			PARS.ExpectSym(parser, SCAN.lxPOINT);
			PARS.ExpectSym(parser, SCAN.lxIDENT);
			ident := ident.unit.idents.get(ident.unit, parser.lex.ident, FALSE);
			PARS.check1((ident # NIL) & ident.export, parser, 48);
			import := TRUE
		END;
		PARS.Next(parser);

		e.readOnly := FALSE;
		e.ident := ident;

		CASE ident.typ OF
		|PROG.idCONST:
			e.obj   := eCONST;
			e.type  := ident.type;
			e.value := ident.value
		|PROG.idTYPE:
			e.obj  := eTYPE;
			e.type := ident.type
		|PROG.idVAR:
			e.obj  := eVAR;
			e.type := ident.type;
			e.readOnly := import
		|PROG.idPROC:
			e.obj   := ePROC;
			e.type  := ident.type
		|PROG.idIMP:
			e.obj   := eIMP;
			e.type  := ident.type
		|PROG.idVPAR:
			e.type := ident.type;
			IF e.type.typ = PROG.tRECORD THEN
				e.obj := eVREC
			ELSE
				e.obj := eVPAR
			END
		|PROG.idPARAM:
			e.obj  := ePARAM;
			e.type := ident.type;
			e.readOnly := (e.type.typ IN {PROG.tRECORD, PROG.tARRAY})
		|PROG.idSTPROC:
			e.obj    := eSTPROC;
			e.stproc := ident.stproc
		|PROG.idSTFUNC:
			e.obj    := eSTFUNC;
			e.stproc := ident.stproc
		|PROG.idSYSPROC:
			e.obj    := eSYSPROC;
			e.stproc := ident.stproc
		|PROG.idSYSFUNC:
			PARS.check(~parser.constexp, parser, pos, 109);
			e.obj    := eSYSFUNC;
			e.stproc := ident.stproc
		|PROG.idNONE:
			PARS.check(FALSE, parser, pos, 115)
		END;

		IF isVar(e) THEN
			PARS.check(e.ident.global OR (e.ident.scopeLvl = parser.unit.scopeLvl), parser, pos, 105)
		END

	END qualident;

PROCEDURE deref (pos: SCAN.POSITION; e: PARS.EXPR; load: BOOLEAN; error: INTEGER);
	VAR
		label:  INTEGER;

	BEGIN
		IF load THEN
			CODE.Load(e.type.size)
		END;

		IF chkPTR IN checking THEN
			label := CODE.Label_New();
			CODE.CmdJmp_Add(CODE.opJNZ, label);
			CODE.OnError(pos.line, error);
			CODE.Label_Set(label)
		END
	END deref;

PROCEDURE designator (parser: PARS.PARSER; VAR e: PARS.EXPR);
	VAR
		field:  PROG.FIELD;
		pos:    SCAN.POSITION;
		t, idx: PARS.EXPR;


		PROCEDURE LoadAdr (e: PARS.EXPR);
		VAR
			offset: INTEGER;

			PROCEDURE OpenArray (e: PARS.EXPR);
			VAR
				offset, n: INTEGER;
			BEGIN
				offset := e.ident.offset;
				n := PROG.Dim(e.type);
				WHILE n >= 0 DO
					CODE.Cmd_Add(CODE.opVADR, offset);
					DEC(offset);
					DEC(n)
				END
			END OpenArray;


		BEGIN
			IF e.obj = eVAR THEN
				offset := PROG.getOffset(PARS.program, e.ident);
				IF e.ident.global THEN
					CODE.Cmd_Add(mConst.codeGADR, offset)
				ELSE
					CODE.Cmd_Add(CODE.opLADR, -offset)
				END
			ELSIF e.obj = ePARAM THEN
				IF (e.type.typ = PROG.tRECORD) OR ((e.type.typ = PROG.tARRAY) & (e.type.length > 0)) THEN
					CODE.Cmd_Add(CODE.opVADR, e.ident.offset)
				ELSIF PROG.isOpenArray(e.type) THEN
					OpenArray(e)
				ELSE
					CODE.Cmd_Add(CODE.opLADR, e.ident.offset)
				END
			ELSIF e.obj IN {eVPAR, eVREC} THEN
				IF PROG.isOpenArray(e.type) THEN
					OpenArray(e)
				ELSE
					CODE.Cmd_Add(CODE.opVADR, e.ident.offset)
				END
			END
		END LoadAdr;


		PROCEDURE OpenIdx (parser: PARS.PARSER; pos: SCAN.POSITION; e: PARS.EXPR);
		VAR
			label:  INTEGER;
			type:   PROG.TYPE_;
			n, offset, k: INTEGER;

		BEGIN

			IF chkIDX IN checking THEN
				label := CODE.Label_New();
				CODE.Cmd2_Add(CODE.opCHKIDX2, label, 0);
				CODE.OnError(pos.line, errIDX);
				CODE.Label_Set(label)
			ELSE
				CODE.Cmd_Add(CODE.opCHKIDX2, -1)
			END;

			type := PROG.OpenBase(e.type);
			IF type.size # 1 THEN
				CODE.Cmd_Add(mConst.codeMULC, type.size)
			END;
			n := PROG.Dim(e.type) - 1;
			k := n;
			WHILE n > 0 DO
				CODE.Cmd0_Add(mConst.codeMUL);
				DEC(n)
			END;
			CODE.Cmd0_Add(CODE.opADD);
			offset := e.ident.offset - 1;
			n := k;
			WHILE n > 0 DO
				CODE.Cmd_Add(CODE.opVADR, offset);
				DEC(offset);
				DEC(n)
			END
		END OpenIdx;


	BEGIN
		qualident(parser, e);

		IF e.obj IN {ePROC, eIMP} THEN
			PROG.UseProc(parser.unit, e.ident.proc)
		END;

		IF isVar(e) THEN
			LoadAdr(e)
		END;

		WHILE parser.sym = SCAN.lxPOINT DO
			getpos(parser, pos);
			PARS.check1(isExpr(e) & (e.type.typ IN {PROG.tRECORD, PROG.tPOINTER}), parser, 73);
			IF e.type.typ = PROG.tPOINTER THEN
				deref(pos, e, TRUE, errPTR)
			END;
			PARS.ExpectSym(parser, SCAN.lxIDENT);
			IF e.type.typ = PROG.tPOINTER THEN
				e.type := e.type.base;
				e.readOnly := FALSE
			END;
			field := e.type.fields.get(e.type, parser.lex.ident, parser.unit);
			PARS.check1(field # NIL, parser, 74);
			e.type := field.type;
			IF e.obj = eVREC THEN
				e.obj := eVPAR
			END;
			IF field.offset # 0 THEN
				CODE.Cmd_Add(CODE.opADDR, field.offset)
			END;
			PARS.Next(parser);
			e.ident := NIL

		ELSIF parser.sym = SCAN.lxLSQUARE DO

			REPEAT

				PARS.check1(isArr(e), parser, 75);
				NextPos(parser, pos);
				parser.expression(parser, idx);
				PARS.check(isInt(idx), parser, pos, 76);

				IF idx.obj = eCONST THEN
					IF e.type.length > 0 THEN
						PARS.check(ARITH.IsRange(idx.value, 0, e.type.length - 1), parser, pos, 83);
						IF ARITH.Int(idx.value) > 0 THEN
							CODE.Cmd_Add(CODE.opADDR, ARITH.Int(idx.value) * e.type.base.size)
						END
					ELSE
						PARS.check(ARITH.IsRange(idx.value, 0, MACHINE.target.maxInt), parser, pos, 83);
						LoadConst(idx);
						OpenIdx(parser, pos, e)
					END
				ELSE
					IF e.type.length > 0 THEN
						IF chkIDX IN checking THEN
							CheckRange(e.type.length, pos.line, errIDX)
						END;
						IF e.type.base.size # 1 THEN
							CODE.Cmd_Add(mConst.codeMULC, e.type.base.size)
						END;
						CODE.Cmd0_Add(CODE.opADD)
					ELSE
						OpenIdx(parser, pos, e)
					END
				END;

				e.type := e.type.base

			UNTIL parser.sym # SCAN.lxCOMMA;

			PARS.checklex(parser, SCAN.lxRSQUARE);
			PARS.Next(parser);
			e.ident := NIL

		ELSIF parser.sym = SCAN.lxCARET DO
			getpos(parser, pos);
			PARS.check1(isPtr(e), parser, 77);
			deref(pos, e, TRUE, errPTR);
			e.type := e.type.base;
			e.readOnly := FALSE;
			PARS.Next(parser);
			e.ident := NIL;
			e.obj := eVREC

		ELSIF (parser.sym = SCAN.lxLROUND) & isExpr(e) & (e.type.typ IN {PROG.tRECORD, PROG.tPOINTER}) DO

			IF e.type.typ = PROG.tRECORD THEN
				PARS.check1(e.obj = eVREC, parser, 78)
			END;
			NextPos(parser, pos);
			qualident(parser, t);
			PARS.check(t.obj = eTYPE, parser, pos, 79);

			IF e.type.typ = PROG.tRECORD THEN
				PARS.check(t.type.typ = PROG.tRECORD, parser, pos, 80);
				IF chkGUARD IN checking THEN
					IF e.ident = NIL THEN
						CODE.Type_Guard(CODE.opTYPEGD, t.type.num, pos.line, errGUARD)
					ELSE
						CODE.Cmd_Add(CODE.opVADR, e.ident.offset - 1);
						CODE.Type_Guard(CODE.opTYPEGR, t.type.num, pos.line, errGUARD)
					END
				END;
			ELSE
				PARS.check(t.type.typ = PROG.tPOINTER, parser, pos, 81);
				IF chkGUARD IN checking THEN
					CODE.Type_Guard(CODE.opTYPEGP, t.type.base.num, pos.line, errGUARD)
				END
			END;

			PARS.check(PROG.isBaseOf(e.type, t.type), parser, pos, 82);

			e.type := t.type;

			PARS.checklex(parser, SCAN.lxRROUND);
			PARS.Next(parser)

		END

	END designator;

PROCEDURE expression (parser: PARS.PARSER; VAR e: PARS.EXPR);
	VAR
		pos, pos0, pos1: SCAN.POSITION;

		op:        INTEGER;
		e1:        PARS.EXPR;
		constant:  BOOLEAN;
		operator:  ARITH.tRelation;
		error:     INTEGER;

		PROCEDURE relation (sym: INTEGER): BOOLEAN;
			RETURN (sym = SCAN.lxEQ) OR (sym = SCAN.lxNE) OR
					(sym = SCAN.lxLT) OR (sym = SCAN.lxLE) OR
					(sym = SCAN.lxGT) OR (sym = SCAN.lxGE) OR
					(sym = SCAN.lxIN) OR (sym = SCAN.lxIS)
		END relation;

		PROCEDURE AddOperator (sym: INTEGER): BOOLEAN;
			RETURN (sym = SCAN.lxPLUS) OR (sym = SCAN.lxMINUS) OR
					(sym = SCAN.lxOR)
		END AddOperator;

		PROCEDURE MulOperator (sym: INTEGER): BOOLEAN;
			RETURN (sym = SCAN.lxMUL) OR (sym = SCAN.lxSLASH) OR
					(sym = SCAN.lxDIV) OR (sym = SCAN.lxMOD) OR
					(sym = SCAN.lxAND)
		END MulOperator;

		PROCEDURE element (parser: PARS.PARSER; VAR e: PARS.EXPR);
		VAR
			e1, e2: PARS.EXPR;
			pos:    SCAN.POSITION;
			range:  BOOLEAN;

		BEGIN
			range := FALSE;
			getpos(parser, pos);
			expression(parser, e1);
			PARS.check(isInt(e1), parser, pos, 76);

			IF e1.obj = eCONST THEN
				PARS.check(ARITH.IsRange(e1.value, 0, MACHINE.target.maxSet), parser, pos, 44)
			END;

			range := parser.sym = SCAN.lxRANGE;

			IF range THEN
				NextPos(parser, pos);
				expression(parser, e2);
				PARS.check(isInt(e2), parser, pos, 76);

				IF e2.obj = eCONST THEN
					PARS.check(ARITH.IsRange(e2.value, 0, MACHINE.target.maxSet), parser, pos, 44)
				END
			ELSE
				IF e1.obj = eCONST THEN
					e2 := e1
				END
			END;

			e.type := PARS.program.stTypes.typeSet;

			IF (e1.obj = eCONST) & (e2.obj = eCONST) THEN
				ARITH.Set_New(e.value, e1.value, e2.value);
				e.obj := eCONST
			ELSE
				IF range THEN
					IF e1.obj = eCONST THEN
						CODE.Cmd_Add(CODE.opRSETL, ARITH.Int(e1.value))
					ELSIF e2.obj = eCONST THEN
						CODE.Cmd_Add(CODE.opRSETR, ARITH.Int(e2.value))
					ELSE
						CODE.Cmd0_Add(CODE.opRSET)
					END
				ELSE
					CODE.Cmd0_Add(CODE.opRSET1)
				END;
				e.obj := eEXPR
			END

		END element;

		PROCEDURE set (parser: PARS.PARSER; VAR e: PARS.EXPR);
		VAR
			e1: PARS.EXPR;

		BEGIN
			ASSERT(parser.sym = SCAN.lxLCURLY);

			e.obj := eCONST;
			e.type := PARS.program.stTypes.typeSet;
			ARITH.Empty_Set(e.value);

			PARS.Next(parser);
			IF parser.sym # SCAN.lxRCURLY THEN
				element(parser, e1);

				IF e1.obj = eCONST THEN
					ARITH.OpSet_Set(e.value, e1.value, "+")
				ELSE
					e.obj := eEXPR
				END;

				WHILE parser.sym = SCAN.lxCOMMA DO
					PARS.Next(parser);
					element(parser, e1);
					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN
						ARITH.OpSet_Set(e.value, e1.value, "+")
					ELSE
						IF e.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opADDSL, ARITH.Int(e.value))
						ELSIF e1.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opADDSR, ARITH.Int(e1.value))
						ELSE
							CODE.Cmd0_Add(CODE.opADDS)
						END;
						e.obj := eEXPR
					END
				END;
				PARS.checklex(parser, SCAN.lxRCURLY)
			END;
			PARS.Next(parser);
		END set;

		PROCEDURE factor (parser: PARS.PARSER; VAR e: PARS.EXPR);
		VAR
			sym:    INTEGER;
			pos:    SCAN.POSITION;
			e1:     PARS.EXPR;
			cconv:  INTEGER;
			params: INTEGER;
			fregs:  INTEGER;


			PROCEDURE LoadVar (e: PARS.EXPR; parser: PARS.PARSER; pos: SCAN.POSITION);
			BEGIN
				IF ~(e.type.typ IN {PROG.tRECORD, PROG.tARRAY}) THEN
					IF e.type.typ = PROG.typeReal THEN
						PARS.check(CODE.Float_Load(), parser, pos, 41)
					ELSE
						CODE.Load(e.type.size)
					END
				END
			END LoadVar;


		BEGIN
			sym := parser.sym;

			IF (sym = SCAN.lxINTEGER) OR (sym = SCAN.lxHEX) OR (sym = SCAN.lxFLOAT) OR (sym = SCAN.lxCHAR) OR (sym = SCAN.lxSTRING) THEN
				e.obj := eCONST;
				e.value := parser.lex.value;
				e.type := PARS.program.getType(PARS.program, e.value.typ);
				PARS.Next(parser)

			ELSIF sym = SCAN.lxNIL THEN
				e.obj   := eCONST;
				e.type  := PARS.program.stTypes.tNIL;
				PARS.Next(parser)

			ELSIF (sym = SCAN.lxTRUE) OR (sym = SCAN.lxFALSE) THEN
				e.obj   := eCONST;
				ARITH.Bool_Set(e.value, sym = SCAN.lxTRUE);
				e.type  := PARS.program.stTypes.typeBoolean;
				PARS.Next(parser)

			ELSIF sym = SCAN.lxLCURLY THEN
				set(parser, e)

			ELSIF sym = SCAN.lxIDENT THEN
				getpos(parser, pos);

				CODE.BegEnd_Push(begcall, endcall);

				designator(parser, e);
				IF isVar(e) THEN
					LoadVar(e, parser, pos)
				END;
				IF parser.sym = SCAN.lxLROUND THEN
					e1 := e;
					ActualParameters(parser, e);

					PARS.check(e.type # NIL, parser, pos, 59);
					IF e1.obj IN {ePROC, eIMP} THEN
						cconv := e1.ident.type.call;
						params := e1.ident.type.params.size;
						CODE.Last_Set(begcall);
						fregs := CODE.Pre_Call(e.type.typ = PROG.typeReal);
						CODE.Last_Set(endcall.prev(CODE.tpCommand));

						IF e1.obj = eIMP THEN
							CODE.Imp_Call(e1.ident.import)
						ELSE
							CODE.Call(e1.ident.proc.label)
						END;

						IF cconv = PROG.cdecl THEN
							CODE.Cmd_Add(CODE.opCLEANUP, params)
						END;

						IF e.type.typ = PROG.typeReal THEN
							PARS.check(CODE.IsResFloat(fregs), parser, pos, 41)
						ELSE
							CODE.res(fregs)
						END

					ELSIF isExpr(e1) THEN
						cconv := e1.type.call;
						params := e1.type.params.size;
						CODE.Last_Set(begcall);
						fregs := CODE.Pre_Call(e.type.typ = PROG.typeReal);
						CODE.Last_Set(endcall.prev(CODE.tpCommand));
						deref(pos, e1, FALSE, errPROC);
						CODE.Proc_Call;

						IF cconv = PROG.cdecl THEN
							CODE.Cmd_Add(CODE.opCLEANUP, params)
						END;

						IF e.type.typ = PROG.typeReal THEN
							PARS.check(CODE.IsResFloat(fregs), parser, pos, 41)
						ELSE
							CODE.res(fregs)
						END
					END
				END;
				CODE.BegEnd_Pop(begcall, endcall)

			ELSIF sym = SCAN.lxLROUND THEN
				PARS.Next(parser);
				expression(parser, e);
				PARS.checklex(parser, SCAN.lxRROUND);
				PARS.Next(parser);
				IF isExpr(e) & (e.obj # eCONST) THEN
					e.obj := eEXPR
				END

			ELSIF sym = SCAN.lxNOT THEN
				NextPos(parser, pos);
				factor(parser, e);
				PARS.check(isBoolean(e), parser, pos, 72);
				IF e.obj # eCONST THEN
					CODE.Not;
					e.obj := eEXPR
				ELSE
					ASSERT(ARITH.IsNeg(e.value))
				END

			ELSE
				PARS.check1(FALSE, parser, 34)
			END
		END factor;


		PROCEDURE term (parser: PARS.PARSER; VAR e: PARS.EXPR);
		VAR
			pos: SCAN.POSITION;
			op:  INTEGER;
			e1:  PARS.EXPR;

			label:  INTEGER;
			label1: INTEGER;

		BEGIN
			factor(parser, e);
			label := -1;

			WHILE MulOperator(parser.sym) DO
				op  := parser.sym;
				getpos(parser, pos);
				PARS.Next(parser);

				IF op = SCAN.lxAND THEN
					IF ~parser.constexp THEN

						IF label = -1 THEN
							label := CODE.Label_New()
						END;

						IF e.obj = eCONST THEN
							CODE.Cmd_Add(mConst.codeCONST, ORD(ARITH.Bool_Get(e.value)))
						END;
						CODE.Cmd0_Add(CODE.opACC);
						CODE.CmdJmp_Add(CODE.opJZ, label);
						CODE.Drop
					END
				END;

				factor(parser, e1);

				CASE op OF
				|SCAN.lxMUL:
					PARS.check(isInt(e) & isInt(e1) OR isReal(e) & isReal(e1) OR isSet(e) & isSet(e1), parser, pos, 37);
					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN

						CASE e.value.typ OF
						|mConst.typeInteger: PARS.check(ARITH.IsOpInt(e.value, e1.value, "*"),   parser, pos, 39)
						|mConst.typeReal:    PARS.check(ARITH.IsOpFloat(e.value, e1.value, "*"), parser, pos, 40)
						|mConst.typeSet:     ARITH.OpSet_Set(e.value, e1.value, "*")
						END

					ELSE
						IF isInt(e) THEN
							IF e.obj = eCONST THEN
								CODE.Cmd_Add(mConst.codeMULC, ARITH.Int(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Cmd_Add(mConst.codeMULC, ARITH.Int(e1.value))
							ELSE
								CODE.Cmd0_Add(mConst.codeMUL)
							END
						ELSIF isReal(e) THEN
							IF e.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e1.value))
							END;
							CODE.fbinop(CODE.opMULF)
						ELSIF isSet(e) THEN
							IF e.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opMULSC, ARITH.Int(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opMULSC, ARITH.Int(e1.value))
							ELSE
								CODE.Cmd0_Add(CODE.opMULS)
							END
						END;
						e.obj := eEXPR
					END

				|SCAN.lxSLASH:
					PARS.check(isReal(e) & isReal(e1) OR isSet(e) & isSet(e1), parser, pos, 37);
					IF (e1.obj = eCONST) & isReal(e1) THEN
						PARS.check(~ARITH.IsZero(e1.value), parser, pos, 45)
					END;
					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN

						CASE e.value.typ OF
						|mConst.typeReal: PARS.check(ARITH.IsOpFloat(e.value, e1.value, "/"), parser, pos, 40)
						|mConst.typeSet:  ARITH.OpSet_Set(e.value, e1.value, "/")
						END

					ELSE
						IF isReal(e) THEN
							IF e.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e.value));
								CODE.fbinop(CODE.opDIVFI)
							ELSIF e1.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e1.value));
								CODE.fbinop(CODE.opDIVF)
							ELSE
								CODE.fbinop(CODE.opDIVF)
							END
						ELSIF isSet(e) THEN
							IF e.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opDIVSC, ARITH.Int(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opDIVSC, ARITH.Int(e1.value))
							ELSE
								CODE.Cmd0_Add(CODE.opDIVS)
							END
						END;
						e.obj := eEXPR
					END

				|SCAN.lxDIV, SCAN.lxMOD:
					PARS.check(isInt(e) & isInt(e1), parser, pos, 37);
					IF e1.obj = eCONST THEN
						PARS.check(~ARITH.IsZero(e1.value), parser, pos, 46)
					END;
					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN

						IF op = SCAN.lxDIV THEN
							PARS.check(ARITH.IsOpInt(e.value, e1.value, "D"), parser, pos, 39)
						ELSE
							ASSERT(ARITH.IsOpInt(e.value, e1.value, "M"))
						END

					ELSE
						IF e1.obj # eCONST THEN
							label1 := CODE.Label_New();
							CODE.CmdJmp_Add(CODE.opJNZ, label1)
						END;
						IF e.obj = eCONST THEN
							CODE.OnError(pos.line, errDIV);
							CODE.Label_Set(label1);
							CODE.Cmd_Add(mConst.codeMOD + ORD(op = SCAN.lxMOD), ARITH.Int(e.value))
						ELSIF e1.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opDIVR + ORD(op = SCAN.lxMOD), ARITH.Int(e1.value))
						ELSE
							CODE.OnError(pos.line, errDIV);
							CODE.Label_Set(label1);
							CODE.Cmd0_Add(mConst.codeDIV  + ORD(op = SCAN.lxMOD))
						END;
						e.obj := eEXPR
					END

				|SCAN.lxAND:
					PARS.check(isBoolean(e) & isBoolean(e1), parser, pos, 37);

					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN
						ARITH.OpBool_Set(e.value, e1.value, "&")
					ELSE
						e.obj := eEXPR;
						IF e1.obj = eCONST THEN
							CODE.Cmd_Add(mConst.codeCONST, ORD(ARITH.Bool_Get(e1.value)))
						END;
						CODE.Cmd0_Add(CODE.opACC)
					END

				END
			END;

			IF label # -1 THEN
				CODE.Label_Set(label)
			END
		END term;


		PROCEDURE SimpleExpression (parser: PARS.PARSER; VAR e: PARS.EXPR);
		VAR
			pos: SCAN.POSITION;
			op:  INTEGER;
			e1:  PARS.EXPR;

			plus, minus: BOOLEAN;

			label: INTEGER;

		BEGIN
			plus  := parser.sym = SCAN.lxPLUS;
			minus := parser.sym = SCAN.lxMINUS;

			IF plus OR minus THEN
				getpos(parser, pos);
				PARS.Next(parser)
			END;

			term(parser, e);

			IF plus OR minus THEN
				PARS.check(isInt(e) OR isReal(e) OR isSet(e), parser, pos, 36);

				IF minus & (e.obj = eCONST) THEN
					PARS.check(ARITH.IsNeg(e.value), parser, pos, 39)
				END;

				IF e.obj # eCONST THEN
					IF minus THEN
						IF isInt(e) THEN
							CODE.Cmd0_Add(CODE.opUMINUS)
						ELSIF isReal(e) THEN
							CODE.Cmd0_Add(CODE.opUMINF)
						ELSIF isSet(e) THEN
							CODE.Cmd0_Add(CODE.opUMINS)
						END
					END;
					e.obj := eEXPR
				END
			END;

			label := -1;

			WHILE AddOperator(parser.sym) DO

				op  := parser.sym;
				getpos(parser, pos);
				PARS.Next(parser);

				IF op = SCAN.lxOR THEN

					IF ~parser.constexp THEN

						IF label = -1 THEN
							label := CODE.Label_New()
						END;

						IF e.obj = eCONST THEN
							CODE.Cmd_Add(mConst.codeCONST, ORD(ARITH.Bool_Get(e.value)))
						END;
						CODE.Cmd0_Add(CODE.opACC);
						CODE.CmdJmp_Add(CODE.opJNZ, label);
						CODE.Drop
					END

				END;

				term(parser, e1);

				CASE op OF
				|SCAN.lxPLUS, SCAN.lxMINUS:

					IF op = SCAN.lxPLUS THEN
						op := ORD("+")
					ELSE
						op := ORD("-")
					END;

					PARS.check(isInt(e) & isInt(e1) OR isReal(e) & isReal(e1) OR isSet(e) & isSet(e1), parser, pos, 37);
					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN

						CASE e.value.typ OF
						|mConst.typeInteger: PARS.check(ARITH.IsOpInt(e.value, e1.value, CHR(op)),   parser, pos, 39)
						|mConst.typeReal:    PARS.check(ARITH.IsOpFloat(e.value, e1.value, CHR(op)), parser, pos, 40)
						|mConst.typeSet:     ARITH.OpSet_Set(e.value, e1.value, CHR(op))
						END

					ELSE
						IF isInt(e) THEN
							IF e.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opADDL + ORD(op = ORD("-")), ARITH.Int(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opADDR + ORD(op = ORD("-")), ARITH.Int(e1.value))
							ELSE
								CODE.Cmd0_Add(CODE.opADD  + ORD(op = ORD("-")))
							END
						ELSIF isReal(e) THEN
							IF e.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e.value));
								CODE.fbinop(CODE.opADDFI + ORD(op = ORD("-")))
							ELSIF e1.obj = eCONST THEN
								CODE.Float(ARITH.Float_Get(e1.value));
								CODE.fbinop(CODE.opADDF  + ORD(op = ORD("-")))
							ELSE
								CODE.fbinop(CODE.opADDF  + ORD(op = ORD("-")))
							END
						ELSIF isSet(e) THEN
							IF e.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opADDSL + ORD(op = ORD("-")), ARITH.Int(e.value))
							ELSIF e1.obj = eCONST THEN
								CODE.Cmd_Add(CODE.opADDSR + ORD(op = ORD("-")), ARITH.Int(e1.value))
							ELSE
								CODE.Cmd0_Add(CODE.opADDS  + ORD(op = ORD("-")))
							END
						END;
						e.obj := eEXPR
					END

				|SCAN.lxOR:
					PARS.check(isBoolean(e) & isBoolean(e1), parser, pos, 37);


					IF (e.obj = eCONST) & (e1.obj = eCONST) THEN
						ARITH.OpBool_Set(e.value, e1.value, "|")
					ELSE
						e.obj := eEXPR;
						IF e1.obj = eCONST THEN
							CODE.Cmd_Add(mConst.codeCONST, ORD(ARITH.Bool_Get(e1.value)))
						END;
						CODE.Cmd0_Add(CODE.opACC)
					END

				END
			END;

			IF label # -1 THEN
				CODE.Label_Set(label)
			END

		END SimpleExpression;


		PROCEDURE cmpcode (op: INTEGER): INTEGER;
		VAR
			res: INTEGER;
		BEGIN
			CASE op OF
			|SCAN.lxEQ: res := 0
			|SCAN.lxNE: res := 1
			|SCAN.lxLT: res := 2
			|SCAN.lxLE: res := 3
			|SCAN.lxGT: res := 4
			|SCAN.lxGE: res := 5
			END

			RETURN res
		END cmpcode;


		PROCEDURE BoolCmp (eq, val: BOOLEAN);
		BEGIN
			IF eq = val THEN
				CODE.Cmd0_Add(CODE.opNER)
			ELSE
				CODE.Cmd0_Add(CODE.opEQR)
			END
		END BoolCmp;


		PROCEDURE strcmp (VAR e, e1: PARS.EXPR; op: INTEGER): BOOLEAN;
		VAR
			res: BOOLEAN;

		BEGIN

			res := TRUE;

			IF isString(e) & isCharArray(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, String(e));
				CODE.Cmd_Add(mConst.codeCONST, strlen(e) + 1);
				CODE.Cmd0_Add(CODE.opEQS2 + cmpcode(op))

			ELSIF isString(e) & isCharArrayW(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, StringW(e));
				CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e) + 1);
				CODE.Cmd0_Add(CODE.opEQSW2 + cmpcode(op))

			ELSIF isStringW(e) & isCharArrayW(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, StringW(e));
				CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e) + 1);
				CODE.Cmd0_Add(CODE.opEQSW2 + cmpcode(op))

			ELSIF isCharArray(e) & isString(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, String(e1));
				CODE.Cmd_Add(mConst.codeCONST, strlen(e1) + 1);
				CODE.Cmd0_Add(CODE.opEQS + cmpcode(op))

			ELSIF isCharArrayW(e) & isString(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, StringW(e1));
				CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e1) + 1);
				CODE.Cmd0_Add(CODE.opEQSW + cmpcode(op))

			ELSIF isCharArrayW(e) & isStringW(e1) THEN
				CODE.Cmd_Add(CODE.opSADR, StringW(e1));
				CODE.Cmd_Add(mConst.codeCONST, utf8strlen(e1) + 1);
				CODE.Cmd0_Add(CODE.opEQSW + cmpcode(op))

			ELSIF isCharArrayW(e) & isCharArrayW(e1) THEN
				CODE.Cmd0_Add(CODE.opEQSW + cmpcode(op))

			ELSIF isCharArray(e) & isCharArray(e1) THEN
				CODE.Cmd0_Add(CODE.opEQS + cmpcode(op))

			ELSIF isString(e) & isString(e1) THEN
				PARS.strcmp(e.value, e1.value, op)

			ELSE
				res := FALSE

			END

			RETURN res
		END strcmp;
	BEGIN
		getpos(parser, pos0);
		SimpleExpression(parser, e);
		IF relation(parser.sym) THEN
			IF (isCharArray(e) OR isCharArrayW(e)) & (e.type.length # 0) THEN
				CODE.Cmd_Add(mConst.codeCONST, e.type.length)
			END;
			op  := parser.sym;
			getpos(parser, pos);
			PARS.Next(parser);

			pos1 := parser.lex.pos;
			SimpleExpression(parser, e1);

			IF (isCharArray(e1) OR isCharArrayW(e1)) & (e1.type.length # 0) THEN
				CODE.Cmd_Add(mConst.codeCONST, e1.type.length)
			END;

			constant := (e.obj = eCONST) & (e1.obj = eCONST);

			CASE op OF
			|SCAN.lxEQ: operator := "="
			|SCAN.lxNE: operator := "#"
			|SCAN.lxLT: operator := "<"
			|SCAN.lxLE: operator := "<="
			|SCAN.lxGT: operator := ">"
			|SCAN.lxGE: operator := ">="
			|SCAN.lxIN: operator := "IN"
			|SCAN.lxIS: operator := ""
			END;

			error := 0;

			CASE op OF
			|SCAN.lxEQ, SCAN.lxNE:

				IF isInt(e) & isInt(e1) OR isSet(e) & isSet(e1) OR isChar(e) & isChar(e1) OR isCharW(e) & isCharW(e1) OR
				isCharW(e) & isChar(e1) & (e1.obj = eCONST) OR isCharW(e1) & isChar(e) & (e.obj = eCONST) OR
				isCharW(e1) & (e1.obj = eCONST) & isChar(e) & (e.obj = eCONST) OR
				isCharW(e) & (e.obj = eCONST) & isChar(e1) & (e1.obj = eCONST) OR
				isPtr(e) & isPtr(e1) & (PROG.isBaseOf(e.type, e1.type) OR PROG.isBaseOf(e1.type, e.type)) THEN
					IF constant THEN
						ARITH.Relation_Set(e.value, e1.value, operator, error)
					ELSE
						IF e.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 6,  ARITH.Int(e.value))
						ELSIF e1.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 12, ARITH.Int(e1.value))
						ELSE
							CODE.Cmd0_Add(CODE.opEQ + cmpcode(op))
						END
					END

				ELSIF isStringW1(e) & isCharW(e1) THEN
					CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 6, StrToWChar(e.value.string(SCAN.IDENT).s))

				ELSIF isStringW1(e1) & isCharW(e) THEN
					CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 12, StrToWChar(e1.value.string(SCAN.IDENT).s))

				ELSIF isBoolean(e) & isBoolean(e1) THEN
					IF constant THEN
						ARITH.Relation_Set(e.value, e1.value, operator, error)
					ELSE
						IF e.obj = eCONST THEN
							BoolCmp(op = SCAN.lxEQ, ARITH.Int(e.value) # 0)
						ELSIF e1.obj = eCONST THEN
							BoolCmp(op = SCAN.lxEQ, ARITH.Int(e1.value) # 0)
						ELSE
							IF op = SCAN.lxEQ THEN
								CODE.Cmd0_Add(CODE.opEQB)
							ELSE
								CODE.Cmd0_Add(CODE.opNEB)
							END
						END
					END

				ELSIF isReal(e) & isReal(e1) THEN
					IF constant THEN
						ARITH.Relation_Set(e.value, e1.value, operator, error)
					ELSE
						IF e.obj = eCONST THEN
							CODE.Float(ARITH.Float_Get(e.value));
							CODE.fcmp(CODE.opEQF + cmpcode(op) + 6)
						ELSIF e1.obj = eCONST THEN
							CODE.Float(ARITH.Float_Get(e1.value));
							CODE.fcmp(CODE.opEQF + cmpcode(op))
						ELSE
							CODE.fcmp(CODE.opEQF + cmpcode(op))
						END
					END

				ELSIF (isStringW(e) OR isCharArrayX(e)) & (isStringW(e1) OR isCharArrayX(e1)) THEN
					IF ~strcmp(e, e1, op) THEN
						PARS.error(parser, pos, 37)
					END

				ELSIF isPtr(e) & isNil(e1) OR isNil(e) & isPtr(e1) THEN
					CODE.Cmd0_Add(CODE.opEQ + cmpcode(op) + 6)

				ELSIF isProc(e) & isNil(e1) THEN
					IF e.obj IN {ePROC, eIMP} THEN
						PARS.check(e.ident.global, parser, pos0, 85);
						constant := TRUE;
						e.obj := eCONST;
						ARITH.Bool_Set(e.value, op = SCAN.lxNE)
					ELSE
						CODE.Cmd0_Add(CODE.opEQ + cmpcode(op) + 6)
					END

				ELSIF isNil(e) & isProc(e1) THEN
					IF e1.obj IN {ePROC, eIMP} THEN
						PARS.check(e1.ident.global, parser, pos1, 85);
						constant := TRUE;
						e.obj := eCONST;
						ARITH.Bool_Set(e.value, op = SCAN.lxNE)
					ELSE
						CODE.Cmd0_Add(CODE.opEQ + cmpcode(op) + 6)
					END

				ELSIF isProc(e) & isProc(e1) & PROG.isTypeEq(e.type, e1.type) THEN
					IF e.obj = ePROC THEN
						PARS.check(e.ident.global, parser, pos0, 85)
					END;
					IF e1.obj = ePROC THEN
						PARS.check(e1.ident.global, parser, pos1, 85)
					END;
					IF (e.obj IN {ePROC, eIMP}) & (e1.obj IN {ePROC, eIMP}) THEN
						constant := TRUE;
						e.obj := eCONST;
						IF op = SCAN.lxEQ THEN
							ARITH.Bool_Set(e.value, e.ident = e1.ident)
						ELSE
							ARITH.Bool_Set(e.value, e.ident # e1.ident)
						END
					ELSIF e.obj = ePROC THEN
						CODE.Proc_Cmp(e.ident.proc.label, cmpcode(op) = 0)
					ELSIF e1.obj = ePROC THEN
						CODE.Proc_Cmp(e1.ident.proc.label, cmpcode(op) = 0)
					ELSIF e.obj = eIMP THEN
						CODE.ProcImp_Cmp(e.ident.import, cmpcode(op) = 0)
					ELSIF e1.obj = eIMP THEN
						CODE.ProcImp_Cmp(e1.ident.import, cmpcode(op) = 0)
					ELSE
						CODE.Cmd0_Add(CODE.opEQ + cmpcode(op))
					END

				ELSIF isNil(e) & isNil(e1) THEN
					constant := TRUE;
					e.obj := eCONST;
					ARITH.Bool_Set(e.value, op = SCAN.lxEQ)

				ELSE
					PARS.error(parser, pos, 37)
				END

			|SCAN.lxLT, SCAN.lxLE, SCAN.lxGT, SCAN.lxGE:
				IF isInt(e) & isInt(e1) OR isChar(e) & isChar(e1) OR isCharW(e) & isCharW(e1) OR
					isCharW(e) & isChar(e1) & (e1.obj = eCONST) OR isCharW(e1) & isChar(e) & (e.obj = eCONST) OR
					isCharW(e1) & (e1.obj = eCONST) & isChar(e) & (e.obj = eCONST) OR
					isCharW(e) & (e.obj = eCONST) & isChar(e1) & (e1.obj = eCONST) THEN

					IF constant THEN
						ARITH.Relation_Set(e.value, e1.value, operator, error)
					ELSE
						IF e.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 6, ARITH.Int(e.value))
						ELSIF e1.obj = eCONST THEN
							CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 12, ARITH.Int(e1.value))
						ELSE
							CODE.Cmd0_Add(CODE.opEQ + cmpcode(op))
						END
					END

				ELSIF isStringW1(e) & isCharW(e1) THEN
					CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 6, StrToWChar(e.value.string(SCAN.IDENT).s))

				ELSIF isStringW1(e1) & isCharW(e) THEN
					CODE.Cmd_Add(CODE.opEQ + cmpcode(op) + 12, StrToWChar(e1.value.string(SCAN.IDENT).s))

				ELSIF isReal(e) & isReal(e1) THEN
					IF constant THEN
						ARITH.Relation_Set(e.value, e1.value, operator, error)
					ELSE
						IF e.obj = eCONST THEN
							CODE.Float(ARITH.Float_Get(e.value));
							CODE.fcmp(CODE.opEQF + cmpcode(op) + 6)
						ELSIF e1.obj = eCONST THEN
							CODE.Float(ARITH.Float_Get(e1.value));
							CODE.fcmp(CODE.opEQF + cmpcode(op))
						ELSE
							CODE.fcmp(CODE.opEQF + cmpcode(op))
						END
					END

				ELSIF (isStringW(e) OR isCharArrayX(e)) & (isStringW(e1) OR isCharArrayX(e1)) THEN
					IF ~strcmp(e, e1, op) THEN
						PARS.error(parser, pos, 37)
					END

				ELSE
					PARS.error(parser, pos, 37)
				END

			|SCAN.lxIN:
				PARS.check(isInt(e) & isSet(e1), parser, pos, 37);
				IF e.obj = eCONST THEN
					PARS.check(ARITH.IsRange(e.value, 0, MACHINE.target.maxSet), parser, pos0, 56)
				END;
				IF constant THEN
					ARITH.Relation_Set(e.value, e1.value, operator, error)
				ELSE
					IF e.obj = eCONST THEN
						CODE.Cmd_Add(CODE.opINL, ARITH.Int(e.value))
					ELSIF e1.obj = eCONST THEN
						CODE.Cmd_Add(CODE.opINR, ARITH.Int(e1.value))
					ELSE
						CODE.Cmd0_Add(CODE.opIN)
					END
				END

			|SCAN.lxIS:
				PARS.check(isExpr(e) & (e.type.typ IN {PROG.tRECORD, PROG.tPOINTER}), parser, pos, 73);
				IF e.type.typ = PROG.tRECORD THEN
					PARS.check(e.obj = eVREC, parser, pos0, 78)
				END;
				PARS.check(e1.obj = eTYPE, parser, pos1, 79);

				IF e.type.typ = PROG.tRECORD THEN
					PARS.check(e1.type.typ = PROG.tRECORD,  parser, pos1, 80);
					IF e.ident = NIL THEN
						CODE.Type_Check(e1.type.num)
					ELSE
						CODE.Cmd_Add(CODE.opVADR, e.ident.offset - 1);
						CODE.TypeRec_Check(e1.type.num)
					END
				ELSE
					PARS.check(e1.type.typ = PROG.tPOINTER, parser, pos1, 81);
					CODE.Type_Check(e1.type.base.num)
				END;

				PARS.check(PROG.isBaseOf(e.type, e1.type), parser, pos1, 82)

			END;

			ASSERT(error = 0);

			e.type := PARS.program.stTypes.typeBoolean;

			IF ~constant THEN
				e.obj := eEXPR
			END

		END
	END expression;

PROCEDURE ElementaryStatement (parser: PARS.PARSER);
	VAR
		e, e1:  PARS.EXPR;
		pos:    SCAN.POSITION;
		line:   INTEGER;
		call:   BOOLEAN;
		params: INTEGER;
		cconv:  INTEGER;

	BEGIN
		getpos(parser, pos);

		CODE.BegEnd_Push(begcall, endcall);

		designator(parser, e);

		IF parser.sym = SCAN.lxASSIGN THEN
			line := parser.lex.pos.line;
			PARS.check(isVar(e), parser, pos, 93);
			PARS.check(~e.readOnly, parser, pos, 94);
			NextPos(parser, pos);
			expression(parser, e1);
			PARS.check(assign(e1, e.type, line), parser, pos, 91);
			IF e1.obj = ePROC THEN
				PARS.check(e1.ident.global, parser, pos, 85)
			END;
			call := FALSE
		ELSIF parser.sym = SCAN.lxEQ THEN
			PARS.check1(FALSE, parser, 96)
		ELSIF parser.sym = SCAN.lxLROUND THEN
			e1 := e;
			ActualParameters(parser, e1);
			PARS.check((e1.type = NIL) OR (e.type.call IN {PROG.winapi, PROG.kosapi}), parser, pos, 92);
			call := TRUE
		ELSE
			PARS.check(isProc(e), parser, pos, 86);
			PARS.check((e.type.base = NIL) OR (e.type.call IN {PROG.winapi, PROG.kosapi}), parser, pos, 92);
			PARS.check1(e.type.params.first = NIL, parser, 64);
			call := TRUE
		END;

		cconv := -1;

		IF call THEN
			IF e.obj IN {ePROC, eIMP} THEN
				cconv := e.ident.type.call;
				params := e.ident.type.params.size;
				CODE.Last_Set(begcall);
				ASSERT(CODE.Pre_Call(FALSE) = 0);
				CODE.Last_Set(endcall.prev(CODE.tpCommand));
				IF e.obj = eIMP THEN
					CODE.Imp_Call(e.ident.import)
				ELSE
					CODE.Call(e.ident.proc.label)
				END

			ELSIF isExpr(e) THEN
				cconv := e.type.call;
				params := e.type.params.size;
				CODE.Last_Set(begcall);
				ASSERT(CODE.Pre_Call(FALSE) = 0);
				CODE.Last_Set(endcall.prev(CODE.tpCommand));
				deref(pos, e, TRUE, errPROC);
				CODE.Proc_Call
			END
		END;

		CODE.BegEnd_Pop(begcall, endcall);

		IF cconv = PROG.cdecl THEN
			CODE.Cmd_Add(CODE.opCLEANUP, params)
		END

	END ElementaryStatement;

PROCEDURE IfStatement (parser: PARS.PARSER; if: BOOLEAN);
	VAR
		e:     PARS.EXPR;
		pos:   SCAN.POSITION;

		label, L: INTEGER;

	BEGIN
		L := CODE.Label_New();

		IF ~if THEN
			CODE.Label_Set(L)
		END;

		REPEAT
			NextPos(parser, pos);

			label := CODE.Label_New();

			expression(parser, e);
			PARS.check(isBoolean(e), parser, pos, 72);

			IF e.obj = eCONST THEN
				IF ~ARITH.Bool_Get(e.value) THEN
					CODE.CmdJmp_Add(mConst.codeJMP, label)
				END
			ELSE
				CODE.CmdJmp_Add(CODE.opJNE, label)
			END;

			IF if THEN
				PARS.checklex(parser, SCAN.lxTHEN)
			ELSE
				PARS.checklex(parser, SCAN.lxDO)
			END;

			PARS.Next(parser);
			parser.StatSeq(parser);

			CODE.CmdJmp_Add(mConst.codeJMP, L);
			CODE.Label_Set(label)

		UNTIL parser.sym # SCAN.lxELSIF;

		IF if THEN
			IF parser.sym = SCAN.lxELSE THEN
				PARS.Next(parser);
				parser.StatSeq(parser)
			END;
			CODE.Label_Set(L)
		END;

		PARS.checklex(parser, SCAN.lxEND);
		PARS.Next(parser)
	END IfStatement;

PROCEDURE RepeatStatement (parser: PARS.PARSER);
	VAR
		e:     PARS.EXPR;
		pos:   SCAN.POSITION;
		label: INTEGER;

	BEGIN
		label := CODE.Label_New();
		CODE.Label_Set(label);

		PARS.Next(parser);
		parser.StatSeq(parser);
		PARS.checklex(parser, SCAN.lxUNTIL);
		NextPos(parser, pos);
		expression(parser, e);
		PARS.check(isBoolean(e), parser, pos, 72);

		IF e.obj = eCONST THEN
			IF ~ARITH.Bool_Get(e.value) THEN
				CODE.CmdJmp_Add(mConst.codeJMP, label)
			END
		ELSE
			CODE.CmdJmp_Add(CODE.opJNE, label)
		END
	END RepeatStatement;

PROCEDURE LabelCmp (a, b: AVL.tpData): INTEGER;
	VAR
		La, Ra, Lb, Rb, res: INTEGER;

	BEGIN
		La := a(CASE_LABEL).range.a;
		Ra := a(CASE_LABEL).range.b;
		Lb := b(CASE_LABEL).range.a;
		Rb := b(CASE_LABEL).range.b;
		IF (Ra < Lb) OR (La > Rb) THEN
			res := ORD(La > Lb) - ORD(La < Lb)
		ELSE
			res := 0
		END

		RETURN res
	END LabelCmp;

PROCEDURE DestroyLabel (VAR label: AVL.tpData);
	BEGIN
		C.Push(CaseLabels, label);
		label := NIL
	END DestroyLabel;

PROCEDURE NewVariant (label: INTEGER; cmd: CODE.tpCommand): CASE_VARIANT;
	VAR
		res:   CASE_VARIANT;
		citem: C.tpItem;

	BEGIN
		citem := C.Pop(CaseVar);
		IF citem = NIL THEN
			NEW(res)
		ELSE
			res := citem(CASE_VARIANT)
		END;

		res.label := label;
		res.cmd := cmd;
		res.processed := FALSE

		RETURN res
	END NewVariant;

PROCEDURE CaseStatement (parser: PARS.PARSER);
	VAR
		e:      PARS.EXPR;
		pos:    SCAN.POSITION;
		PROCEDURE isRecPtr (caseExpr: PARS.EXPR): BOOLEAN;
			RETURN isRec(caseExpr) OR isPtr(caseExpr)
		END isRecPtr;


		PROCEDURE Label (parser: PARS.PARSER; caseExpr: PARS.EXPR; VAR type: PROG.TYPE_): INTEGER;
		VAR
			a:      INTEGER;
			label:  PARS.EXPR;
			pos:    SCAN.POSITION;
			value:  ARITH.tValue;

		BEGIN
			getpos(parser, pos);
			type := NIL;

			IF isChar(caseExpr) THEN
				PARS.ConstExpression(parser, value);
				PARS.check(value.typ = mConst.typeChar, parser, pos, 99);
				a := ARITH.Int_Get(value)
			ELSIF isCharW(caseExpr) THEN
				PARS.ConstExpression(parser, value);
				IF (value.typ = mConst.typeString) & (_length(value.string(SCAN.IDENT).s) = 1) & (LENGTH(value.string(SCAN.IDENT).s) > 1) THEN
					ASSERT(ARITH.Int_Set(value, StrToWChar(value.string(SCAN.IDENT).s)))
				ELSE
					PARS.check(value.typ IN {mConst.typeWChar, mConst.typeChar}, parser, pos, 99)
				END;
				a := ARITH.Int_Get(value)
			ELSIF isInt(caseExpr) THEN
				PARS.ConstExpression(parser, value);
				PARS.check(value.typ = mConst.typeInteger, parser, pos, 99);
				a := ARITH.Int_Get(value)
			ELSIF isRecPtr(caseExpr) THEN
				qualident(parser, label);
				PARS.check(label.obj = eTYPE, parser, pos, 79);
				PARS.check(PROG.isBaseOf(caseExpr.type, label.type), parser, pos, 99);
				IF isRec(caseExpr) THEN
					a := label.type.num
				ELSE
					a := label.type.base.num
				END;
				type := label.type
			END

			RETURN a
		END Label;


		PROCEDURE CheckType (node: AVL.tpNode; type: PROG.TYPE_; parser: PARS.PARSER; pos: SCAN.POSITION);
		BEGIN
			IF node # NIL THEN
				PARS.check(~(PROG.isBaseOf(node.data(CASE_LABEL).type, type) OR PROG.isBaseOf(type, node.data(CASE_LABEL).type)), parser, pos, 100);
				CheckType(node.left, type, parser, pos);
				CheckType(node.right, type, parser, pos)
			END
		END CheckType;


		PROCEDURE LabelRange (parser: PARS.PARSER; caseExpr: PARS.EXPR; VAR tree: AVL.tpNode; variant: INTEGER): AVL.tpNode;
		VAR
			label:     CASE_LABEL;
			citem:     C.tpItem;
			pos, pos1: SCAN.POSITION;
			node:      AVL.tpNode;
			newnode:   BOOLEAN;
			range:     RANGE;

		BEGIN
			citem := C.Pop(CaseLabels);
			IF citem = NIL THEN
				NEW(label)
			ELSE
				label := citem(CASE_LABEL)
			END;

			label.variant := variant;
			label.self := CODE.Label_New();

			getpos(parser, pos1);
			range.a := Label(parser, caseExpr, label.type);

			IF parser.sym = SCAN.lxRANGE THEN
				PARS.check1(~isRecPtr(caseExpr), parser, 53);
				NextPos(parser, pos);
				range.b := Label(parser, caseExpr, label.type);
				PARS.check(range.a <= range.b, parser, pos, 103)
			ELSE
				range.b := range.a
			END;

			label.range := range;

			IF isRecPtr(caseExpr) THEN
				CheckType(tree, label.type, parser, pos1)
			END;
			tree := AVL.Insert(tree, label, LabelCmp, newnode, node);
			PARS.check(newnode, parser, pos1, 100)

			RETURN node

		END LabelRange;


		PROCEDURE CaseLabelList (parser: PARS.PARSER; caseExpr: PARS.EXPR; VAR tree: AVL.tpNode; variant: INTEGER): AVL.tpNode;
		VAR
			exit: BOOLEAN;
			res:  AVL.tpNode;

		BEGIN
			exit := FALSE;
			REPEAT
				res := LabelRange(parser, caseExpr, tree, variant);
				IF parser.sym = SCAN.lxCOMMA THEN
					PARS.check1(~isRecPtr(caseExpr), parser, 53);
					PARS.Next(parser)
				ELSE
					exit := TRUE
				END
			UNTIL exit

			RETURN res
		END CaseLabelList;


		PROCEDURE case (parser: PARS.PARSER; caseExpr: PARS.EXPR; VAR tree: AVL.tpNode; end: INTEGER);
		VAR
			sym:      INTEGER;
			t:        PROG.TYPE_;
			variant:  INTEGER;
			node:     AVL.tpNode;
			last:     CODE.tpCommand;

		BEGIN
			sym := parser.sym;
			IF sym # SCAN.lxBAR THEN
				variant := CODE.Label_New();
				node := CaseLabelList(parser, caseExpr, tree, variant);
				PARS.checklex(parser, SCAN.lxCOLON);
				PARS.Next(parser);
				IF isRecPtr(caseExpr) THEN
					t := caseExpr.type;
					caseExpr.ident.type := node.data(CASE_LABEL).type
				END;

				last := CODE.Last_Get();
				CODE.Label_Set(variant);

				IF ~isRecPtr(caseExpr) THEN
					LISTS.Add(CaseVariants, NewVariant(variant, last))
				END;

				parser.StatSeq(parser);
				CODE.CmdJmp_Add(mConst.codeJMP, end);

				IF isRecPtr(caseExpr) THEN
					caseExpr.ident.type := t
				END
			END
		END case;


		PROCEDURE Table (node: AVL.tpNode; else: INTEGER);
		VAR
			L, R: INTEGER;
			range: RANGE;
			left, right: AVL.tpNode;
			last: CODE.tpCommand;
			v: CASE_VARIANT;

		BEGIN
			IF node # NIL THEN

				range := node.data(CASE_LABEL).range;

				left := node.left;
				IF left # NIL THEN
					L := left.data(CASE_LABEL).self
				ELSE
					L := else
				END;

				right := node.right;
				IF right # NIL THEN
					R := right.data(CASE_LABEL).self
				ELSE
					R := else
				END;

				last := CODE.Last_Get();

				v := CaseVariants.last(CASE_VARIANT);
				WHILE (v # NIL) & (v.label # 0) & (v.label # node.data(CASE_LABEL).variant) DO
					v := v.prev(CASE_VARIANT)
				END;

				ASSERT((v # NIL) & (v.label # 0));
				CODE.Last_Set(v.cmd);

				CODE.Label_Set(node.data(CASE_LABEL).self);
				CODE.Case(range.a, range.b, L, R);
				IF v.processed THEN
					CODE.CmdJmp_Add(mConst.codeJMP, node.data(CASE_LABEL).variant)
				END;
				v.processed := TRUE;

				CODE.Last_Set(last);

				Table(left, else);
				Table(right, else)
			END
		END Table;


		PROCEDURE TableT (node: AVL.tpNode);
		BEGIN
			IF node # NIL THEN
				CODE.Case_Set(node.data(CASE_LABEL).range.a, node.data(CASE_LABEL).variant);

				TableT(node.left);
				TableT(node.right)
			END
		END TableT;


		PROCEDURE ParseCase (parser: PARS.PARSER; e: PARS.EXPR; pos: SCAN.POSITION);
		VAR
			table, end, else: INTEGER;
			tree: AVL.tpNode;
			item:  LISTS.tpItem;

		BEGIN
			LISTS.Add(CaseVariants, NewVariant(0, NIL));
			end   := CODE.Label_New();
			else  := CODE.Label_New();
			table := CODE.Label_New();
			CODE.Cmd_Add(CODE.opSWITCH, ORD(isRecPtr(e)));
			CODE.CmdJmp_Add(mConst.codeJMP, table);

			tree := NIL;

			case(parser, e, tree, end);
			WHILE parser.sym = SCAN.lxBAR DO
				PARS.Next(parser);
				case(parser, e, tree, end)
			END;

			CODE.Label_Set(else);
			IF parser.sym = SCAN.lxELSE THEN
				PARS.Next(parser);
				parser.StatSeq(parser);
				CODE.CmdJmp_Add(mConst.codeJMP, end)
			ELSE
				CODE.OnError(pos.line, errCASE)
			END;

			PARS.checklex(parser, SCAN.lxEND);
			PARS.Next(parser);

			IF isRecPtr(e) THEN
				CODE.Label_Set(table);
				TableT(tree);
				CODE.CmdJmp_Add(mConst.codeJMP, else)
			ELSE
				tree.data(CASE_LABEL).self := table;
				Table(tree, else)
			END;

			AVL.Destroy(tree, DestroyLabel);
			CODE.Label_Set(end);
			CODE.Cmd0_Add(CODE.opENDSW);

			REPEAT
				item := LISTS.Delete(CaseVariants);
				C.Push(CaseVar, item)
			UNTIL item(CASE_VARIANT).cmd = NIL

		END ParseCase;
	BEGIN
		NextPos(parser, pos);
		expression(parser, e);
		PARS.check(isInt(e) OR isChar(e) OR isCharW(e) OR isPtr(e) OR isRec(e), parser, pos, 95);
		IF isRecPtr(e) THEN
			PARS.check(isVar(e), parser, pos, 93);
			PARS.check(e.ident # NIL, parser, pos, 106)
		END;
		IF isRec(e) THEN
			PARS.check(e.obj = eVREC, parser, pos, 78)
		END;

		IF e.obj = eCONST THEN
			LoadConst(e)
		ELSIF isRec(e) THEN
			CODE.Drop;
			CODE.Cmd_Add(CODE.opLADR, e.ident.offset - 1);
			CODE.Load(PARS.program.target.word)
		ELSIF isPtr(e) THEN
			deref(pos, e, FALSE, errPTR);
			CODE.Cmd_Add(CODE.opSUBR, PARS.program.target.word);
			CODE.Load(PARS.program.target.word)
		END;

		PARS.checklex(parser, SCAN.lxOF);
		PARS.Next(parser);
		ParseCase(parser, e, pos)
	END CaseStatement;

PROCEDURE ForStatement (parser: PARS.PARSER);
	VAR
		e:       PARS.EXPR;
		pos:     SCAN.POSITION;
		step:    ARITH.tValue;
		st:      INTEGER;
		ident:   PROG.IDENT;
		offset:  INTEGER;
		L1, L2:  INTEGER;

	BEGIN
		L1 := CODE.Label_New();
		L2 := CODE.Label_New();

		PARS.ExpectSym(parser, SCAN.lxIDENT);
		ident := parser.unit.idents.get(parser.unit, parser.lex.ident, TRUE);
		PARS.check1(ident # NIL, parser, 48);
		PARS.check1(ident.typ = PROG.idVAR, parser, 93);
		PARS.check1(ident.type.typ = PROG.tINTEGER, parser, 97);

		offset := PROG.getOffset(PARS.program, ident);

		IF ident.global THEN
			CODE.Cmd_Add(mConst.codeGADR, offset)
		ELSE
			CODE.Cmd_Add(CODE.opLADR, -offset)
		END;

		PARS.ExpectSym(parser, SCAN.lxASSIGN);
		NextPos(parser, pos);
		expression(parser, e);
		PARS.check(isInt(e), parser, pos, 76);

		ASSERT(assign(e, ident.type, 0));

		CODE.Label_Set(L1);

		IF ident.global THEN
			CODE.Cmd_Add(mConst.codeGADR, offset)
		ELSE
			CODE.Cmd_Add(CODE.opLADR, -offset)
		END;
		CODE.Load(ident.type.size);

		PARS.checklex(parser, SCAN.lxTO);
		NextPos(parser, pos);
		expression(parser, e);
		PARS.check(isInt(e), parser, pos, 76);

		IF parser.sym = SCAN.lxBY THEN
			NextPos(parser, pos);
			PARS.ConstExpression(parser, step);
			PARS.check(step.typ = mConst.typeInteger, parser, pos, 76);
			st := ARITH.Int_Get(step);
			PARS.check(st # 0, parser, pos, 98)
		ELSE
			st := 1
		END;

		IF e.obj = eCONST THEN
			IF st > 0 THEN
				CODE.Cmd_Add(CODE.opLER, ARITH.Int(e.value))
			ELSE
				CODE.Cmd_Add(CODE.opGER, ARITH.Int(e.value))
			END
		ELSE
			IF st > 0 THEN
				CODE.Cmd0_Add(CODE.opLE)
			ELSE
				CODE.Cmd0_Add(CODE.opGE)
			END
		END;

		CODE.CmdJmp_Add(CODE.opJNE, L2);

		PARS.checklex(parser, SCAN.lxDO);
		PARS.Next(parser);
		parser.StatSeq(parser);

		IF ident.global THEN
			CODE.Cmd_Add(mConst.codeGADR, offset)
		ELSE
			CODE.Cmd_Add(CODE.opLADR, -offset)
		END;

		IF st = 1 THEN
			CODE.Cmd0_Add(CODE.opINC1)
		ELSIF st = -1 THEN
			CODE.Cmd0_Add(CODE.opDEC1)
		ELSE
			IF st > 0 THEN
				CODE.Cmd_Add(CODE.opINCC, st)
			ELSE
				CODE.Cmd_Add(CODE.opDECC, -st)
			END
		END;

		CODE.CmdJmp_Add(mConst.codeJMP, L1);

		PARS.checklex(parser, SCAN.lxEND);
		PARS.Next(parser);

		CODE.Label_Set(L2);

	END ForStatement;

PROCEDURE statement (parser: PARS.PARSER);
	VAR
		sym: INTEGER;

	BEGIN
		sym := parser.sym;

		IF sym = SCAN.lxIDENT THEN
			ElementaryStatement(parser)
		ELSIF sym = SCAN.lxIF THEN
			IfStatement(parser, TRUE)
		ELSIF sym = SCAN.lxWHILE THEN
			IfStatement(parser, FALSE)
		ELSIF sym = SCAN.lxREPEAT THEN
			RepeatStatement(parser)
		ELSIF sym = SCAN.lxCASE THEN
			CaseStatement(parser)
		ELSIF sym = SCAN.lxFOR THEN
			ForStatement(parser)
		END
	END statement;

PROCEDURE StatSeq (parser: PARS.PARSER);
	BEGIN
		statement(parser);
		WHILE parser.sym = SCAN.lxSEMI DO
			PARS.Next(parser);
			statement(parser)
		END
	END StatSeq;

PROCEDURE chkreturn (parser: PARS.PARSER; e: PARS.EXPR; t: PROG.TYPE_; pos: SCAN.POSITION): BOOLEAN;
	VAR
		res: BOOLEAN;

	BEGIN
		res := assigncomp(e, t);
		IF res THEN
			IF e.obj = eCONST THEN
				IF e.type.typ = PROG.typeReal THEN
					CODE.Float(ARITH.Float_Get(e.value))
				ELSIF e.type.typ = PROG.tNIL THEN
					CODE.Cmd_Add(mConst.codeCONST, 0)
				ELSE
					LoadConst(e)
				END
			ELSIF (e.type.typ = PROG.tINTEGER) & (t.typ = PROG.tBYTE) & (chkBYTE IN checking) THEN
				CheckRange(256, pos.line, errBYTE)
			ELSIF e.obj = ePROC THEN
				PARS.check(e.ident.global, parser, pos, 85);
				CODE.Proc_Push(e.ident.proc.label)
			ELSIF e.obj = eIMP THEN
				CODE.ProcImp_Push(e.ident.import)
			END;

			IF e.type.typ = PROG.typeReal THEN
				CODE.retf
			END
		END

		RETURN res
	END chkreturn;

PROCEDURE setrtl;
	VAR
		rtl: PROG.UNIT;


		PROCEDURE getproc (rtl: PROG.UNIT; name: SCAN.LEXSTR; idx: INTEGER);
		VAR
			id:    PROG.IDENT;

		BEGIN
			id := rtl.idents.get(rtl, SCAN.enterid(name), FALSE);

			IF (id # NIL) & (id.import # NIL) THEN
				CODE.codes.rtl[idx] := -id.import(CODE.tpProcImport).label;
				id.proc.used := TRUE
			ELSIF (id # NIL) & (id.proc # NIL) THEN
				CODE.codes.rtl[idx] := id.proc.label;
				id.proc.used := TRUE
			ELSE
				ERRORS.Error3("procedure RTL.", name, " not found")
			END
		END getproc;


	BEGIN
		rtl := PARS.program.rtl;
		ASSERT(rtl # NIL);

		getproc(rtl,  "_move",      CODE._move);
		getproc(rtl,  "_move2",     CODE._move2);
		getproc(rtl,  "_in",        CODE._in);
		getproc(rtl,  "_in2",       CODE._in2);
		getproc(rtl,  "_set",       CODE._set);
		getproc(rtl,  "_set2",      CODE._set2);
		getproc(rtl,  "_incl",      CODE._incl);
		getproc(rtl,  "_excl",      CODE._excl);
		getproc(rtl,  "_div",       CODE._div);
		getproc(rtl,  "_mod",       CODE._mod);
		getproc(rtl,  "_div2",      CODE._div2);
		getproc(rtl,  "_mod2",      CODE._mod2);
		getproc(rtl,  "_arrcpy",    CODE._arrcpy);
		getproc(rtl,  "_rot",       CODE._rot);
		getproc(rtl,  "_new",       CODE._new);
		getproc(rtl,  "_dispose",   CODE._dispose);
		getproc(rtl,  "_strcmp",    CODE._strcmp);
		getproc(rtl,  "_error",     CODE._error);
		getproc(rtl,  "_is",        CODE._is);
		getproc(rtl,  "_isrec",     CODE._isrec);
		getproc(rtl,  "_guard",     CODE._guard);
		getproc(rtl,  "_guardrec",  CODE._guardrec);
		getproc(rtl,  "_length",    CODE._length);
		getproc(rtl,  "_init",      CODE._init);
		getproc(rtl,  "_dllentry",  CODE._dllentry);
		getproc(rtl,  "_strcpy",    CODE._strcpy);
		getproc(rtl,  "_exit",      CODE._exit);
		getproc(rtl,  "_strcpy2",   CODE._strcpy2);
		getproc(rtl,  "_lengthw",   CODE._lengthw);
		getproc(rtl,  "_strcmp2",   CODE._strcmp2);
		getproc(rtl,  "_strcmpw",   CODE._strcmpw);
		getproc(rtl,  "_strcmpw2",  CODE._strcmpw2);

	END setrtl;

PROCEDURE compile* (path, lib_path, modname, outname, ext: PARS.tPath; target, version, stack, base: INTEGER; pic, reloc: BOOLEAN; chk: SET);
	VAR
		parser:  PARS.PARSER;
	BEGIN
		CaseLabels := C.New();
		CaseVar := C.New();

		CaseVariants := LISTS.New(NIL);
		LISTS.Add(CaseVariants, NewVariant(0, NIL));

		checking := chk;
		CODE.Init;

		parser := PARS.create(path, lib_path, ext, StatSeq, expression, designator, chkreturn);
		IF parser.open(parser, "RTL") THEN
			parser.parse(parser);
			PARS.destroy(parser)
		ELSE
			PARS.destroy(parser);
			parser := PARS.create(lib_path, lib_path, ext, StatSeq, expression, designator, chkreturn);
			IF parser.open(parser, "RTL") THEN
				parser.parse(parser);
				PARS.destroy(parser)
			ELSE
				ERRORS.Error5("file ", lib_path, "RTL", ext, " not found")
			END
		END;

		parser := PARS.create(path, lib_path, ext, StatSeq, expression, designator, chkreturn);
		parser.main := TRUE;

		IF parser.open(parser, modname) THEN
			parser.parse(parser)
		ELSE
			ERRORS.Error5("file ", path, modname, ext, " not found")
		END;

		PARS.destroy(parser);

		setrtl;

		PROG.DelUnused(PARS.program, CODE.Import_Del);

		CODE.codes.bss := PARS.program.bss;
		IF target = mConst.Target_iWin64 THEN
			AMD64.CodeGen(CODE.codes, outname, target, stack, base, version, pic, reloc)
		ELSE
			X86.CodeGen(CODE.codes, outname, target, stack, base, version, pic, reloc)
		END
	END compile;

END STATEMENTS.
