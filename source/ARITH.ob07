MODULE ARITH;
(*
	BSD 2-Clause License

	Copyright (c) 2018, Anton Krotov
	All rights reserved.
	*)

IMPORT mAt := AVLTREES,
	mStr := STRINGS,
	mMach := MACHINE,
	mConst := modConstante;

TYPE
	tRelation* = ARRAY 3 OF CHAR;

	tValue* = RECORD
			typ*:      INTEGER;
			int:       INTEGER;
			float:     REAL;
			set:       SET;
			bool:      BOOLEAN;
			string*:   mAt.tpData
		END;

VAR

	digit: ARRAY 256 OF INTEGER;

PROCEDURE Int* (pVal: tValue): INTEGER;
	VAR
		res: INTEGER;
	BEGIN
		IF pVal.typ = mConst.typeInteger THEN
			res := pVal.int
		ELSIF pVal.typ = mConst.typeChar THEN
			res := pVal.int
		ELSIF pVal.typ = mConst.typeWChar THEN
			res := pVal.int
		ELSIF pVal.typ = mConst.typeSet THEN
			res := ORD(pVal.set);
			IF mMach.b64to32 THEN
				res := mMach.Int32To64(res)
			END
		ELSIF pVal.typ = mConst.typeBoolean THEN
			res := ORD(pVal.bool)
		END

		RETURN res
	END Int;

PROCEDURE Bool_Get* (pVal: tValue): BOOLEAN;
	BEGIN
		ASSERT(pVal.typ = mConst.typeBoolean);

		RETURN pVal.bool
	END Bool_Get;

PROCEDURE Float_Get* (pVal: tValue): REAL;
	BEGIN
		ASSERT(pVal.typ = mConst.typeReal);

		RETURN pVal.float
	END Float_Get;

PROCEDURE Check* (pVal: tValue): BOOLEAN;
	VAR
		_bError: BOOLEAN;
	BEGIN
		_bError := FALSE;

		IF (pVal.typ = mConst.typeInteger) & ((pVal.int < mMach.target.minInt) OR (pVal.int > mMach.target.maxInt)) THEN
			_bError := TRUE
		ELSIF (pVal.typ = mConst.typeChar) & ((pVal.int < 0) OR (pVal.int > 255)) THEN
			_bError := TRUE
		ELSIF (pVal.typ = mConst.typeWChar) & ((pVal.int < 0) OR (pVal.int > 65535)) THEN
			_bError := TRUE
		ELSIF (pVal.typ = mConst.typeReal) & ((pVal.float < -mMach.target.maxReal) OR (pVal.float > mMach.target.maxReal)) THEN
			_bError := TRUE
		END

		RETURN ~_bError
	END Check;

PROCEDURE IsZero* (pVal: tValue): BOOLEAN;
	VAR
		_bRes: BOOLEAN;
	BEGIN
		ASSERT(pVal.typ IN {mConst.typeInteger, mConst.typeReal});

		IF pVal.typ = mConst.typeInteger THEN
			_bRes := pVal.int = 0
		ELSIF pVal.typ = mConst.typeReal THEN
			_bRes := pVal.float = 0.0
		END

		RETURN _bRes
	END IsZero;

PROCEDURE Int_Convert* (s: ARRAY OF CHAR; VAR pVal: tValue; VAR pError: INTEGER);
	VAR
		_val: INTEGER;
		_i:   INTEGER;
		d:    INTEGER;
	BEGIN
		pError := 0;
		_val := 0;

		_i := 0;
		WHILE mStr.digit(s[_i]) & (pError = 0) DO
			d := digit[ORD(s[_i])];
			IF _val <= (mMach.native.maxInt - d) DIV 10 THEN
				_val := _val * 10 + d;
				INC(_i)
			ELSE
				pError := 1
			END
		END;

		IF pError = 0 THEN
			pVal.int := _val;
			pVal.typ := mConst.typeInteger;
			IF ~Check(pVal) THEN
				pError := 1
			END
		END
	END Int_Convert;

PROCEDURE Hex_Convert* (s: ARRAY OF CHAR; VAR pVal: tValue; VAR pError: INTEGER);
	VAR
		_val: INTEGER;
		_i:     INTEGER;
		n:     INTEGER;
		d:     INTEGER;
	BEGIN
		ASSERT(mStr.digit(s[0]));

		pError := 0;
		_val := 0;

		n := -1;
		_i := 0;
		WHILE (s[_i] # "H") & (s[_i] # "X") & (pError = 0) DO

			d := digit[ORD(s[_i])];
			IF (n = -1) & (d # 0) THEN
				n := _i
			END;

			IF (n # -1) & (_i - n + 1 > mMach.target.maxHex) THEN
				pError := 2
			ELSE
				_val := _val * 16 + d;
				INC(_i)
			END

		END;

		IF mMach.b64to32 THEN
			_val := mMach.Int32To64(_val);
		END;

		IF (s[_i] = "X") & (n # -1) & (_i - n > 4) THEN
			pError := 3
		END;

		IF pError = 0 THEN
			pVal.int := _val;
			IF s[_i] = "X" THEN
				pVal.typ := mConst.typeChar;
				IF ~Check(pVal) THEN
					pVal.typ := mConst.typeWChar;
					IF ~Check(pVal) THEN
						pError := 3
					END
				END
			ELSE
				pVal.typ := mConst.typeInteger;
				IF ~Check(pVal) THEN
					pError := 2
				END
			END
		END

	END Hex_Convert;

PROCEDURE IsOpFloat2 (VAR pA: REAL; pB: REAL; pOp: CHAR): BOOLEAN;
	VAR
		_max: REAL;
		_bRes: BOOLEAN;
	BEGIN
		_max := mMach.native.maxReal;

		CASE pOp OF
		|"+":
			IF (pA < 0.0) & (pB < 0.0) THEN
				_bRes := pA > -_max - pB
			ELSIF (pA > 0.0) & (pB > 0.0) THEN
				_bRes := pA <  _max - pB
			ELSE
				_bRes := TRUE
			END;
			IF _bRes THEN
				pA := pA + pB
			END
		|"-":
			IF (pA < 0.0) & (pB > 0.0) THEN
				_bRes := pA > pB - _max
			ELSIF (pA > 0.0) & (pB < 0.0) THEN
				_bRes := pA < pB + _max
			ELSE
				_bRes := TRUE
			END;
			IF _bRes THEN
				pA := pA - pB
			END
		|"*":
			IF (ABS(pA) > 1.0) & (ABS(pB) > 1.0) THEN
				_bRes := ABS(pA) < _max / ABS(pB)
			ELSE
				_bRes := TRUE
			END;
			IF _bRes THEN
				pA := pA * pB
			END
		|"/":
			IF ABS(pB) < 1.0 THEN
				_bRes := ABS(pA) < _max * ABS(pB)
			ELSE
				_bRes := TRUE
			END;
			IF _bRes THEN
				pA := pA / pB
			END
		END
		RETURN _bRes
	END IsOpFloat2;

PROCEDURE Float_Convert* (s: ARRAY OF CHAR; VAR pVal: tValue; VAR pError: INTEGER);
	VAR
		_val:    REAL;
		exp10:    REAL;
		_i, n, d:  INTEGER;
		minus:    BOOLEAN;

	BEGIN
		pError := 0;
		_val := 0.0;
		exp10 := 10.0;
		minus := FALSE;
		n := 0;

		_i := 0;
		WHILE (pError = 0) & mStr.digit(s[_i]) DO
			IF IsOpFloat2(_val, 10.0, "*") & IsOpFloat2(_val, FLT(digit[ORD(s[_i])]), "+") THEN
				INC(_i)
			ELSE
				pError := 4
			END
		END;

		INC(_i);

		WHILE (pError = 0) & mStr.digit(s[_i]) DO
			IF IsOpFloat2(_val, FLT(digit[ORD(s[_i])]) / exp10, "+") & IsOpFloat2(exp10, 10.0, "*") THEN
				INC(_i)
			ELSE
				pError := 4
			END
		END;

		IF s[_i] = "E" THEN
			INC(_i)
		END;

		IF (s[_i] = "-") OR (s[_i] = "+") THEN
			minus := s[_i] = "-";
			INC(_i)
		END;

		WHILE (pError = 0) & mStr.digit(s[_i]) DO
			d := digit[ORD(s[_i])];
			IF n <= (mMach.native.maxInt - d) DIV 10 THEN
				n := n * 10 + d;
				INC(_i)
			ELSE
				pError := 5
			END
		END;

		exp10 := 1.0;
		WHILE (pError = 0) & (n > 0) DO
			IF IsOpFloat2(exp10, 10.0, "*") THEN
				DEC(n)
			ELSE
				pError := 4
			END
		END;

		IF pError = 0 THEN
			IF minus THEN
				IF ~IsOpFloat2(_val, exp10, "/") THEN
					pError := 4
				END
			ELSE
				IF ~IsOpFloat2(_val, exp10, "*") THEN
					pError := 4
				END
			END
		END;

		IF pError = 0 THEN
			pVal.float := _val;
			pVal.typ := mConst.typeReal;
			IF ~Check(pVal) THEN
				pError := 4
			END
		END

	END Float_Convert;

PROCEDURE Char_Set* (VAR pVal: tValue; pOrd: INTEGER);
	BEGIN
		pVal.typ := mConst.typeChar;
		pVal.int := pOrd
	END Char_Set;

PROCEDURE WChar_Set* (VAR pVal: tValue; pOrd: INTEGER);
	BEGIN
		pVal.typ := mConst.typeWChar;
		pVal.int := pOrd
	END WChar_Set;

PROCEDURE Int_Add (VAR pA: INTEGER; pB: INTEGER): BOOLEAN;
	VAR
		_bError: BOOLEAN;
	BEGIN
		IF (pA > 0) & (pB > 0) THEN
			_bError := pA > mMach.native.maxInt - pB
		ELSIF (pA < 0) & (pB < 0) THEN
			_bError := pA < mMach.native.minInt - pB
		ELSE
			_bError := FALSE
		END;

		IF ~_bError THEN
			pA := pA + pB
		ELSE
			pA := 0
		END

		RETURN ~_bError
	END Int_Add;

PROCEDURE Int_Sub (VAR pA: INTEGER; pB: INTEGER): BOOLEAN;
	VAR
		_bError: BOOLEAN;
	BEGIN
		IF (pA > 0) & (pB < 0) THEN
			_bError := pA > mMach.native.maxInt + pB
		ELSIF (pA < 0) & (pB > 0) THEN
			_bError := pA < mMach.native.minInt + pB
		ELSIF (pA = 0) & (pB < 0) THEN
			_bError := pB = mMach.native.minInt
		ELSE
			_bError := FALSE
		END;

		IF ~_bError THEN
			pA := pA - pB
		ELSE
			pA := 0
		END

		RETURN ~_bError
	END Int_Sub;

PROCEDURE Lg2_Get (pNum: INTEGER): INTEGER;
	VAR
		_num: INTEGER;
	BEGIN
		ASSERT(pNum > 0);

		_num := 0;
		WHILE ~ODD(pNum) DO
			pNum := pNum DIV 2;
			INC(_num)
		END;

		IF pNum # 1 THEN
			_num := 255
		END

		RETURN _num
	END Lg2_Get;

PROCEDURE Int_Mul* (VAR pA: INTEGER; pB: INTEGER): BOOLEAN;
	VAR
		_bError:    BOOLEAN;
		_min, _max: INTEGER;
	BEGIN
		_min := mMach.native.minInt;
		_max := mMach.native.maxInt;

		IF ((pA > 1) & (pB > 1)) OR ((pA < 0) & (pB < 0)) THEN
			_bError := (pA = _min) OR (pB = _min) OR (ABS(pA) > _max DIV ABS(pB))

		ELSIF ((pA > 1) & (pB < 0)) OR ((pA < 0) & (pB > 1)) THEN
			_bError := (pA = _min) OR (pB = _min);
			IF ~_bError THEN
				IF Lg2_Get(ABS(pA)) + Lg2_Get(ABS(pB)) >= mMach.native.bit_depth THEN
					_bError := ABS(pA) > _max DIV ABS(pB)
				END
			END

		ELSE
			_bError := FALSE
		END;

		IF ~_bError THEN
			pA := pA * pB
		ELSE
			pA := 0
		END

		RETURN ~_bError
	END Int_Mul;

PROCEDURE ASR_Get (pNum, pBit: INTEGER): INTEGER;
	BEGIN
		IF mMach.b64to32 THEN
			pNum := mMach.Int32To64(pNum)
		END

		RETURN ASR(pNum, pBit)
	END ASR_Get;

PROCEDURE LSR_Get (pNum, pBit: INTEGER): INTEGER;
	BEGIN
		IF mMach.b64to32 THEN
			pNum := mMach.Int64To32(pNum);
			pNum := LSR(pNum, pBit);
			pNum := mMach.Int32To64(pNum)
		ELSE
			pNum := LSR(pNum, pBit)
		END

		RETURN pNum
	END LSR_Get;

PROCEDURE LSL_Get (pNum, pBit: INTEGER): INTEGER;
	BEGIN
		pNum := LSL(pNum, pBit);
		IF mMach.b64to32 THEN
			pNum := mMach.Int32To64(pNum)
		END

		RETURN pNum
	END LSL_Get;

PROCEDURE ROR1_32_Get (pNum: INTEGER): INTEGER;
	BEGIN
		pNum := mMach.Int64To32(pNum);
		pNum := ORD(BITS(LSR(pNum, 1)) + BITS(LSL(pNum, 31)))
		RETURN mMach.Int32To64(pNum)
	END ROR1_32_Get;

PROCEDURE ROR_Get (pNum, pBit: INTEGER): INTEGER;
	BEGIN
		IF mMach.b64to32 THEN
			pBit := pBit MOD 32;
			WHILE pBit > 0 DO
				pNum := ROR1_32_Get(pNum);
				DEC(pBit)
			END
		ELSE
			pNum := ROR(pNum, pBit)
		END

		RETURN pNum
	END ROR_Get;

PROCEDURE IsOpInt* (VAR pA: tValue; pB: tValue; pOp: CHAR): BOOLEAN;
	VAR
		_bSuccess: BOOLEAN;
	BEGIN
		_bSuccess := TRUE;

		CASE pOp OF
		|"+": _bSuccess := Int_Add(pA.int, pB.int)
		|"-": _bSuccess := Int_Sub(pA.int, pB.int)
		|"*": _bSuccess := Int_Mul(pA.int, pB.int)
		|"/": _bSuccess := FALSE
		|"D": IF (pB.int # -1) OR (pA.int # mMach.native.minInt) THEN pA.int := pA.int DIV pB.int ELSE _bSuccess := FALSE END
		|"M": pA.int := pA.int MOD pB.int
		|"L": pA.int := LSL_Get(pA.int, pB.int)
		|"A": pA.int := ASR_Get(pA.int, pB.int)
		|"O": pA.int := ROR_Get(pA.int, pB.int)
		|"R": pA.int := LSR_Get(pA.int, pB.int)
		|"m": pA.int := MIN(pA.int, pB.int)
		|"x": pA.int := MAX(pA.int, pB.int)
		END;
		pA.typ := mConst.typeInteger

		RETURN _bSuccess & Check(pA)
	END IsOpInt;

PROCEDURE CharToStr* (c: tValue; VAR s: ARRAY OF CHAR);
	BEGIN
		s[0] := CHR(c.int);
		s[1] := 0X
	END CharToStr;

PROCEDURE OpSet_Set* (VAR pA: tValue; pB: tValue; pOp: CHAR);
	BEGIN
		CASE pOp OF
		|"+": pA.set := pA.set + pB.set
		|"-": pA.set := pA.set - pB.set
		|"*": pA.set := pA.set * pB.set
		|"/": pA.set := pA.set / pB.set
		END;
		pA.typ := mConst.typeSet
	END OpSet_Set;

PROCEDURE IsOpFloat* (VAR pA: tValue; pB: tValue; pOp: CHAR): BOOLEAN;
	BEGIN
		pA.typ := mConst.typeReal
		RETURN IsOpFloat2(pA.float, pB.float, pOp) & Check(pA)
	END IsOpFloat;

PROCEDURE Ord_Set* (VAR pVal: tValue);
	BEGIN
		CASE pVal.typ OF
		|mConst.typeChar, mConst.typeWChar:
		|mConst.typeBoolean: pVal.int := ORD(pVal.bool)
		|mConst.typeSet:
			pVal.int := ORD(pVal.set);
			IF mMach.b64to32 THEN
				pVal.int := mMach.Int32To64(pVal.int)
			END
		END;
		pVal.typ := mConst.typeInteger
	END Ord_Set;

PROCEDURE Odd_Set* (VAR pVal: tValue);
	BEGIN
		pVal.typ := mConst.typeBoolean;
		pVal.bool := ODD(pVal.int)
	END Odd_Set;

PROCEDURE Bits_Set* (VAR pVal: tValue);
	BEGIN
		pVal.typ := mConst.typeSet;
		pVal.set := BITS(pVal.int)
	END Bits_Set;

PROCEDURE Abs_Set* (VAR pVal: tValue);
	BEGIN
		CASE pVal.typ OF
		|mConst.typeReal:    pVal.float := ABS(pVal.float)
		|mConst.typeInteger: pVal.int := ABS(pVal.int)
		END
	END Abs_Set;

PROCEDURE IsFloor* (VAR pVal: tValue): BOOLEAN;
	VAR
		_bRes: BOOLEAN;
	BEGIN
		pVal.typ := mConst.typeInteger;
		_bRes := (FLT(mMach.native.minInt) <= pVal.float) & (pVal.float <= FLT(mMach.native.maxInt));
		IF _bRes THEN
			pVal.int := FLOOR(pVal.float)
		END

		RETURN _bRes
	END IsFloor;

PROCEDURE Float_Set* (VAR pVal: tValue);
	BEGIN
		pVal.typ := mConst.typeReal;
		pVal.float := FLT(pVal.int)
	END Float_Set;


PROCEDURE IsNeg* (VAR pVal: tValue): BOOLEAN;
	VAR
		z: tValue;
		_bRes: BOOLEAN;

	BEGIN
		_bRes := TRUE;

		z.typ := mConst.typeInteger;
		z.int := 0;

		CASE pVal.typ OF
		|mConst.typeReal:     pVal.float := -pVal.float
		|mConst.typeSet:      pVal.set := -pVal.set
		|mConst.typeInteger:  _bRes := IsOpInt(z, pVal, "-"); pVal := z
		|mConst.typeBoolean:  pVal.bool := ~pVal.bool
		END

		RETURN _bRes
	END IsNeg;


PROCEDURE setbool* (VAR pVal: tValue; pB: BOOLEAN);
BEGIN
	pVal.bool := pB;
	pVal.typ := mConst.typeBoolean
END setbool;


PROCEDURE opBoolean* (VAR pA: tValue; pB: tValue; pOp: CHAR);
BEGIN
	CASE pOp OF
	|"&": pA.bool := pA.bool & pB.bool
	|"|": pA.bool := pA.bool OR pB.bool
	END;
	pA.typ := mConst.typeBoolean
END opBoolean;


PROCEDURE range* (i: tValue; pA, pB: INTEGER): BOOLEAN;
	RETURN (pA <= i.int) & (i.int <= pB)
END range;


PROCEDURE less (pVal, v2: tValue; VAR error: INTEGER): BOOLEAN;
VAR
	_bRes: BOOLEAN;

BEGIN
	_bRes := FALSE;

	IF (pVal.typ = v2.typ) OR (pVal.typ IN {mConst.typeChar, mConst.typeWChar}) & (v2.typ IN {mConst.typeChar, mConst.typeWChar}) THEN
		CASE pVal.typ OF
		|mConst.typeInteger,
		 mConst.typeWChar,
		 mConst.typeChar:     _bRes := pVal.int < v2.int
		|mConst.typeReal:     _bRes := pVal.float < v2.float
		|mConst.typeBoolean,
		 mConst.typeSet:      error := 1
		END
	ELSE
		error := 1
	END

	RETURN _bRes
END less;

PROCEDURE equal (pVal, v2: tValue; VAR error: INTEGER): BOOLEAN;
VAR
	_bRes: BOOLEAN;

BEGIN
	_bRes := FALSE;

	IF (pVal.typ = v2.typ) OR (pVal.typ IN {mConst.typeChar, mConst.typeWChar}) & (v2.typ IN {mConst.typeChar, mConst.typeWChar}) THEN
		CASE pVal.typ OF
		|mConst.typeInteger,
		 mConst.typeWChar,
		 mConst.typeChar:     _bRes := pVal.int = v2.int
		|mConst.typeReal:     _bRes := pVal.float = v2.float
		|mConst.typeBoolean:  _bRes := pVal.bool = v2.bool
		|mConst.typeSet:      _bRes := pVal.set = v2.set
		END
	ELSE
		error := 1
	END

	RETURN _bRes
END equal;


PROCEDURE relation* (VAR pVal: tValue; v2: tValue; operator: tRelation; VAR error: INTEGER);
VAR
	_bRes: BOOLEAN;

BEGIN
	error := 0;

	_bRes := FALSE;

	CASE operator[0] OF

	|"=":
		_bRes := equal(pVal, v2, error)

	|"#":
		_bRes := ~equal(pVal, v2, error)

	|"<":
		IF operator[1] = "=" THEN
			_bRes := less(pVal, v2, error);
			IF error = 0 THEN
				_bRes := equal(pVal, v2, error) OR _bRes
			END
		ELSE
			_bRes := less(pVal, v2, error)
		END

	|">":
		IF operator[1] = "=" THEN
			_bRes := ~less(pVal, v2, error)
		ELSE
			_bRes := less(pVal, v2, error);
			IF error = 0 THEN
				_bRes := equal(pVal, v2, error) OR _bRes
			END;
			_bRes := ~_bRes
		END

	|"I":
		IF (pVal.typ = mConst.typeInteger) & (v2.typ = mConst.typeSet) THEN
			IF range(pVal, 0, mMach.target.maxSet) THEN
				_bRes := pVal.int IN v2.set
			ELSE
				error := 2
			END
		ELSE
			error := 1
		END

	END;

	IF error = 0 THEN
		pVal.bool := _bRes;
		pVal.typ  := mConst.typeBoolean
	END

END relation;


PROCEDURE emptySet* (VAR pVal: tValue);
BEGIN
	pVal.typ := mConst.typeSet;
	pVal.set := {}
END emptySet;


PROCEDURE constrSet* (VAR pVal: tValue; pA, pB: tValue);
BEGIN
	pVal.typ := mConst.typeSet;
	pVal.set := {pA.int .. pB.int}
END constrSet;


PROCEDURE getInt* (pVal: tValue): INTEGER;
BEGIN
	ASSERT(Check(pVal))

	RETURN pVal.int
END getInt;


PROCEDURE setInt* (VAR pVal: tValue; i: INTEGER): BOOLEAN;
BEGIN
	pVal.int := i;
	pVal.typ := mConst.typeInteger

	RETURN Check(pVal)
END setInt;


PROCEDURE init;
VAR
	i: INTEGER;

BEGIN
	FOR i := 0 TO LEN(digit) - 1 DO
		digit[i] := -1
	END;

	FOR i := ORD("0") TO ORD("9") DO
		digit[i] := i - ORD("0")
	END;

	FOR i := ORD("A") TO ORD("F") DO
		digit[i] := i - ORD("A") + 10
	END
END init;


BEGIN
	init
END ARITH.
