        Компилятор языка программирования Oberon-07/16 для MSP430.
------------------------------------------------------------------------------

        Параметры командной строки

  Вход - текстовые файлы модулей с расширением ".ob07", кодировка ANSI или
UTF-8 с BOM-сигнатурой.
  Выход - испоняемый файл hex-формата.
  Параметры:
  1) имя главного модуля
  2) имя результирующего файла
  3) "msp430"
  4) необязательные параметры-ключи
      -ram <size> размер ОЗУ в байтах (128 - 2048) по умолчанию 128
      -rom <size> размер ПЗУ в байтах (4096 - 49152) по умолчанию 4096
      -nochk <"ptibcwra"> отключить проверки при выполнении

      параметр -nochk задается в виде строки из символов:
      "p" - указатели
      "t" - типы
      "i" - индексы
      "b" - неявное приведение INTEGER к BYTE
      "c" - диапазон аргумента функции CHR
      "a" - все проверки

      Порядок символов может быть любым. Наличие в строке того или иного
      символа отключает соответствующую проверку.

      Например: -nochk it - отключить проверку индексов и охрану типа.
      -nochk a - отключить все отключаемые проверки.

  Например:

  Compiler.exe "C:\example.ob07" "C:\example.hex" msp430 -ram 128 -rom 4096 -nochk pti
  Compiler.exe "C:\example.ob07" "C:\example.hex" msp430 -ram 512 -rom 16384

  В случае успешной компиляции, компилятор передает код завершения 0, иначе 1.
При работе компилятора в KolibriOS, код завершения не передается.

------------------------------------------------------------------------------
        Отличия от оригинала

 1.     Расширен псевдомодуль SYSTEM
 2.     В идентификаторах допускается символ "_"
 3.     Усовершенствован оператор CASE (добавлены константные выражения в
        метках вариантов и необязательная ветка ELSE)
 4.     Расширен набор стандартных процедур
 5.     Семантика охраны/проверки типа уточнена для нулевого указателя
 6.     Добавлены однострочные комментарии (начинаются с пары символов "//")
 7.     Разрешено наследование от типа-указателя
 8.     "Строки" можно заключать также в одиночные кавычки: 'строка'
 9.     Добавлены кодовые процедуры
10.     Не реализована вещественная арифметика

------------------------------------------------------------------------------
        Особенности реализации

1.      Основные типы

          Тип              Диапазон значений               Размер, байт

        INTEGER       -32768 .. 32767                           2
        CHAR          символ ASCII (0X .. 0FFX)                 1
        BOOLEAN       FALSE, TRUE                               1
        SET           множество из целых чисел {0 .. 15}        2
        BYTE          0 .. 255                                  1

2.      Максимальная длина идентификаторов - 1024 символов
3.      Максимальная длина строковых констант - 1024 символов (UTF-8)
4.      Максимальная размерность открытых массивов - 5
5.      Процедура NEW заполняет нулями выделенный блок памяти
6.      Глобальные и локальные переменные инициализируются нулями
7.      В отличие от многих Oberon-реализаций, сборщик мусора и динамическая
        модульность отсутствуют
8.      Тип BYTE в выражениях всегда приводится к INTEGER
9.      Контроль переполнения значений выражений не производится
10.     Ошибки времени выполнения:

номер    ошибка

 1       ASSERT(x), при x = FALSE
 2       разыменование нулевого указателя
 3       целочисленное деление на 0 или на отрицательное число
 4       вызов процедуры через процедурную переменную с нулевым значением
 5       ошибка охраны типа
 6       нарушение границ массива
 7       непредусмотренное значение выражения в операторе CASE
 8       ошибка копирования массивов v := x, если LEN(v) < LEN(x)
 9       CHR(x), если (x < 0) OR (x > 255)
11       неявное приведение x:INTEGER к v:BYTE, если (x < 0) OR (x > 255)

------------------------------------------------------------------------------
        Псевдомодуль SYSTEM

  Псевдомодуль SYSTEM содержит низкоуровневые и небезопасные процедуры,
ошибки при использовании процедур псевдомодуля SYSTEM могут привести к
повреждению данных времени выполнения и аварийному завершению программы.

        PROCEDURE ADR(v: любой тип): INTEGER
                v - переменная или процедура;
                возвращает адрес v

        PROCEDURE SADR(x: строковая константа (CHAR UTF-8)): INTEGER
                возвращает адрес x

        PROCEDURE SIZE(T): INTEGER
                возвращает размер типа T

        PROCEDURE TYPEID(T): INTEGER
                T - тип-запись или тип-указатель,
                возвращает номер типа в таблице типов-записей

        PROCEDURE GET(a: INTEGER;
                VAR v: любой основной тип, PROCEDURE, POINTER)
                v := Память[a]

        PROCEDURE PUT8(a: INTEGER; x: INTEGER, SET, BYTE, CHAR)
                Память[a] := младшие 8 бит (x)

        PROCEDURE PUT(a: INTEGER; x: любой основной тип, PROCEDURE, POINTER)
                Память[a] := x;
                Если x: BYTE, то значение x будет расширено до 16 бит,
                для записи байтов использовать SYSTEM.PUT8

        PROCEDURE MOVE(Source, Dest, n: INTEGER)
                Копирует n байт памяти из Source в Dest,
                области Source и Dest не могут перекрываться

        PROCEDURE CODE(word1, word2,... : INTEGER)
                Вставка машинного кода,
                word1, word2 ... - константы в диапазоне 0..65535,
                например:
                SYSTEM.CODE(0D032H, 0010H) (* BIS #16, SR; CPUOFF *)


  Функции псевдомодуля SYSTEM нельзя использовать в константных выражениях.

------------------------------------------------------------------------------
        Оператор CASE

  Синтаксис оператора CASE:

        CaseStatement =
                CASE Expression OF Сase {"|" Сase}
                        [ELSE StatementSequence] END.
        Case = [CaseLabelList ":" StatementSequence].
        CaseLabelList = CaseLabels {"," CaseLabels}.
        CaseLabels = ConstExpression [".." ConstExpression].

  Например:

        CASE x OF
        |-1:    DoSomething1
        | 1:    DoSomething2
        | 0:    DoSomething3
        ELSE
                DoSomething4
        END

  В метках вариантов можно использовать константные выражения, ветка ELSE
необязательна. Если значение x не соответствует ни одному варианту и ELSE
отсутствует, то программа прерывается с ошибкой времени выполнения.

------------------------------------------------------------------------------
        Проверка и охрана типа нулевого указателя

  Оригинальное сообщение о языке не определяет поведение программы при
выполнении охраны p(T) и проверки типа p IS T при p = NIL. Во многих
Oberon-реализациях выполнение такой операции приводит к ошибке времени
выполнения. В данной реализации охрана типа нулевого указателя не приводит к
ошибке, а проверка типа дает результат FALSE. В ряде случаев это позволяет
значительно сократить частоту применения охраны типа.

------------------------------------------------------------------------------
        Дополнительные стандартные процедуры


        COPY (x: ARRAY OF CHAR; VAR v: ARRAY OF CHAR);
                v := x;
                Если LEN(v) < LEN(x), то строка x будет скопирована
                не полностью

        LSR (x, n: INTEGER): INTEGER
                Логический сдвиг x на n бит вправо.

        MIN (a, b: INTEGER): INTEGER
                Минимум из двух значений.

        MAX (a, b: INTEGER): INTEGER
                Максимум из двух значений.

        BITS (x: INTEGER): SET
                Интерпретирует x как значение типа SET.
                Выполняется на этапе компиляции.

        LENGTH (s: ARRAY OF CHAR): INTEGER
                Длина 0X-завершенной строки s, без учета символа 0X.
                Если символ 0X отсутствует, функция возвращает длину
                массива s. s не может быть константой.

------------------------------------------------------------------------------
        Использование регистров общего назначения R4 - R15

        R4 - R7:  регистровый стэк (промежуточные значения выражений)
        R8 - R12: не используются
        R13:      используется при обработке прерываний
        R14:      указатель кучи
        R15:      указатель кадра стэка

------------------------------------------------------------------------------
        Вызов процедур и кадр стэка

  Правила вызова похожи на соглашение cdecl (x86):
  - параметры передаются через стэк справа налево
  - результат, если есть, передается через регистр R4
  - вызывающая процедура очищает стэк

  Состояние стэка при выполнении процедуры:

  меньшие адреса <- |var3|var2|var1|R15|PC|arg1|arg2|arg3| -> бОльшие адреса

  R15  - значение регистра R15 перед вызовом
  PC   - значение регистра PC перед вызовом (адрес возврата)
  argX - параметры в порядке объявления (слева направо)
  varX - локальные переменные в порядке использования в процедуре

  Размер каждого элемента в стэке - 1 машинное слово (2 байта).

  Адресация кадра стэка:
  0(R15)  - предыдущее значение регистра R15
  2(R15)  - адрес возврата
  4(R15)  - arg1
  6(R15)  - arg2
  -2(R15) - var1
  -4(R15) - var2

  Размещение локальных переменных зависит от порядка использования и
  в общем случае неопределенно. Если переменная не используется явно, то
  компилятор не выделяет для нее место в стэке.

  Пролог процедуры:
  PUSH R15     ; сохранить предыдущее значение
  MOV  SP, R15 ; настроить указатель кадра
  PUSH #0      ; выделить место для локальных переменных с обнулением
  PUSH #0
  ...

  Эпилог процедуры:
  MOV R15, SP  ; удалить локальные переменные
  POP R15      ; восстановить предыдущее значение
  RET          ; возврат

------------------------------------------------------------------------------
        Скрытые параметры процедур

  Некоторые процедуры могут иметь скрытые параметры, они отсутствуют в списке
формальных параметров, но учитываются компилятором при трансляции вызовов.
Это возможно в следующих случаях:

1.      Процедура имеет формальный параметр открытый массив:
                PROCEDURE Proc (x: ARRAY OF ARRAY OF REAL);
        Вызов транслируется так:
                Proc(LEN(x), LEN(x[0]), SYSTEM.ADR(x))
2.      Процедура имеет формальный параметр-переменную типа RECORD:
                PROCEDURE Proc (VAR x: Rec);
        Вызов транслируется так:
                Proc(SYSTEM.TYPEID(Rec), SYSTEM.ADR(x))

------------------------------------------------------------------------------
        Кодовые процедуры

  Компилятор поддерживает процедуры, написаные в машинных кодах.
  Синтаксис:

  PROCEDURE "[code]" имя [ (параметры): ТипРезультата ]
      МашСлово, МашСлово,... МашСлово;

  ";" после заголовка и END "имя" в конце процедуры не ставятся.
  МашСлово - целочисленная константа (в том числе и константное выражение).
  Например:

  PROCEDURE [code] _asr* (n, x: INTEGER): INTEGER
      4115H, 2,              (*  MOV  2(SP), R5; R5 <- n  *)
      4114H, 4,              (*  MOV  4(SP), R4; R4 <- x  *)
      0F035H, 15,            (*  AND  #15, R5             *)
      2400H + 3,             (*  JZ   L1                  *)
                             (*  L2:                      *)
      1104H,                 (*  RRA  R4                  *)
      8315H,                 (*  SUB  #1, R5              *)
      2000H + 400H - 3;      (*  JNZ  L2                  *)
                             (*  L1:                      *)

  Для таких процедур компилятор не генерирует код пролога. Эпилог состоит
из единственной машинной команды "MOV  @SP+, PC", она же "POP PC",
она же "RET". Способ передачи параметров и результата не изменяется.

  Кодовые процедуры можно использовать также и для добавления в программу
константных данных:

  PROCEDURE [code] sqr
      0, 1, 4, 9, 16, 25, 36, 49, 64, 81;

  Получить адрес такой "процедуры": SYSTEM.ADR(sqr).
  Получить адрес n-го машинного слова: SYSTEM.ADR(sqr) + n * 2.

  Чтобы использовать кодовые процедуры, необходимо импортировать псевдомодуль
SYSTEM.

------------------------------------------------------------------------------
        Модуль RTL

  Все программы неявно используют модуль RTL. Компилятор транслирует
некоторые операции (проверка и охрана типа, сравнение строк, умножение,
деление и др.) как вызовы процедур этого модуля. Не следует явно вызывать эти
процедуры, за исключением процедур SetInt и SetTrap:

PROCEDURE SetTrap (trap: TRAPPROC)
где TRAPPROC = PROCEDURE (module, err: INTEGER)
назначить обработчик ошибок:
  module - адрес имени модуля
  err - младшие четыре бита - номер ошибки, остальное - номер строки

PROCEDURE SetInt (int: INTPROC)
где INTPROC = PROCEDURE (priority, ptr: INTEGER)
назначить обработчик прерываний:
  priority - приоритет прерывания:

  адрес    приоритет
  0FFFEH     31
  0FFFCH     30
  0FFFAH     29
  ...
  0FFC0H      0


  ptr - указатель на структуру:

  смещение    значение
     0:     priority
    +2:     сохраненное значение регистра SR
    +4:     сохраненное значение регистра PC

  Нельзя вызывать эту процедуру с параметром NIL, т. к. для экономии тактов,
значение адреса обработчика прерываний не проверяется на NIL.

------------------------------------------------------------------------------
        Обработка прерываний

  При появлении запроса на прерывание, процессор:
  - помещает в стэк значение регистра PC
  - помещает в стэк значение регистра SR
  - очищает регистр SR
  - выполняет переход по адресу IV[priority], где IV - вектор прерываний,
    priority - приоритет (номер элемента вектора) прерывания (0..30)

  Компилятор генерирует код обработки прерываний:

                   ; IV[0] = адрес следующей команды
  PUSH  #0         ; поместить в стэк приоритет прерывания
  JMP   Label      ; перейти к обработчику

                   ; IV[1] = адрес следующей команды
  PUSH  #1         ; поместить в стэк приоритет прерывания
  JMP   Label      ; перейти к обработчику

  ...
                   ; IV[priority] = адрес следующей команды
  PUSH  #priority  ; поместить в стэк приоритет прерывания
  JMP   Label      ; перейти к обработчику

  ...
                   ; IV[30] = адрес следующей команды
  PUSH  #30        ; поместить в стэк приоритет прерывания

  Label:
  MOV   SP, R13    ; настроить R13 на структуру данных прерывания (см. выше)
  PUSH  R4         ; сохранить рабочие регистры (R4 - R7)
  ...
  PUSH  R7
  PUSH  R13        ; передать параметр ptr в обработчик (см. выше)
  PUSH  @R13       ; передать параметр priority в обработчик (см. выше)
  CALL  int        ; вызвать обработчик (см. выше)
  ADD   #4, SP     ; удалить из стэка параметры обработчика
  POP   R7         ; восстановить рабочие регистры (R7 - R4)
  ...
  POP   R4
  ADD   #2, SP     ; удалить из стэка значение priority
  RETI             ; возврат из прерывания (восстановить SR и PC)

------------------------------------------------------------------------------
        Инициализация и финализация программы

  В начало программы компилятор вставляет команды для инициализации регистров
SP и R14, для остановки сторожевого таймера, а также назначает пустой
обработчик прерываний.

  В конец программы добавляет команду
  BIS #16, SR; выключить CPU

------------------------------------------------------------------------------
        Структура ОЗУ (RAM)

  начало -> | спец. переменные | глобальные переменные | куча/стэк | <- конец

  Компилятор поддерживает размер ОЗУ 128..2048 байт. ОЗУ начинается с адреса
200H. В нижних адресах располагаются специальные переменные RTL, и далее
пользовательские глобальные переменные. Оставшаяся часть памяти отводится для
кучи и стэка (не менее 64 байта). При старте программы, в регистр R14
записывается адрес начала области кучи/стэка, а регистр SP получает значение
(200H + размер_ОЗУ). При выделении памяти процедурой NEW, значение регистра
R14 увеличивается (если есть свободная память). Таким образом, стэк и куча
растут навстречу друг другу. Проверка переполнения стэка не производится.

------------------------------------------------------------------------------
        Структура ПЗУ (RОM)

  начало -> |код|свободная область|спец. данные|вектор прерываний| <- конец

  Компилятор поддерживает размер ПЗУ 4096..49152 байт. В верхних адресах
располагается вектор прерываний (64 байта), адреса 0FFC0H..0FFFFH.
Непосредственно перед ним размещаются специальные данные RTL. Программный
код начинается с адреса (10000H - размер_ПЗУ), этот адрес является также и
точкой входа в программу. Между кодом и спец. данными может оставаться
свободное пространство.